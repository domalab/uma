
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapters: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/domalab/uma/daemon/services/api/adapters/api_adapter.go (0.0%)</option>
				
				<option value="file1">github.com/domalab/uma/daemon/services/api/api.go (28.1%)</option>
				
				<option value="file2">github.com/domalab/uma/daemon/services/api/async_handlers.go (31.9%)</option>
				
				<option value="file3">github.com/domalab/uma/daemon/services/api/auth_handlers.go (0.0%)</option>
				
				<option value="file4">github.com/domalab/uma/daemon/services/api/bulk_operations.go (32.3%)</option>
				
				<option value="file5">github.com/domalab/uma/daemon/services/api/get-info.go (66.7%)</option>
				
				<option value="file6">github.com/domalab/uma/daemon/services/api/get-logs.go (0.0%)</option>
				
				<option value="file7">github.com/domalab/uma/daemon/services/api/handlers/auth.go (0.0%)</option>
				
				<option value="file8">github.com/domalab/uma/daemon/services/api/handlers/docker.go (39.4%)</option>
				
				<option value="file9">github.com/domalab/uma/daemon/services/api/handlers/docs.go (0.0%)</option>
				
				<option value="file10">github.com/domalab/uma/daemon/services/api/handlers/health.go (82.2%)</option>
				
				<option value="file11">github.com/domalab/uma/daemon/services/api/handlers/storage.go (0.0%)</option>
				
				<option value="file12">github.com/domalab/uma/daemon/services/api/handlers/system.go (35.2%)</option>
				
				<option value="file13">github.com/domalab/uma/daemon/services/api/handlers/test_utils.go (34.2%)</option>
				
				<option value="file14">github.com/domalab/uma/daemon/services/api/handlers/vm.go (0.0%)</option>
				
				<option value="file15">github.com/domalab/uma/daemon/services/api/handlers/websocket.go (0.0%)</option>
				
				<option value="file16">github.com/domalab/uma/daemon/services/api/http_server.go (29.8%)</option>
				
				<option value="file17">github.com/domalab/uma/daemon/services/api/metrics.go (53.2%)</option>
				
				<option value="file18">github.com/domalab/uma/daemon/services/api/middleware/auth.go (0.0%)</option>
				
				<option value="file19">github.com/domalab/uma/daemon/services/api/middleware/compression.go (47.5%)</option>
				
				<option value="file20">github.com/domalab/uma/daemon/services/api/middleware/cors.go (18.4%)</option>
				
				<option value="file21">github.com/domalab/uma/daemon/services/api/middleware/logging.go (65.7%)</option>
				
				<option value="file22">github.com/domalab/uma/daemon/services/api/middleware/metrics.go (76.9%)</option>
				
				<option value="file23">github.com/domalab/uma/daemon/services/api/middleware/request_id.go (37.5%)</option>
				
				<option value="file24">github.com/domalab/uma/daemon/services/api/middleware/versioning.go (56.2%)</option>
				
				<option value="file25">github.com/domalab/uma/daemon/services/api/openapi.go (58.5%)</option>
				
				<option value="file26">github.com/domalab/uma/daemon/services/api/openapi/config.go (0.0%)</option>
				
				<option value="file27">github.com/domalab/uma/daemon/services/api/openapi/generator.go (0.0%)</option>
				
				<option value="file28">github.com/domalab/uma/daemon/services/api/openapi/info.go (0.0%)</option>
				
				<option value="file29">github.com/domalab/uma/daemon/services/api/openapi/parameters/common.go (0.0%)</option>
				
				<option value="file30">github.com/domalab/uma/daemon/services/api/openapi/paths/async_operations.go (0.0%)</option>
				
				<option value="file31">github.com/domalab/uma/daemon/services/api/openapi/paths/auth.go (0.0%)</option>
				
				<option value="file32">github.com/domalab/uma/daemon/services/api/openapi/paths/docker.go (0.0%)</option>
				
				<option value="file33">github.com/domalab/uma/daemon/services/api/openapi/paths/storage.go (0.0%)</option>
				
				<option value="file34">github.com/domalab/uma/daemon/services/api/openapi/paths/system.go (0.0%)</option>
				
				<option value="file35">github.com/domalab/uma/daemon/services/api/openapi/paths/vm.go (0.0%)</option>
				
				<option value="file36">github.com/domalab/uma/daemon/services/api/openapi/paths/websocket.go (0.0%)</option>
				
				<option value="file37">github.com/domalab/uma/daemon/services/api/openapi/responses/common.go (0.0%)</option>
				
				<option value="file38">github.com/domalab/uma/daemon/services/api/openapi/schemas/async_operations.go (0.0%)</option>
				
				<option value="file39">github.com/domalab/uma/daemon/services/api/openapi/schemas/auth.go (0.0%)</option>
				
				<option value="file40">github.com/domalab/uma/daemon/services/api/openapi/schemas/common.go (0.0%)</option>
				
				<option value="file41">github.com/domalab/uma/daemon/services/api/openapi/schemas/docker.go (0.0%)</option>
				
				<option value="file42">github.com/domalab/uma/daemon/services/api/openapi/schemas/errors.go (0.0%)</option>
				
				<option value="file43">github.com/domalab/uma/daemon/services/api/openapi/schemas/rate_limiting.go (0.0%)</option>
				
				<option value="file44">github.com/domalab/uma/daemon/services/api/openapi/schemas/registry.go (0.0%)</option>
				
				<option value="file45">github.com/domalab/uma/daemon/services/api/openapi/schemas/storage.go (0.0%)</option>
				
				<option value="file46">github.com/domalab/uma/daemon/services/api/openapi/schemas/system.go (0.0%)</option>
				
				<option value="file47">github.com/domalab/uma/daemon/services/api/openapi/schemas/vm.go (0.0%)</option>
				
				<option value="file48">github.com/domalab/uma/daemon/services/api/openapi/schemas/websocket.go (0.0%)</option>
				
				<option value="file49">github.com/domalab/uma/daemon/services/api/origin.go (0.0%)</option>
				
				<option value="file50">github.com/domalab/uma/daemon/services/api/rate_limit_middleware.go (0.0%)</option>
				
				<option value="file51">github.com/domalab/uma/daemon/services/api/utils/metrics.go (0.0%)</option>
				
				<option value="file52">github.com/domalab/uma/daemon/services/api/utils/response.go (13.5%)</option>
				
				<option value="file53">github.com/domalab/uma/daemon/services/api/utils/validation.go (12.8%)</option>
				
				<option value="file54">github.com/domalab/uma/daemon/services/api/utils/websocket.go (0.0%)</option>
				
				<option value="file55">github.com/domalab/uma/daemon/services/api/validation.go (95.5%)</option>
				
				<option value="file56">github.com/domalab/uma/daemon/services/api/validation_enhanced.go (0.0%)</option>
				
				<option value="file57">github.com/domalab/uma/daemon/services/api/vm_handlers.go (0.0%)</option>
				
				<option value="file58">github.com/domalab/uma/daemon/services/api/websocket.go (8.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adapters

import (
        "github.com/domalab/uma/daemon/services/api/utils"
)

// APIAdapter adapts the existing API to our new interface structure
type APIAdapter struct {
        api interface{} // Will hold the original *Api instance
}

// NewAPIAdapter creates a new API adapter
func NewAPIAdapter(api interface{}) *APIAdapter <span class="cov0" title="0">{
        return &amp;APIAdapter{api: api}
}</span>

// GetInfo returns general API information
func (a *APIAdapter) GetInfo() interface{} <span class="cov0" title="0">{
        // Implementation would call the original API's info method
        // For now, return placeholder
        return map[string]interface{}{
                "service": "UMA API",
                "version": "1.0.0",
                "status":  "running",
        }
}</span>

// GetSystem returns the system interface
func (a *APIAdapter) GetSystem() utils.SystemInterface <span class="cov0" title="0">{
        return &amp;SystemAdapter{api: a.api}
}</span>

// GetStorage returns the storage interface
func (a *APIAdapter) GetStorage() utils.StorageInterface <span class="cov0" title="0">{
        return &amp;StorageAdapter{api: a.api}
}</span>

// GetDocker returns the Docker interface
func (a *APIAdapter) GetDocker() utils.DockerInterface <span class="cov0" title="0">{
        return &amp;DockerAdapter{api: a.api}
}</span>

// GetVM returns the VM interface
func (a *APIAdapter) GetVM() utils.VMInterface <span class="cov0" title="0">{
        return &amp;VMAdapter{api: a.api}
}</span>

// GetAuth returns the auth interface
func (a *APIAdapter) GetAuth() utils.AuthInterface <span class="cov0" title="0">{
        return &amp;AuthAdapter{api: a.api}
}</span>

// SystemAdapter adapts system operations
type SystemAdapter struct {
        api interface{}
}

func (s *SystemAdapter) GetCPUInfo() (interface{}, error) <span class="cov0" title="0">{
        // Implementation would call original API methods
        return map[string]interface{}{
                "usage":       0.0,
                "temperature": 0.0,
                "cores":       0,
                "model":       "Unknown",
        }, nil
}</span>

func (s *SystemAdapter) GetMemoryInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "total":     0,
                "used":      0,
                "free":      0,
                "available": 0,
                "usage":     0.0,
        }, nil
}</span>

func (s *SystemAdapter) GetLoadInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "load1":  0.0,
                "load5":  0.0,
                "load15": 0.0,
        }, nil
}</span>

func (s *SystemAdapter) GetUptimeInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "uptime": "0d 0h 0m 0s",
        }, nil
}</span>

func (s *SystemAdapter) GetNetworkInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "interfaces": []interface{}{},
        }, nil
}</span>

func (s *SystemAdapter) GetEnhancedTemperatureData() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "sensors": []interface{}{},
                "fans":    []interface{}{},
        }, nil
}</span>

// StorageAdapter adapts storage operations
type StorageAdapter struct {
        api interface{}
}

func (s *StorageAdapter) GetArrayInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "state":       "unknown",
                "protection":  "unknown",
                "disks":       []interface{}{},
                "parity":      []interface{}{},
        }, nil
}</span>

func (s *StorageAdapter) GetDisks() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (s *StorageAdapter) GetZFSPools() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (s *StorageAdapter) GetCacheInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "pools": []interface{}{},
        }, nil
}</span>

func (s *StorageAdapter) StartArray(request interface{}) error <span class="cov0" title="0">{
        // Implementation would call original API methods
        return nil
}</span>

func (s *StorageAdapter) StopArray(request interface{}) error <span class="cov0" title="0">{
        // Implementation would call original API methods
        return nil
}</span>

// DockerAdapter adapts Docker operations
type DockerAdapter struct {
        api interface{}
}

func (d *DockerAdapter) GetContainers() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (d *DockerAdapter) GetContainer(id string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "id":     id,
                "name":   "unknown",
                "status": "unknown",
        }, nil
}</span>

func (d *DockerAdapter) StartContainer(id string) error <span class="cov0" title="0">{
        return nil
}</span>

func (d *DockerAdapter) StopContainer(id string) error <span class="cov0" title="0">{
        return nil
}</span>

func (d *DockerAdapter) RestartContainer(id string) error <span class="cov0" title="0">{
        return nil
}</span>

func (d *DockerAdapter) GetImages() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (d *DockerAdapter) GetNetworks() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (d *DockerAdapter) GetSystemInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "version":    "unknown",
                "containers": 0,
                "images":     0,
        }, nil
}</span>

// VMAdapter adapts VM operations
type VMAdapter struct {
        api interface{}
}

func (v *VMAdapter) GetVMs() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (v *VMAdapter) GetVM(name string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":   name,
                "status": "unknown",
        }, nil
}</span>

func (v *VMAdapter) StartVM(name string) error <span class="cov0" title="0">{
        return nil
}</span>

func (v *VMAdapter) StopVM(name string) error <span class="cov0" title="0">{
        return nil
}</span>

func (v *VMAdapter) RestartVM(name string) error <span class="cov0" title="0">{
        return nil
}</span>

func (v *VMAdapter) GetVMStats(name string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        name,
                "cpu_percent": 0.0,
                "memory_used": 0,
        }, nil
}</span>

func (v *VMAdapter) GetVMConsole(name string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "vnc",
                "host": "localhost",
                "port": 5900,
        }, nil
}</span>

func (v *VMAdapter) SetVMAutostart(name string, autostart bool) error <span class="cov0" title="0">{
        return nil
}</span>

// AuthAdapter adapts auth operations
type AuthAdapter struct {
        api interface{}
}

func (a *AuthAdapter) Login(username, password string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "access_token": "placeholder_token",
                "token_type":   "Bearer",
                "expires_in":   3600,
        }, nil
}</span>

func (a *AuthAdapter) GetUsers() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (a *AuthAdapter) GetStats() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "total_users":    0,
                "active_users":   0,
                "total_sessions": 0,
        }, nil
}</span>

func (a *AuthAdapter) IsEnabled() bool <span class="cov0" title="0">{
        return false // Placeholder
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "log"
        "net"
        "os"
        "time"

        "github.com/domalab/uma/daemon/common"
        "github.com/domalab/uma/daemon/domain"
        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/logger"
        "github.com/domalab/uma/daemon/plugins/diagnostics"
        "github.com/domalab/uma/daemon/plugins/docker"
        "github.com/domalab/uma/daemon/plugins/gpu"
        "github.com/domalab/uma/daemon/plugins/notifications"
        "github.com/domalab/uma/daemon/plugins/sensor"
        "github.com/domalab/uma/daemon/plugins/storage"
        "github.com/domalab/uma/daemon/plugins/system"
        "github.com/domalab/uma/daemon/plugins/ups"
        "github.com/domalab/uma/daemon/plugins/vm"
        "github.com/domalab/uma/daemon/services/async"
        "github.com/domalab/uma/daemon/services/auth"
        "github.com/domalab/uma/daemon/services/cache"
        "github.com/domalab/uma/daemon/services/config"
)

type Api struct {
        ctx *domain.Context

        // Unix socket listener
        listener net.Listener

        // HTTP server
        httpServer *HTTPServer

        // Services
        configManager        *config.Manager
        authService          *auth.AuthService
        rateLimiter          *auth.RateLimiter
        operationRateLimiter *auth.OperationRateLimiter
        asyncManager         *async.AsyncManager

        // Data providers
        origin        *dto.Origin
        sensor        sensor.Sensor
        ups           ups.Ups
        storage       *storage.StorageMonitor
        system        *system.SystemMonitor
        gpu           *gpu.GPUMonitor
        docker        *docker.DockerManager
        vm            *vm.VMManager
        diagnostics   *diagnostics.DiagnosticsManager
        notifications *notifications.NotificationManager
}

func Create(ctx *domain.Context) *Api <span class="cov8" title="1">{
        // Initialize configuration manager
        configManager := config.NewManager("")
        if err := configManager.Load(); err != nil </span><span class="cov8" title="1">{
                logger.Yellow("Failed to load configuration: %v", err)
        }</span>

        // Update context with loaded configuration
        <span class="cov8" title="1">loadedConfig := configManager.GetConfig()
        ctx.Config.Version = loadedConfig.Version
        if ctx.Config.Version == "" || ctx.Config.Version == "unknown" </span><span class="cov8" title="1">{
                ctx.Config.Version = loadedConfig.Version
        }</span>

        // Initialize authentication service
        <span class="cov8" title="1">authService := auth.NewAuthService(loadedConfig.Auth)

        // Initialize rate limiter (100 requests per minute)
        rateLimiter := auth.NewRateLimiter(100, time.Minute)

        // Initialize operation-specific rate limiter
        operationRateLimiter := auth.NewOperationRateLimiter()

        // Initialize async manager
        asyncManager := async.NewAsyncManager()

        api := &amp;Api{
                ctx:                  ctx,
                configManager:        configManager,
                authService:          authService,
                rateLimiter:          rateLimiter,
                operationRateLimiter: operationRateLimiter,
                asyncManager:         asyncManager,
        }

        // Initialize HTTP server if enabled
        if loadedConfig.HTTPServer.Enabled </span><span class="cov8" title="1">{
                api.httpServer = NewHTTPServer(api, loadedConfig.HTTPServer.Port)
        }</span>

        <span class="cov8" title="1">return api</span>
}

func (a *Api) Run() error <span class="cov0" title="0">{
        // Initialize all monitoring plugins
        a.sensor = a.createSensor()
        a.ups = a.createUps()
        a.storage = storage.NewStorageMonitor()
        a.system = system.NewSystemMonitor()
        a.gpu = gpu.NewGPUMonitor()
        a.docker = docker.NewDockerManager()
        a.vm = vm.NewVMManager()
        a.diagnostics = diagnostics.NewDiagnosticsManager()
        a.notifications = notifications.NewNotificationManager()

        // Initialize cache system
        cache.InitializeGlobalInvalidator()

        // Register async operation executors
        a.registerAsyncExecutors()

        // Start HTTP server if configured
        if a.httpServer != nil </span><span class="cov0" title="0">{
                if err := a.httpServer.Start(); err != nil </span><span class="cov0" title="0">{
                        logger.Yellow("Failed to start HTTP server: %v", err)
                }</span>
        }

        // Start Unix socket server
        <span class="cov0" title="0">go a.startUnixSocketServer()

        return nil</span>
}

// startUnixSocketServer starts the Unix socket API server
func (a *Api) startUnixSocketServer() <span class="cov0" title="0">{
        // make sure there's no socket file
        os.Remove(common.Socket)

        var err error
        a.listener, err = net.Listen("unix", common.Socket)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen on %s: %v", common.Socket, err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                a.listener.Close()
                os.Remove(common.Socket)
        }</span>()

        <span class="cov0" title="0">logger.Blue("Unix socket API listening on %s", common.Socket)

        for </span><span class="cov0" title="0">{
                conn, err := a.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Error accepting connection:", err)
                        continue</span>
                }

                <span class="cov0" title="0">go a.handleUnixSocketConnection(conn)</span>
        }
}

// Stop gracefully stops all API servers
func (a *Api) Stop() error <span class="cov8" title="1">{
        logger.Blue("Stopping API services...")

        // Stop HTTP server
        if a.httpServer != nil </span><span class="cov8" title="1">{
                if err := a.httpServer.Stop(); err != nil </span><span class="cov0" title="0">{
                        logger.Yellow("Error stopping HTTP server: %v", err)
                }</span>
        }

        // Stop async manager
        <span class="cov8" title="1">if a.asyncManager != nil </span><span class="cov8" title="1">{
                a.asyncManager.Stop()
        }</span>

        // Stop cache system
        <span class="cov8" title="1">cache.GetGlobalCacheManager().Stop()

        // Stop Unix socket server
        if a.listener != nil </span><span class="cov0" title="0">{
                a.listener.Close()
                os.Remove(common.Socket)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// handleUnixSocketConnection handles Unix socket connections (legacy API)
func (a *Api) handleUnixSocketConnection(conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()

        var req dto.Request
        err := json.NewDecoder(conn).Decode(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error decoding request: %v", err)
                conn.Write([]byte(`{"error": "Invalid request"}` + "\n"))
                return
        }</span>

        <span class="cov0" title="0">logger.LightGreen("received %+v ", req)

        var resp []byte
        switch req.Action </span>{
        case "get_info":<span class="cov0" title="0">
                reply := a.getInfo()
                resp, _ = json.Marshal(reply)</span>

        case "get_logs":<span class="cov0" title="0">
                params := req.Params
                logType := params["logType"]
                reply := a.getLogs(logType)
                resp, _ = json.Marshal(reply)</span>

        case "get_origin":<span class="cov0" title="0">
                reply := a.getOrigin()
                resp, _ = json.Marshal(reply)</span>

        default:<span class="cov0" title="0">
                resp, _ = json.Marshal(map[string]string{"error": "Unsupported action"})</span>
        }

        <span class="cov0" title="0">logger.Yellow(" sending %+v", string(resp))

        conn.Write(resp)
        conn.Write([]byte("\n"))</span>
}

func (a *Api) createSensor() sensor.Sensor <span class="cov8" title="1">{
        s, err := sensor.IdentifySensor()
        if err != nil </span><span class="cov0" title="0">{
                logger.Yellow("error identifying sensor: %s", err)
        }</span> else<span class="cov8" title="1"> {
                switch s </span>{
                case sensor.SYSTEM:<span class="cov0" title="0">
                        logger.Blue("created system sensor ...")
                        return sensor.NewSystemSensor()</span>
                case sensor.IPMI:<span class="cov0" title="0">
                        logger.Blue("created ipmi sensor ...")
                        return sensor.NewIpmiSensor()</span>
                }
        }

        <span class="cov8" title="1">logger.Blue("no sensor detected ...")

        return sensor.NewNoSensor()</span>
}

func (a *Api) createUps() ups.Ups <span class="cov8" title="1">{
        logger.Blue("showing ups %t ...", a.ctx.Config.ShowUps)
        if a.ctx.Config.ShowUps </span><span class="cov0" title="0">{
                u, err := ups.IdentifyUps()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Yellow("error identifying ups: %s", err)
                }</span> else<span class="cov0" title="0"> {
                        switch u </span>{
                        case ups.APC:<span class="cov0" title="0">
                                logger.Blue("created apc ups ...")
                                return ups.NewApc()</span>
                        case ups.NUT:<span class="cov0" title="0">
                                logger.Blue("created nut ups ...")
                                return ups.NewNut()</span>
                        }
                }
        }

        <span class="cov8" title="1">logger.Blue("no ups detected ...")

        return ups.NewNoUps()</span>
}

// registerAsyncExecutors registers all async operation executors
func (a *Api) registerAsyncExecutors() <span class="cov0" title="0">{
        // Create adapters for existing services
        storageAdapter := async.NewStorageMonitorAdapter(a.storage)
        dockerAdapter := async.NewDockerManagerAdapter(a.docker)

        // Register parity check executor
        parityExecutor := async.NewParityCheckExecutor(storageAdapter)
        a.asyncManager.RegisterExecutor(parityExecutor)

        // Register array operation executors
        arrayStartExecutor := async.NewArrayStartExecutor(storageAdapter)
        a.asyncManager.RegisterExecutor(arrayStartExecutor)

        arrayStopExecutor := async.NewArrayStopExecutor(storageAdapter)
        a.asyncManager.RegisterExecutor(arrayStopExecutor)

        // Register SMART scan executor
        smartExecutor := async.NewSMARTScanExecutor(storageAdapter)
        a.asyncManager.RegisterExecutor(smartExecutor)

        // Register bulk container executor
        bulkContainerExecutor := async.NewBulkContainerExecutor(dockerAdapter)
        a.asyncManager.RegisterExecutor(bulkContainerExecutor)

        logger.Blue("Registered %d async operation executors", 5)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/domalab/uma/daemon/logger"
        "github.com/domalab/uma/daemon/services/async"
)

// AsyncOperationsHandler handles GET /api/v1/operations
func (h *HTTPServer) AsyncOperationsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Apply rate limiting
        if !h.api.rateLimiter.Allow(getClientIP(r)) </span><span class="cov0" title="0">{
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
        }</span>

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                h.listOperations(w, r)</span>
        case "POST":<span class="cov8" title="1">
                h.startOperation(w, r)</span>
        case "OPTIONS":<span class="cov0" title="0">
                h.handleCORS(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// AsyncOperationHandler handles GET/DELETE /api/v1/operations/{id}
func (h *HTTPServer) AsyncOperationHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Apply rate limiting
        if !h.api.rateLimiter.Allow(getClientIP(r)) </span><span class="cov0" title="0">{
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
        }</span>

        // Extract operation ID from URL
        <span class="cov0" title="0">pathParts := strings.Split(r.URL.Path, "/")
        if len(pathParts) &lt; 5 </span><span class="cov0" title="0">{
                http.Error(w, "Invalid operation ID", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">operationID := pathParts[4]

        switch r.Method </span>{
        case "GET":<span class="cov0" title="0">
                h.getOperation(w, r, operationID)</span>
        case "DELETE":<span class="cov0" title="0">
                h.cancelOperation(w, r, operationID)</span>
        case "OPTIONS":<span class="cov0" title="0">
                h.handleCORS(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// listOperations handles GET /api/v1/operations
func (h *HTTPServer) listOperations(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Parse query parameters for filtering
        status := async.OperationStatus(r.URL.Query().Get("status"))
        operationType := async.OperationType(r.URL.Query().Get("type"))

        // Get operations from async manager
        response := h.api.asyncManager.ListOperations(status, operationType)

        // Create standard response
        standardResponse := map[string]interface{}{
                "data": response,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "request_id":  r.Header.Get("X-Request-ID"),
                        "api_version": "v1",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(standardResponse); err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to encode operations response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">logger.Green("Listed %d operations (status: %s, type: %s)",
                response.Total, status, operationType)</span>
}

// startOperation handles POST /api/v1/operations
func (h *HTTPServer) startOperation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req async.OperationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Validate request
        <span class="cov8" title="1">if req.Type == "" </span><span class="cov0" title="0">{
                http.Error(w, "Operation type is required", http.StatusBadRequest)
                return
        }</span>

        // Get user from context (if authenticated)
        <span class="cov8" title="1">createdBy := "anonymous"
        if userID := r.Header.Get("X-User-ID"); userID != "" </span><span class="cov0" title="0">{
                createdBy = userID
        }</span>

        // Start the operation
        <span class="cov8" title="1">operation, err := h.api.asyncManager.StartOperation(req, createdBy)
        if err != nil </span><span class="cov8" title="1">{
                requestID := r.Header.Get("X-Request-ID")
                logger.LogErrorWithContext("async", "start_operation", err, requestID, map[string]interface{}{
                        "operation_type": req.Type,
                        "created_by":     createdBy,
                        "description":    req.Description,
                })
                logger.Red("Failed to start operation %s: %v", req.Type, err)
                http.Error(w, fmt.Sprintf("Failed to start operation: %v", err), http.StatusBadRequest)
                return
        }</span>

        // Create response
        <span class="cov0" title="0">response := async.OperationResponse{
                ID:          operation.ID,
                Type:        operation.Type,
                Status:      operation.Status,
                Description: operation.Description,
                Cancellable: operation.Cancellable,
                Started:     operation.Started,
        }

        // Create standard response
        standardResponse := map[string]interface{}{
                "data": response,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "request_id":  r.Header.Get("X-Request-ID"),
                        "api_version": "v1",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(standardResponse); err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to encode operation response: %v", err)
                return
        }</span>

        // Log successful operation start with structured logging
        <span class="cov0" title="0">requestID := r.Header.Get("X-Request-ID")
        logger.LogAsyncOperation(operation.ID, string(operation.Type), "started", 0, requestID, map[string]interface{}{
                "description": operation.Description,
                "cancellable": operation.Cancellable,
                "created_by":  createdBy,
        })
        logger.Green("Started async operation %s (%s) by %s",
                operation.ID, operation.Type, createdBy)</span>
}

// getOperation handles GET /api/v1/operations/{id}
func (h *HTTPServer) getOperation(w http.ResponseWriter, r *http.Request, operationID string) <span class="cov0" title="0">{
        operation, err := h.api.asyncManager.GetOperation(operationID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Operation not found", http.StatusNotFound)
                return
        }</span>

        // Create standard response
        <span class="cov0" title="0">standardResponse := map[string]interface{}{
                "data": operation,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "request_id":  r.Header.Get("X-Request-ID"),
                        "api_version": "v1",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(standardResponse); err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to encode operation response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// cancelOperation handles DELETE /api/v1/operations/{id}
func (h *HTTPServer) cancelOperation(w http.ResponseWriter, r *http.Request, operationID string) <span class="cov0" title="0">{
        err := h.api.asyncManager.CancelOperation(operationID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Yellow("Failed to cancel operation %s: %v", operationID, err)
                http.Error(w, fmt.Sprintf("Failed to cancel operation: %v", err), http.StatusBadRequest)
                return
        }</span>

        // Create success response
        <span class="cov0" title="0">response := map[string]interface{}{
                "success": true,
                "message": fmt.Sprintf("Operation %s cancelled successfully", operationID),
        }

        standardResponse := map[string]interface{}{
                "data": response,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "request_id":  r.Header.Get("X-Request-ID"),
                        "api_version": "v1",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(standardResponse); err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to encode cancel response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Log successful cancellation with structured logging
        <span class="cov0" title="0">requestID := r.Header.Get("X-Request-ID")
        logger.LogAsyncOperation(operationID, "unknown", "cancelled", 0, requestID, map[string]interface{}{
                "cancelled_by": "user",
        })
        logger.Green("Cancelled async operation %s", operationID)</span>
}

// AsyncStatsHandler handles GET /api/v1/operations/stats
func (h *HTTPServer) AsyncStatsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Apply rate limiting
        if !h.api.rateLimiter.Allow(getClientIP(r)) </span><span class="cov0" title="0">{
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
        }</span>

        <span class="cov8" title="1">if r.Method != "GET" </span><span class="cov0" title="0">{
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        h.handleCORS(w, r)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return</span>
        }

        // Get stats from async manager
        <span class="cov8" title="1">stats := h.api.asyncManager.GetStats()

        // Create standard response
        standardResponse := map[string]interface{}{
                "data": stats,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "request_id":  r.Header.Get("X-Request-ID"),
                        "api_version": "v1",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(standardResponse); err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to encode stats response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// Helper function to get current timestamp
func getCurrentTimestamp() int64 <span class="cov8" title="1">{
        return 1640995200 // This would be time.Now().Unix() in real implementation
}</span>

// Helper function to get client IP
func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check X-Forwarded-For header first
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                // Take the first IP if multiple are present
                if idx := strings.Index(xff, ","); idx != -1 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(xff[:idx])
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(xff)</span>
        }

        // Check X-Real-IP header
        <span class="cov8" title="1">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(xri)
        }</span>

        // Fall back to RemoteAddr
        <span class="cov8" title="1">if idx := strings.LastIndex(r.RemoteAddr, ":"); idx != -1 </span><span class="cov8" title="1">{
                return r.RemoteAddr[:idx]
        }</span>
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

// Helper function to handle CORS
func (h *HTTPServer) handleCORS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID")
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/go-chi/chi/v5"
        "github.com/domalab/uma/daemon/services/auth"
)

// LoginRequest represents a login request
type LoginRequest struct {
        APIKey string `json:"api_key" validate:"required"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        Token string     `json:"token"`
        User  *auth.User `json:"user"`
}

// CreateUserRequest represents a user creation request
type CreateUserRequest struct {
        Username string    `json:"username" validate:"required"`
        Role     auth.Role `json:"role" validate:"required"`
}

// UpdateUserRequest represents a user update request
type UpdateUserRequest struct {
        Role   *auth.Role `json:"role,omitempty"`
        Active *bool      `json:"active,omitempty"`
}

// handleAuthLogin handles POST /api/v1/auth/login
func (h *HTTPServer) handleAuthLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON")
                return
        }</span>

        // Validate API key and get user
        <span class="cov0" title="0">user, err := h.authService.ValidateAPIKey(req.APIKey)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusUnauthorized, err.Error())
                return
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := h.authService.GenerateJWT(user)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to generate token")
                return
        }</span>

        <span class="cov0" title="0">response := LoginResponse{
                Token: token,
                User:  user,
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleAuthToken handles POST /api/v1/auth/token (alias for login)
func (h *HTTPServer) handleAuthToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.handleAuthLogin(w, r)
}</span>

// handleAuthUsers handles GET /api/v1/auth/users
func (h *HTTPServer) handleAuthUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">users, err := h.authService.GetUsers()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusOK, users, nil)</span>
}

// handleAuthCreateUser handles POST /api/v1/auth/users
func (h *HTTPServer) handleAuthCreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">var req CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON")
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        // Validate role
        <span class="cov0" title="0">if req.Role != auth.RoleAdmin &amp;&amp; req.Role != auth.RoleOperator &amp;&amp; req.Role != auth.RoleViewer </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid role. Must be admin, operator, or viewer")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.CreateUser(req.Username, req.Role)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusCreated, user, nil)</span>
}

// handleAuthGetUser handles GET /api/v1/auth/users/{id}
func (h *HTTPServer) handleAuthGetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">userID := chi.URLParam(r, "id")
        if userID == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "User ID is required")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.GetUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusOK, user, nil)</span>
}

// handleAuthUpdateUser handles PUT /api/v1/auth/users/{id}
func (h *HTTPServer) handleAuthUpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPut </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">userID := chi.URLParam(r, "id")
        if userID == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "User ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req UpdateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON")
                return
        }</span>

        // Build updates map
        <span class="cov0" title="0">updates := make(map[string]interface{})
        if req.Role != nil </span><span class="cov0" title="0">{
                // Validate role
                if *req.Role != auth.RoleAdmin &amp;&amp; *req.Role != auth.RoleOperator &amp;&amp; *req.Role != auth.RoleViewer </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid role. Must be admin, operator, or viewer")
                        return
                }</span>
                <span class="cov0" title="0">updates["role"] = string(*req.Role)</span>
        }
        <span class="cov0" title="0">if req.Active != nil </span><span class="cov0" title="0">{
                updates["active"] = *req.Active
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "No updates provided")
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.UpdateUser(userID, updates)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusOK, map[string]string{"message": "User updated successfully"}, nil)</span>
}

// handleAuthDeleteUser handles DELETE /api/v1/auth/users/{id}
func (h *HTTPServer) handleAuthDeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">userID := chi.URLParam(r, "id")
        if userID == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "User ID is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.DeleteUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusOK, map[string]string{"message": "User deleted successfully"}, nil)</span>
}

// handleAuthRegenerateKey handles POST /api/v1/auth/users/{id}/regenerate-key
func (h *HTTPServer) handleAuthRegenerateKey(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">userID := chi.URLParam(r, "id")
        if userID == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "User ID is required")
                return
        }</span>

        <span class="cov0" title="0">newAPIKey, err := h.authService.RegenerateAPIKey(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response := map[string]string{
                "message": "API key regenerated successfully",
                "api_key": newAPIKey,
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleAuthStats handles GET /api/v1/auth/stats
func (h *HTTPServer) handleAuthStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if h.authService == nil || !h.authService.IsEnabled() </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotImplemented, "Authentication is disabled")
                return
        }</span>

        <span class="cov0" title="0">stats := h.authService.GetAuthStats()
        h.writeStandardResponse(w, http.StatusOK, stats, nil)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/logger"
)

// BulkOperationRequest represents a bulk operation request
type BulkOperationRequest struct {
        ContainerIDs []string `json:"container_ids"`
}

// BulkOperationResponse represents a bulk operation response
type BulkOperationResponse struct {
        Operation string                     `json:"operation"`
        Results   []ContainerOperationResult `json:"results"`
        Summary   BulkOperationSummary       `json:"summary"`
}

// ContainerOperationResult represents the result of an operation on a single container
type ContainerOperationResult struct {
        ContainerID   string `json:"container_id"`
        ContainerName string `json:"container_name,omitempty"`
        Success       bool   `json:"success"`
        Error         string `json:"error,omitempty"`
        Duration      string `json:"duration,omitempty"`
}

// BulkOperationSummary provides a summary of the bulk operation
type BulkOperationSummary struct {
        Total     int `json:"total"`
        Succeeded int `json:"succeeded"`
        Failed    int `json:"failed"`
}

// handleDockerBulkStart handles POST /api/v1/docker/containers/bulk/start
func (h *HTTPServer) handleDockerBulkStart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">h.handleDockerBulkOperation(w, r, "start")</span>
}

// handleDockerBulkStop handles POST /api/v1/docker/containers/bulk/stop
func (h *HTTPServer) handleDockerBulkStop(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">h.handleDockerBulkOperation(w, r, "stop")</span>
}

// handleDockerBulkRestart handles POST /api/v1/docker/containers/bulk/restart
func (h *HTTPServer) handleDockerBulkRestart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">h.handleDockerBulkOperation(w, r, "restart")</span>
}

// handleDockerBulkOperation handles bulk Docker operations
func (h *HTTPServer) handleDockerBulkOperation(w http.ResponseWriter, r *http.Request, operation string) <span class="cov8" title="1">{
        // Parse request body
        var request BulkOperationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request body")
                return
        }</span>

        // Validate request using enhanced validation
        <span class="cov8" title="1">if err := h.validateBulkRequest(&amp;request); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get request metadata and track timing
        <span class="cov8" title="1">requestID := h.getRequestIDFromContext(r)
        startTime := time.Now()
        logger.Green("Starting bulk %s operation for %d containers [%s]", operation, len(request.ContainerIDs), requestID)

        // Perform bulk operation
        results := h.performBulkDockerOperation(request.ContainerIDs, operation)

        // Calculate summary
        summary := BulkOperationSummary{
                Total: len(results),
        }
        for _, result := range results </span><span class="cov8" title="1">{
                if result.Success </span><span class="cov0" title="0">{
                        summary.Succeeded++
                }</span> else<span class="cov8" title="1"> {
                        summary.Failed++
                }</span>
        }

        // Create response
        <span class="cov8" title="1">response := BulkOperationResponse{
                Operation: operation,
                Results:   results,
                Summary:   summary,
        }

        // Record metrics for the bulk operation
        operationDuration := time.Since(startTime)
        RecordBulkOperation(operation, summary.Total, summary.Succeeded, summary.Failed, operationDuration, requestID)

        // Use standardized response format
        h.writeStandardResponse(w, http.StatusOK, response, nil)

        logger.Green("Bulk %s operation completed: %d succeeded, %d failed [%s]",
                operation, summary.Succeeded, summary.Failed, requestID)</span>
}

// performBulkDockerOperation performs the actual bulk operation on containers
func (h *HTTPServer) performBulkDockerOperation(containerIDs []string, operation string) []ContainerOperationResult <span class="cov8" title="1">{
        results := make([]ContainerOperationResult, len(containerIDs))

        // Get container information first to validate IDs and get names
        containers, err := h.api.docker.ListContainers(true) // Include all containers
        if err != nil </span><span class="cov0" title="0">{
                // If we can't list containers, mark all as failed
                for i, containerID := range containerIDs </span><span class="cov0" title="0">{
                        results[i] = ContainerOperationResult{
                                ContainerID: containerID,
                                Success:     false,
                                Error:       "Failed to list containers: " + err.Error(),
                        }
                }</span>
                <span class="cov0" title="0">return results</span>
        }

        // Create a map for quick container lookup
        <span class="cov8" title="1">containerMap := make(map[string]string) // ID -&gt; Name
        for _, container := range containers </span><span class="cov8" title="1">{
                containerMap[container.ID] = container.Name
                // Also allow lookup by name
                containerMap[container.Name] = container.Name
        }</span>

        // Perform operation on each container
        <span class="cov8" title="1">for i, containerID := range containerIDs </span><span class="cov8" title="1">{
                startTime := time.Now()

                // Check if container exists
                containerName, exists := containerMap[containerID]
                if !exists </span><span class="cov8" title="1">{
                        results[i] = ContainerOperationResult{
                                ContainerID: containerID,
                                Success:     false,
                                Error:       "Container not found",
                                Duration:    time.Since(startTime).String(),
                        }
                        continue</span>
                }

                // Perform the operation
                <span class="cov0" title="0">var err error
                switch operation </span>{
                case "start":<span class="cov0" title="0">
                        err = h.api.docker.StartContainer(containerID)</span>
                case "stop":<span class="cov0" title="0">
                        err = h.api.docker.StopContainer(containerID, 10)</span> // 10 second timeout
                case "restart":<span class="cov0" title="0">
                        err = h.api.docker.RestartContainer(containerID, 10)</span> // 10 second timeout
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("unsupported operation: %s", operation)</span>
                }

                // Record result
                <span class="cov0" title="0">results[i] = ContainerOperationResult{
                        ContainerID:   containerID,
                        ContainerName: containerName,
                        Success:       err == nil,
                        Duration:      time.Since(startTime).String(),
                }

                if err != nil </span><span class="cov0" title="0">{
                        results[i].Error = err.Error()
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// validateBulkOperationRequest validates a bulk operation request
func (h *HTTPServer) validateBulkOperationRequest(request *BulkOperationRequest) error <span class="cov0" title="0">{
        if len(request.ContainerIDs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("container_ids array cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(request.ContainerIDs) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum 50 containers allowed per bulk operation")
        }</span>

        // Check for duplicate container IDs
        <span class="cov0" title="0">seen := make(map[string]bool)
        for _, containerID := range request.ContainerIDs </span><span class="cov0" title="0">{
                if containerID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("container ID cannot be empty")
                }</span>
                <span class="cov0" title="0">if seen[containerID] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate container ID: %s", containerID)
                }</span>
                <span class="cov0" title="0">seen[containerID] = true</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Enhanced bulk operation with better error handling and validation
func (h *HTTPServer) handleEnhancedDockerBulkOperation(w http.ResponseWriter, r *http.Request, operation string) <span class="cov0" title="0">{
        // Parse request body
        var request BulkOperationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request body: "+err.Error())
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateBulkOperationRequest(&amp;request); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get request metadata
        <span class="cov0" title="0">requestID := h.getRequestIDFromContext(r)
        logger.Green("Starting enhanced bulk %s operation for %d containers [%s]", operation, len(request.ContainerIDs), requestID)

        // Perform bulk operation with enhanced error handling
        results := h.performEnhancedBulkDockerOperation(request.ContainerIDs, operation)

        // Calculate summary
        summary := BulkOperationSummary{
                Total: len(results),
        }
        for _, result := range results </span><span class="cov0" title="0">{
                if result.Success </span><span class="cov0" title="0">{
                        summary.Succeeded++
                }</span> else<span class="cov0" title="0"> {
                        summary.Failed++
                }</span>
        }

        // Create response
        <span class="cov0" title="0">response := BulkOperationResponse{
                Operation: operation,
                Results:   results,
                Summary:   summary,
        }

        // Determine HTTP status code based on results
        statusCode := http.StatusOK
        if summary.Failed &gt; 0 &amp;&amp; summary.Succeeded == 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusBadRequest // All operations failed
        }</span> else<span class="cov0" title="0"> if summary.Failed &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus // Partial success
        }</span>

        // Use standardized response format
        <span class="cov0" title="0">h.writeStandardResponse(w, statusCode, response, nil)

        logger.Green("Enhanced bulk %s operation completed: %d succeeded, %d failed [%s]",
                operation, summary.Succeeded, summary.Failed, requestID)</span>
}

// performEnhancedBulkDockerOperation performs bulk operations with enhanced error handling
func (h *HTTPServer) performEnhancedBulkDockerOperation(containerIDs []string, operation string) []ContainerOperationResult <span class="cov0" title="0">{
        results := make([]ContainerOperationResult, len(containerIDs))

        // Get container information first
        containers, err := h.api.docker.ListContainers(true)
        if err != nil </span><span class="cov0" title="0">{
                for i, containerID := range containerIDs </span><span class="cov0" title="0">{
                        results[i] = ContainerOperationResult{
                                ContainerID: containerID,
                                Success:     false,
                                Error:       "Failed to list containers: " + err.Error(),
                        }
                }</span>
                <span class="cov0" title="0">return results</span>
        }

        // Create container lookup maps
        <span class="cov0" title="0">containerByID := make(map[string]interface{})
        containerByName := make(map[string]interface{})

        for _, container := range containers </span><span class="cov0" title="0">{
                containerByID[container.ID] = container
                containerByName[container.Name] = container
        }</span>

        // Process each container
        <span class="cov0" title="0">for i, containerID := range containerIDs </span><span class="cov0" title="0">{
                startTime := time.Now()

                // Find container by ID or name
                var container interface{}
                var containerName string

                if c, exists := containerByID[containerID]; exists </span><span class="cov0" title="0">{
                        container = c
                        if containerData, ok := c.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if name, ok := containerData["name"].(string); ok </span><span class="cov0" title="0">{
                                        containerName = name
                                }</span>
                        }
                } else<span class="cov0" title="0"> if c, exists := containerByName[containerID]; exists </span><span class="cov0" title="0">{
                        container = c
                        containerName = containerID
                }</span>

                <span class="cov0" title="0">if container == nil </span><span class="cov0" title="0">{
                        results[i] = ContainerOperationResult{
                                ContainerID: containerID,
                                Success:     false,
                                Error:       "Container not found",
                                Duration:    time.Since(startTime).String(),
                        }
                        continue</span>
                }

                // Perform operation
                <span class="cov0" title="0">var err error
                switch operation </span>{
                case "start":<span class="cov0" title="0">
                        err = h.api.docker.StartContainer(containerID)</span>
                case "stop":<span class="cov0" title="0">
                        err = h.api.docker.StopContainer(containerID, 10)</span> // 10 second timeout
                case "restart":<span class="cov0" title="0">
                        err = h.api.docker.RestartContainer(containerID, 10)</span> // 10 second timeout
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("unsupported operation: %s", operation)</span>
                }

                <span class="cov0" title="0">results[i] = ContainerOperationResult{
                        ContainerID:   containerID,
                        ContainerName: containerName,
                        Success:       err == nil,
                        Duration:      time.Since(startTime).String(),
                }

                if err != nil </span><span class="cov0" title="0">{
                        results[i].Error = err.Error()
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "net"
        "strings"

        "github.com/domalab/uma/daemon/common"
        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/lib"
        "github.com/domalab/uma/daemon/logger"
        "gopkg.in/ini.v1"
)

func (a *Api) getInfo() *dto.Info <span class="cov8" title="1">{
        prefs := getPrefs()

        sensorReadings := a.sensor.GetReadings(prefs)
        upsReadings := a.ups.GetStatus()

        samples := append(sensorReadings, upsReadings...)

        return &amp;dto.Info{
                Version:  2,
                Wake:     getMac(),
                Prefs:    prefs,
                Samples:  samples,
                Features: getFeatures(),
        }
}</span>

func getMac() dto.Wake <span class="cov8" title="1">{
        wake := dto.Wake{
                Mac:       "",
                Broadcast: "255.255.255.255",
        }

        ifaces, _ := net.Interfaces()
        for _, iface := range ifaces </span><span class="cov8" title="1">{
                if iface.Name == "eth0" </span><span class="cov0" title="0">{
                        wake.Mac = iface.HardwareAddr.String()
                        break</span>
                }
        }

        <span class="cov8" title="1">return wake</span>
}

func getPrefs() dto.Prefs <span class="cov8" title="1">{
        prefs := dto.Prefs{
                Number: ".,",
                Unit:   "C",
        }

        cfg, err := ini.Load(common.Prefs)
        if err != nil </span><span class="cov8" title="1">{
                logger.Yellow("unable to load/parse prefs file (%s): %s", common.Prefs, err)
                return prefs
        }</span>

        // Use improved parsing with automatic quote removal and defaults
        <span class="cov0" title="0">displaySection := cfg.Section("display")
        if displaySection != nil </span><span class="cov0" title="0">{
                number := displaySection.Key("number").MustString(".,")
                prefs.Number = strings.Replace(number, "\"", "", -1)

                unit := displaySection.Key("unit").MustString("C")
                prefs.Unit = strings.Replace(unit, "\"", "", -1)
        }</span>

        <span class="cov0" title="0">return prefs</span>
}

func getFeatures() map[string]bool <span class="cov8" title="1">{
        features := make(map[string]bool)

        // is sleep available ?
        exists, err := lib.Exists(common.Sleep)
        if err != nil </span><span class="cov0" title="0">{
                logger.Yellow("getfeatures:sleep:(%s)", err)
        }</span>

        <span class="cov8" title="1">features["sleep"] = exists

        return features</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "github.com/domalab/uma/daemon/lib"
        "github.com/domalab/uma/daemon/logger"
)

var logLocation = map[string]string{
        "system": "/var/log/syslog",
        "docker": "/var/log/docker.log",
        "vm":     "/var/log/libvirt/libvirtd.log",
}

func (a *Api) getLogs(logType string) []string <span class="cov0" title="0">{
        log := make([]string, 0)

        exists, err := lib.Exists(logLocation[logType])
        if err != nil </span><span class="cov0" title="0">{
                logger.Yellow("unable to check for log existence: %s", err)
                return log
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                logger.Yellow("log %s is not present in the system", logType)
                return log
        }</span>

        <span class="cov0" title="0">cmd := "tail -n 40 " + logLocation[logType]

        lib.Shell(cmd, func(line string) </span><span class="cov0" title="0">{
                log = append(log, line)
        }</span>)

        <span class="cov0" title="0">return log</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/services/api/types/requests"
        "github.com/domalab/uma/daemon/services/api/types/responses"
        "github.com/domalab/uma/daemon/services/api/utils"
)

// AuthHandler handles authentication-related HTTP requests
type AuthHandler struct {
        api utils.APIInterface
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(api utils.APIInterface) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{api: api}
}</span>

// HandleAuthLogin handles POST /api/v1/auth/login
func (h *AuthHandler) HandleAuthLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the login request
        <span class="cov0" title="0">if err := utils.ValidateStruct(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Attempt login
        <span class="cov0" title="0">loginResponse, err := h.api.GetAuth().Login(request.Username, request.Password)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, "Invalid credentials")
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, loginResponse)</span>
}

// HandleAuthUsers handles GET/POST /api/v1/auth/users
func (h *AuthHandler) HandleAuthUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetUsers(w, r)</span>
        case http.MethodPost:<span class="cov0" title="0">
                h.handleCreateUser(w, r)</span>
        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// HandleAuthStats handles GET /api/v1/auth/stats
func (h *AuthHandler) HandleAuthStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.api.GetAuth().GetStats()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get auth stats: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, stats)</span>
}

// HandleAuthUser handles individual user operations
func (h *AuthHandler) HandleAuthUser(w http.ResponseWriter, r *http.Request, userID string) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetUser(w, r, userID)</span>
        case http.MethodPut:<span class="cov0" title="0">
                h.handleUpdateUser(w, r, userID)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                h.handleDeleteUser(w, r, userID)</span>
        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// HandleAuthRefresh handles POST /api/v1/auth/refresh
func (h *AuthHandler) HandleAuthRefresh(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.TokenRefreshRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the refresh request
        <span class="cov0" title="0">if err := utils.ValidateStruct(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Implementation would refresh token
        // For now, return placeholder response
        <span class="cov0" title="0">response := responses.TokenResponse{
                AccessToken: "new_access_token",
                TokenType:   "Bearer",
                ExpiresIn:   3600,
                IssuedAt:    time.Now().UTC(),
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// HandleAuthLogout handles POST /api/v1/auth/logout
func (h *AuthHandler) HandleAuthLogout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Implementation would invalidate token
        // For now, return success
        <span class="cov0" title="0">response := map[string]interface{}{
                "message":   "Logged out successfully",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// Helper methods

// handleGetUsers handles GET requests for user list
func (h *AuthHandler) handleGetUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        users, err := h.api.GetAuth().GetUsers()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get users: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, users)</span>
}

// handleCreateUser handles POST requests to create a new user
func (h *AuthHandler) handleCreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var request requests.UserCreateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the create request
        <span class="cov0" title="0">if err := utils.ValidateStruct(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Implementation would create user
        // For now, return success
        <span class="cov0" title="0">user := responses.UserInfo{
                ID:       "new_user_id",
                Username: request.Username,
                Email:    request.Email,
                FullName: request.FullName,
                Roles:    request.Roles,
                Enabled:  request.Enabled,
                Created:  time.Now().UTC(),
                Updated:  time.Now().UTC(),
        }

        utils.WriteJSON(w, http.StatusCreated, user)</span>
}

// handleGetUser handles GET requests for individual user
func (h *AuthHandler) handleGetUser(w http.ResponseWriter, r *http.Request, userID string) <span class="cov0" title="0">{
        // Implementation would get user by ID
        // For now, return placeholder
        user := responses.UserInfo{
                ID:       userID,
                Username: "placeholder_user",
                Email:    "user@example.com",
                Enabled:  true,
                Created:  time.Now().UTC(),
                Updated:  time.Now().UTC(),
        }

        utils.WriteJSON(w, http.StatusOK, user)
}</span>

// handleUpdateUser handles PUT requests to update user
func (h *AuthHandler) handleUpdateUser(w http.ResponseWriter, r *http.Request, userID string) <span class="cov0" title="0">{
        var request requests.UserUpdateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the update request
        <span class="cov0" title="0">if err := utils.ValidateStruct(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Implementation would update user
        // For now, return success
        <span class="cov0" title="0">user := responses.UserInfo{
                ID:       userID,
                Username: "updated_user",
                Email:    request.Email,
                FullName: request.FullName,
                Roles:    request.Roles,
                Enabled:  request.Enabled,
                Updated:  time.Now().UTC(),
        }

        utils.WriteJSON(w, http.StatusOK, user)</span>
}

// handleDeleteUser handles DELETE requests to remove user
func (h *AuthHandler) handleDeleteUser(w http.ResponseWriter, r *http.Request, userID string) <span class="cov0" title="0">{
        // Implementation would delete user
        // For now, return success
        response := map[string]interface{}{
                "message":   "User deleted successfully",
                "user_id":   userID,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        utils.WriteJSON(w, http.StatusOK, response)
}</span>

// HandleAuthChangePassword handles POST /api/v1/auth/change-password
func (h *AuthHandler) HandleAuthChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.PasswordChangeRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the password change request
        <span class="cov0" title="0">if err := utils.ValidateStruct(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Implementation would change password
        // For now, return success
        <span class="cov0" title="0">response := map[string]interface{}{
                "message":   "Password changed successfully",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/domalab/uma/daemon/services/api/types/requests"
        "github.com/domalab/uma/daemon/services/api/types/responses"
        "github.com/domalab/uma/daemon/services/api/utils"
)

// DockerHandler handles Docker-related HTTP requests
type DockerHandler struct {
        api utils.APIInterface
}

// NewDockerHandler creates a new Docker handler
func NewDockerHandler(api utils.APIInterface) *DockerHandler <span class="cov8" title="1">{
        return &amp;DockerHandler{api: api}
}</span>

// HandleDockerContainers handles GET /api/v1/docker/containers
func (h *DockerHandler) HandleDockerContainers(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">containers, err := h.api.GetDocker().GetContainers()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get containers: %v", err))
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, containers)</span>
}

// HandleDockerContainer handles individual Docker container operations
func (h *DockerHandler) HandleDockerContainer(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Extract container ID and operation from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/docker/containers/")
        parts := strings.Split(path, "/")

        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, "Container ID and operation are required")
                return
        }</span>

        <span class="cov0" title="0">containerID := parts[0]
        operation := parts[1]

        if containerID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Container ID is required")
                return
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetContainer(w, r, containerID, operation)</span>
        case http.MethodPost:<span class="cov0" title="0">
                h.handleContainerAction(w, r, containerID, operation)</span>
        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// HandleDockerImages handles GET /api/v1/docker/images
func (h *DockerHandler) HandleDockerImages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">images, err := h.api.GetDocker().GetImages()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get images: %v", err))
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, images)</span>
}

// HandleDockerNetworks handles GET /api/v1/docker/networks
func (h *DockerHandler) HandleDockerNetworks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">networks, err := h.api.GetDocker().GetNetworks()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get networks: %v", err))
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, networks)</span>
}

// HandleDockerInfo handles GET /api/v1/docker/info
func (h *DockerHandler) HandleDockerInfo(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">info, err := h.api.GetDocker().GetSystemInfo()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get Docker info: %v", err))
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, info)</span>
}

// HandleDockerBulkStart handles POST /api/v1/docker/containers/bulk/start
func (h *DockerHandler) HandleDockerBulkStart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var request requests.DockerBulkActionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov8" title="1">results := h.performBulkAction(request.ContainerIDs, "start", request.Force)
        utils.WriteBulkOperationResponse(w, http.StatusOK, results)</span>
}

// HandleDockerBulkStop handles POST /api/v1/docker/containers/bulk/stop
func (h *DockerHandler) HandleDockerBulkStop(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.DockerBulkActionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov0" title="0">results := h.performBulkAction(request.ContainerIDs, "stop", request.Force)
        utils.WriteBulkOperationResponse(w, http.StatusOK, results)</span>
}

// HandleDockerBulkRestart handles POST /api/v1/docker/containers/bulk/restart
func (h *DockerHandler) HandleDockerBulkRestart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.DockerBulkActionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov0" title="0">results := h.performBulkAction(request.ContainerIDs, "restart", request.Force)
        utils.WriteBulkOperationResponse(w, http.StatusOK, results)</span>
}

// Helper methods

// handleGetContainer handles GET requests for individual containers
func (h *DockerHandler) handleGetContainer(w http.ResponseWriter, r *http.Request, containerID, operation string) <span class="cov0" title="0">{
        switch operation </span>{
        case "info", "":<span class="cov0" title="0">
                container, err := h.api.GetDocker().GetContainer(containerID)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusNotFound, fmt.Sprintf("Container not found: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, container)</span>

        case "logs":<span class="cov0" title="0">
                // Implementation would get container logs
                logs := map[string]interface{}{
                        "container_id": containerID,
                        "logs":         []string{"Log functionality not implemented"},
                        "timestamp":    time.Now().UTC().Format(time.RFC3339),
                }
                utils.WriteJSON(w, http.StatusOK, logs)</span>

        case "stats":<span class="cov0" title="0">
                // Implementation would get container stats
                stats := map[string]interface{}{
                        "container_id": containerID,
                        "cpu_percent":  0.0,
                        "memory_usage": 0,
                        "timestamp":    time.Now().UTC().Format(time.RFC3339),
                }
                utils.WriteJSON(w, http.StatusOK, stats)</span>

        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusBadRequest, "Invalid operation")</span>
        }
}

// handleContainerAction handles POST requests for container actions
func (h *DockerHandler) handleContainerAction(w http.ResponseWriter, r *http.Request, containerID, operation string) <span class="cov0" title="0">{
        var err error

        switch operation </span>{
        case "start":<span class="cov0" title="0">
                err = h.api.GetDocker().StartContainer(containerID)</span>
        case "stop":<span class="cov0" title="0">
                err = h.api.GetDocker().StopContainer(containerID)</span>
        case "restart":<span class="cov0" title="0">
                err = h.api.GetDocker().RestartContainer(containerID)</span>
        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusBadRequest, "Invalid operation")
                return</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to %s container: %v", operation, err))
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "message":      fmt.Sprintf("Container %s %sed successfully", containerID, operation),
                "container_id": containerID,
                "operation":    operation,
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
        }
        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// performBulkAction performs bulk actions on multiple containers
func (h *DockerHandler) performBulkAction(containerIDs []string, action string, force bool) []responses.BulkOperationResult <span class="cov8" title="1">{
        results := make([]responses.BulkOperationResult, len(containerIDs))

        for i, containerID := range containerIDs </span><span class="cov8" title="1">{
                var err error

                switch action </span>{
                case "start":<span class="cov8" title="1">
                        err = h.api.GetDocker().StartContainer(containerID)</span>
                case "stop":<span class="cov0" title="0">
                        err = h.api.GetDocker().StopContainer(containerID)</span>
                case "restart":<span class="cov0" title="0">
                        err = h.api.GetDocker().RestartContainer(containerID)</span>
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("invalid action: %s", action)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        results[i] = responses.BulkOperationResult{
                                ID:      containerID,
                                Success: false,
                                Error:   err.Error(),
                        }
                }</span> else<span class="cov8" title="1"> {
                        results[i] = responses.BulkOperationResult{
                                ID:      containerID,
                                Success: true,
                                Message: fmt.Sprintf("Container %s %sed successfully", containerID, action),
                        }
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "fmt"
        "net/http"

        "github.com/domalab/uma/daemon/services/api/utils"
)

// DocsHandler handles API documentation HTTP requests
type DocsHandler struct {
        version string
        baseURL string
}

// NewDocsHandler creates a new docs handler
func NewDocsHandler(version, baseURL string) *DocsHandler <span class="cov0" title="0">{
        return &amp;DocsHandler{
                version: version,
                baseURL: baseURL,
        }
}</span>

// SwaggerUIHandler serves the Swagger UI interface
func (h *DocsHandler) SwaggerUIHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Serve Swagger UI HTML
        <span class="cov0" title="0">html := h.generateSwaggerHTML()
        w.Header().Set("Content-Type", "text/html")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(html))</span>
}

// OpenAPIHandler serves the OpenAPI specification
func (h *DocsHandler) OpenAPIHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">spec := h.generateOpenAPISpec()
        utils.WriteJSON(w, http.StatusOK, spec)</span>
}

// generateSwaggerHTML generates the Swagger UI HTML page
func (h *DocsHandler) generateSwaggerHTML() string <span class="cov0" title="0">{
        return fmt.Sprintf(`&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;UMA API Documentation&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css" /&gt;
    &lt;style&gt;
        html {
            box-sizing: border-box;
            overflow: -moz-scrollbars-vertical;
            overflow-y: scroll;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }
        body {
            margin:0;
            background: #fafafa;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-standalone-preset.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() {
            const ui = SwaggerUIBundle({
                url: '%s/api/v1/openapi.json',
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout"
            });
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`, h.baseURL)
}</span>

// generateOpenAPISpec generates the OpenAPI 3.0 specification
func (h *DocsHandler) generateOpenAPISpec() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "openapi": "3.0.3",
                "info": map[string]interface{}{
                        "title":       "UMA API",
                        "description": "Unraid Management API for system, storage, Docker, and VM operations",
                        "version":     h.version,
                        "contact": map[string]interface{}{
                                "name": "UMA Project",
                                "url":  "https://github.com/domalab/uma",
                        },
                        "license": map[string]interface{}{
                                "name": "MIT",
                                "url":  "https://opensource.org/licenses/MIT",
                        },
                },
                "servers": []map[string]interface{}{
                        {
                                "url":         fmt.Sprintf("%s/api/v1", h.baseURL),
                                "description": "UMA API Server",
                        },
                },
                "paths": h.generatePaths(),
                "components": map[string]interface{}{
                        "schemas":         h.generateSchemas(),
                        "securitySchemes": h.generateSecuritySchemes(),
                },
                "security": []map[string]interface{}{
                        {
                                "bearerAuth": []string{},
                        },
                },
        }
}</span>

// generatePaths generates the OpenAPI paths specification
func (h *DocsHandler) generatePaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/health": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Health"},
                                "summary":     "Health check",
                                "description": "Get system health status",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Health status",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": map[string]interface{}{
                                                                        "$ref": "#/components/schemas/HealthResponse",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "/system/info": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"System"},
                                "summary":     "Get system information",
                                "description": "Retrieve general system information",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "System information",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": map[string]interface{}{
                                                                        "$ref": "#/components/schemas/SystemInfo",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "/system/cpu": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"System"},
                                "summary":     "Get CPU information",
                                "description": "Retrieve CPU usage and information",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "CPU information",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": map[string]interface{}{
                                                                        "$ref": "#/components/schemas/CPUInfo",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "/storage/array": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Storage"},
                                "summary":     "Get array status",
                                "description": "Retrieve Unraid array status and information",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Array status",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": map[string]interface{}{
                                                                        "$ref": "#/components/schemas/ArrayStatus",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "/docker/containers": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Docker"},
                                "summary":     "List Docker containers",
                                "description": "Retrieve list of Docker containers",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "List of containers",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": map[string]interface{}{
                                                                        "type": "array",
                                                                        "items": map[string]interface{}{
                                                                                "$ref": "#/components/schemas/DockerContainerInfo",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "/vms": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Virtual Machines"},
                                "summary":     "List virtual machines",
                                "description": "Retrieve list of virtual machines",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "List of VMs",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": map[string]interface{}{
                                                                        "$ref": "#/components/schemas/VMListResponse",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// generateSchemas generates the OpenAPI schemas
func (h *DocsHandler) generateSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "HealthResponse": map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "status": map[string]interface{}{
                                        "type":        "string",
                                        "enum":        []string{"healthy", "degraded", "unhealthy"},
                                        "description": "Overall health status",
                                },
                                "version": map[string]interface{}{
                                        "type":        "string",
                                        "description": "API version",
                                },
                                "uptime": map[string]interface{}{
                                        "type":        "string",
                                        "description": "System uptime",
                                },
                                "timestamp": map[string]interface{}{
                                        "type":        "string",
                                        "format":      "date-time",
                                        "description": "Response timestamp",
                                },
                        },
                },
                "SystemInfo": map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "hostname": map[string]interface{}{
                                        "type":        "string",
                                        "description": "System hostname",
                                },
                                "kernel": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Kernel version",
                                },
                                "architecture": map[string]interface{}{
                                        "type":        "string",
                                        "description": "System architecture",
                                },
                                "uptime": map[string]interface{}{
                                        "type":        "string",
                                        "description": "System uptime",
                                },
                        },
                },
                "CPUInfo": map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "usage": map[string]interface{}{
                                        "type":        "number",
                                        "description": "CPU usage percentage",
                                },
                                "temperature": map[string]interface{}{
                                        "type":        "number",
                                        "description": "CPU temperature in Celsius",
                                },
                                "cores": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Number of CPU cores",
                                },
                                "model": map[string]interface{}{
                                        "type":        "string",
                                        "description": "CPU model name",
                                },
                        },
                },
        }
}</span>

// generateSecuritySchemes generates the OpenAPI security schemes
func (h *DocsHandler) generateSecuritySchemes() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "bearerAuth": map[string]interface{}{
                        "type":         "http",
                        "scheme":       "bearer",
                        "bearerFormat": "JWT",
                        "description":  "JWT Bearer token authentication",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/services/api/types/responses"
        "github.com/domalab/uma/daemon/services/api/utils"
)

// HealthHandler handles health check HTTP requests
type HealthHandler struct {
        api       utils.APIInterface
        version   string
        startTime time.Time
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(api utils.APIInterface, version string) *HealthHandler <span class="cov8" title="1">{
        return &amp;HealthHandler{
                api:       api,
                version:   version,
                startTime: time.Now(),
        }
}</span>

// HandleHealth handles GET /api/v1/health
func (h *HealthHandler) HandleHealth(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Calculate uptime
        <span class="cov8" title="1">uptime := time.Since(h.startTime)
        uptimeStr := formatDuration(uptime)

        // Perform health checks
        checks := h.performHealthChecks()

        // Determine overall status
        status := h.determineOverallStatus(checks)

        utils.WriteHealthResponse(w, status, h.version, uptimeStr, checks)</span>
}

// HandleHealthLive handles GET /api/v1/health/live (liveness probe)
func (h *HealthHandler) HandleHealthLive(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Simple liveness check - just return OK if the service is running
        <span class="cov8" title="1">response := map[string]interface{}{
                "status":    "alive",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// HandleHealthReady handles GET /api/v1/health/ready (readiness probe)
func (h *HealthHandler) HandleHealthReady(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Perform readiness checks
        <span class="cov8" title="1">checks := h.performReadinessChecks()
        ready := h.isSystemReady(checks)

        status := http.StatusOK
        if !ready </span><span class="cov0" title="0">{
                status = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "status":    map[string]bool{"ready": ready},
                "checks":    checks,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        utils.WriteJSON(w, status, response)</span>
}

// performHealthChecks performs comprehensive health checks
func (h *HealthHandler) performHealthChecks() map[string]responses.HealthCheck <span class="cov8" title="1">{
        checks := make(map[string]responses.HealthCheck)

        // System health check
        checks["system"] = h.checkSystemHealth()

        // Storage health check
        checks["storage"] = h.checkStorageHealth()

        // Docker health check
        checks["docker"] = h.checkDockerHealth()

        // Auth service health check
        checks["auth"] = h.checkAuthHealth()

        return checks
}</span>

// performReadinessChecks performs readiness-specific checks
func (h *HealthHandler) performReadinessChecks() map[string]responses.HealthCheck <span class="cov8" title="1">{
        checks := make(map[string]responses.HealthCheck)

        // Check if system APIs are responsive
        checks["system_api"] = h.checkSystemAPIReadiness()

        // Check if storage APIs are responsive
        checks["storage_api"] = h.checkStorageAPIReadiness()

        // Check if Docker APIs are responsive
        checks["docker_api"] = h.checkDockerAPIReadiness()

        return checks
}</span>

// Individual health check methods

func (h *HealthHandler) checkSystemHealth() responses.HealthCheck <span class="cov8" title="1">{
        start := time.Now()

        // Try to get system info
        _, err := h.api.GetSystem().GetCPUInfo()
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                return responses.HealthCheck{
                        Status:    "fail",
                        Message:   "System API not responding",
                        Timestamp: time.Now().UTC(),
                        Duration:  duration.String(),
                }
        }</span>

        <span class="cov8" title="1">return responses.HealthCheck{
                Status:    "pass",
                Message:   "System API healthy",
                Timestamp: time.Now().UTC(),
                Duration:  duration.String(),
        }</span>
}

func (h *HealthHandler) checkStorageHealth() responses.HealthCheck <span class="cov8" title="1">{
        start := time.Now()

        // Try to get storage info
        _, err := h.api.GetStorage().GetArrayInfo()
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                return responses.HealthCheck{
                        Status:    "fail",
                        Message:   "Storage API not responding",
                        Timestamp: time.Now().UTC(),
                        Duration:  duration.String(),
                }
        }</span>

        <span class="cov8" title="1">return responses.HealthCheck{
                Status:    "pass",
                Message:   "Storage API healthy",
                Timestamp: time.Now().UTC(),
                Duration:  duration.String(),
        }</span>
}

func (h *HealthHandler) checkDockerHealth() responses.HealthCheck <span class="cov8" title="1">{
        start := time.Now()

        // Try to get Docker info
        _, err := h.api.GetDocker().GetSystemInfo()
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                return responses.HealthCheck{
                        Status:    "warn",
                        Message:   "Docker API not responding",
                        Timestamp: time.Now().UTC(),
                        Duration:  duration.String(),
                }
        }</span>

        <span class="cov8" title="1">return responses.HealthCheck{
                Status:    "pass",
                Message:   "Docker API healthy",
                Timestamp: time.Now().UTC(),
                Duration:  duration.String(),
        }</span>
}

func (h *HealthHandler) checkAuthHealth() responses.HealthCheck <span class="cov8" title="1">{
        start := time.Now()
        duration := time.Since(start)

        if !h.api.GetAuth().IsEnabled() </span><span class="cov8" title="1">{
                return responses.HealthCheck{
                        Status:    "pass",
                        Message:   "Auth service disabled",
                        Timestamp: time.Now().UTC(),
                        Duration:  duration.String(),
                }
        }</span>

        // Try to get auth stats
        <span class="cov0" title="0">_, err := h.api.GetAuth().GetStats()
        if err != nil </span><span class="cov0" title="0">{
                return responses.HealthCheck{
                        Status:    "warn",
                        Message:   "Auth service not responding",
                        Timestamp: time.Now().UTC(),
                        Duration:  duration.String(),
                }
        }</span>

        <span class="cov0" title="0">return responses.HealthCheck{
                Status:    "pass",
                Message:   "Auth service healthy",
                Timestamp: time.Now().UTC(),
                Duration:  duration.String(),
        }</span>
}

// Readiness check methods

func (h *HealthHandler) checkSystemAPIReadiness() responses.HealthCheck <span class="cov8" title="1">{
        return h.checkSystemHealth() // Same as health check for now
}</span>

func (h *HealthHandler) checkStorageAPIReadiness() responses.HealthCheck <span class="cov8" title="1">{
        return h.checkStorageHealth() // Same as health check for now
}</span>

func (h *HealthHandler) checkDockerAPIReadiness() responses.HealthCheck <span class="cov8" title="1">{
        return h.checkDockerHealth() // Same as health check for now
}</span>

// Helper methods

func (h *HealthHandler) determineOverallStatus(checks map[string]responses.HealthCheck) string <span class="cov8" title="1">{
        hasFailures := false
        hasWarnings := false

        for _, check := range checks </span><span class="cov8" title="1">{
                switch check.Status </span>{
                case "fail":<span class="cov0" title="0">
                        hasFailures = true</span>
                case "warn":<span class="cov0" title="0">
                        hasWarnings = true</span>
                }
        }

        <span class="cov8" title="1">if hasFailures </span><span class="cov0" title="0">{
                return "unhealthy"
        }</span>
        <span class="cov8" title="1">if hasWarnings </span><span class="cov0" title="0">{
                return "degraded"
        }</span>
        <span class="cov8" title="1">return "healthy"</span>
}

func (h *HealthHandler) isSystemReady(checks map[string]responses.HealthCheck) bool <span class="cov8" title="1">{
        for _, check := range checks </span><span class="cov8" title="1">{
                if check.Status == "fail" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        days := int(d.Hours()) / 24
        hours := int(d.Hours()) % 24
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd %dh %dm %ds", days, hours, minutes, seconds)
        }</span>
        <span class="cov8" title="1">if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh %dm %ds", hours, minutes, seconds)
        }</span>
        <span class="cov8" title="1">if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm %ds", minutes, seconds)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%ds", seconds)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/services/api/types/requests"
        "github.com/domalab/uma/daemon/services/api/types/responses"
        "github.com/domalab/uma/daemon/services/api/utils"
)

// StorageHandler handles storage-related HTTP requests
type StorageHandler struct {
        api utils.APIInterface
}

// NewStorageHandler creates a new storage handler
func NewStorageHandler(api utils.APIInterface) *StorageHandler <span class="cov0" title="0">{
        return &amp;StorageHandler{api: api}
}</span>

// HandleStorageArray handles GET /api/v1/storage/array
func (h *StorageHandler) HandleStorageArray(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">arrayInfo, err := h.api.GetStorage().GetArrayInfo()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get array information: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, arrayInfo)</span>
}

// HandleStorageDisks handles GET /api/v1/storage/disks
func (h *StorageHandler) HandleStorageDisks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">disks, err := h.api.GetStorage().GetDisks()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get disk information: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, disks)</span>
}

// HandleStorageZFS handles GET /api/v1/storage/zfs
func (h *StorageHandler) HandleStorageZFS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">zfsPools, err := h.api.GetStorage().GetZFSPools()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get ZFS information: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, zfsPools)</span>
}

// HandleStorageCache handles GET /api/v1/storage/cache
func (h *StorageHandler) HandleStorageCache(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">cacheInfo, err := h.api.GetStorage().GetCacheInfo()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get cache information: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, cacheInfo)</span>
}

// HandleStorageBoot handles GET /api/v1/storage/boot
func (h *StorageHandler) HandleStorageBoot(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">bootInfo := h.getBootUsage()
        utils.WriteJSON(w, http.StatusOK, bootInfo)</span>
}

// HandleStorageGeneral handles GET /api/v1/storage/general
func (h *StorageHandler) HandleStorageGeneral(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">generalInfo := h.getGeneralStorageInfo()
        utils.WriteJSON(w, http.StatusOK, generalInfo)</span>
}

// HandleArrayStart handles POST /api/v1/storage/array/start
func (h *StorageHandler) HandleArrayStart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.ArrayStartRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.GetStorage().StartArray(request)
        if err != nil </span><span class="cov0" title="0">{
                response := responses.ArrayOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to start array: %v", err),
                }
                utils.WriteJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := responses.ArrayOperationResponse{
                Success:     true,
                Message:     "Array start initiated successfully",
                OperationID: fmt.Sprintf("array_start_%d", time.Now().Unix()),
        }
        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// HandleArrayStop handles POST /api/v1/storage/array/stop
func (h *StorageHandler) HandleArrayStop(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.ArrayStopRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.GetStorage().StopArray(request)
        if err != nil </span><span class="cov0" title="0">{
                response := responses.ArrayOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to stop array: %v", err),
                }
                utils.WriteJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := responses.ArrayOperationResponse{
                Success:     true,
                Message:     "Array stop initiated successfully",
                OperationID: fmt.Sprintf("array_stop_%d", time.Now().Unix()),
        }
        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// HandleParityCheck handles GET/POST /api/v1/system/parity/check
func (h *StorageHandler) HandleParityCheck(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                // Get parity check status
                status := h.getParityCheckStatus()
                utils.WriteJSON(w, http.StatusOK, status)</span>

        case http.MethodPost:<span class="cov0" title="0">
                // Start parity check
                var request requests.ParityCheckRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                        return
                }</span>

                <span class="cov0" title="0">err := h.startParityCheck(request)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to start parity check: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">response := responses.ArrayOperationResponse{
                        Success:     true,
                        Message:     "Parity check started successfully",
                        OperationID: fmt.Sprintf("parity_check_%d", time.Now().Unix()),
                }
                utils.WriteJSON(w, http.StatusOK, response)</span>

        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// HandleParityDisk handles GET /api/v1/system/parity/disk
func (h *StorageHandler) HandleParityDisk(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">parityDiskInfo := h.getParityDiskInfo()
        utils.WriteJSON(w, http.StatusOK, parityDiskInfo)</span>
}

// Helper methods

// getBootUsage returns boot filesystem usage information
func (h *StorageHandler) getBootUsage() map[string]interface{} <span class="cov0" title="0">{
        return h.getPathUsage("/boot")
}</span>

// getGeneralStorageInfo returns general storage information
func (h *StorageHandler) getGeneralStorageInfo() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "docker_vdisk": h.getDockerVDiskUsage(),
                "log_usage":    h.getLogFilesystemUsage(),
                "boot_usage":   h.getBootUsage(),
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getPathUsage returns filesystem usage for a given path
func (h *StorageHandler) getPathUsage(path string) map[string]interface{} <span class="cov0" title="0">{
        // Implementation would get actual filesystem usage
        // For now, return placeholder
        return map[string]interface{}{
                "total": 0,
                "used":  0,
                "free":  0,
                "path":  path,
        }
}</span>

// getDockerVDiskUsage returns Docker vDisk usage information
func (h *StorageHandler) getDockerVDiskUsage() map[string]interface{} <span class="cov0" title="0">{
        // Check common Docker vDisk locations
        dockerPaths := []string{"/var/lib/docker", "/mnt/user/system/docker/docker.img"}

        for _, path := range dockerPaths </span><span class="cov0" title="0">{
                if usage := h.getPathUsage(path); usage != nil </span><span class="cov0" title="0">{
                        return usage
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "total": 0,
                "used":  0,
                "free":  0,
        }</span>
}

// getLogFilesystemUsage returns log filesystem usage information
func (h *StorageHandler) getLogFilesystemUsage() map[string]interface{} <span class="cov0" title="0">{
        return h.getPathUsage("/var/log")
}</span>

// getParityCheckStatus returns the current parity check status
func (h *StorageHandler) getParityCheckStatus() responses.ParityCheckStatus <span class="cov0" title="0">{
        // Implementation would get actual parity check status
        // For now, return placeholder
        return responses.ParityCheckStatus{
                Active:      false,
                Type:        "",
                Progress:    0.0,
                Speed:       "",
                Errors:      0,
                LastUpdated: time.Now().UTC(),
        }
}</span>

// startParityCheck starts a parity check operation
func (h *StorageHandler) startParityCheck(request requests.ParityCheckRequest) error <span class="cov0" title="0">{
        // Implementation would start actual parity check
        // For now, return success
        return nil
}</span>

// getParityDiskInfo returns parity disk information
func (h *StorageHandler) getParityDiskInfo() map[string]interface{} <span class="cov0" title="0">{
        // Implementation would get actual parity disk information
        // For now, return placeholder
        return map[string]interface{}{
                "parity_disks": []interface{}{},
                "capacity":     0,
                "temperature":  0.0,
                "health":       "unknown",
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/domalab/uma/daemon/services/api/types/requests"
        "github.com/domalab/uma/daemon/services/api/types/responses"
        "github.com/domalab/uma/daemon/services/api/utils"
)

// SystemHandler handles system-related HTTP requests
type SystemHandler struct {
        api utils.APIInterface
}

// NewSystemHandler creates a new system handler
func NewSystemHandler(api utils.APIInterface) *SystemHandler <span class="cov8" title="1">{
        return &amp;SystemHandler{api: api}
}</span>

// HandleSystemInfo handles GET /api/v1/system/info
func (h *SystemHandler) HandleSystemInfo(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">info := h.api.GetInfo()
        utils.WriteJSON(w, http.StatusOK, info)</span>
}

// HandleSystemCPU handles GET /api/v1/system/cpu
func (h *SystemHandler) HandleSystemCPU(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">cpuData := h.getCPUData()
        if cpuData == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, "Failed to get CPU information")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, cpuData)</span>
}

// HandleSystemMemory handles GET /api/v1/system/memory
func (h *SystemHandler) HandleSystemMemory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">memoryData := h.getMemoryData()
        if memoryData == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, "Failed to get memory information")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, memoryData)</span>
}

// HandleSystemTemperature handles GET /api/v1/system/temperature
func (h *SystemHandler) HandleSystemTemperature(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">tempData := h.getTemperatureData()
        if tempData == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, "Failed to get temperature information")
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, tempData)</span>
}

// HandleSystemNetwork handles GET /api/v1/system/network
func (h *SystemHandler) HandleSystemNetwork(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">networkData := h.getNetworkData()
        if networkData == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, "Failed to get network information")
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, networkData)</span>
}

// HandleSystemUPS handles GET /api/v1/system/ups
func (h *SystemHandler) HandleSystemUPS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">upsData := h.getUPSData()
        utils.WriteJSON(w, http.StatusOK, upsData)</span>
}

// HandleSystemGPU handles GET /api/v1/system/gpu
func (h *SystemHandler) HandleSystemGPU(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">gpuData := h.getIntelGPUData()
        if gpuData == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, "Failed to get GPU information")
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, gpuData)</span>
}

// HandleSystemFans handles GET /api/v1/system/fans
func (h *SystemHandler) HandleSystemFans(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().UTC().Format(time.RFC3339)

        // Get enhanced temperature data which includes fan information
        enhancedData, err := h.api.GetSystem().GetEnhancedTemperatureData()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get fan information: %v", err))
                return
        }</span>

        // Extract fans from enhanced data (assuming it's a map)
        <span class="cov0" title="0">var fans interface{}
        if dataMap, ok := enhancedData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                fans = dataMap["fans"]
        }</span> else<span class="cov0" title="0"> {
                fans = []interface{}{} // Empty array as fallback
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "fans":         fans,
                "last_updated": timestamp,
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// HandleSystemResources handles GET /api/v1/system/resources
func (h *SystemHandler) HandleSystemResources(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">resources := make(map[string]interface{})

        // CPU information
        if cpuInfo, err := h.api.GetSystem().GetCPUInfo(); err == nil </span><span class="cov0" title="0">{
                resources["cpu"] = cpuInfo
        }</span>

        // Memory information
        <span class="cov0" title="0">if memInfo, err := h.api.GetSystem().GetMemoryInfo(); err == nil </span><span class="cov0" title="0">{
                resources["memory"] = memInfo
        }</span>

        // Load information
        <span class="cov0" title="0">if loadInfo, err := h.api.GetSystem().GetLoadInfo(); err == nil </span><span class="cov0" title="0">{
                resources["load"] = loadInfo
        }</span>

        // Uptime information
        <span class="cov0" title="0">if uptimeInfo, err := h.api.GetSystem().GetUptimeInfo(); err == nil </span><span class="cov0" title="0">{
                resources["uptime"] = uptimeInfo
        }</span>

        // Network information
        <span class="cov0" title="0">if networkInfo, err := h.api.GetSystem().GetNetworkInfo(); err == nil </span><span class="cov0" title="0">{
                resources["network"] = networkInfo
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, resources)</span>
}

// HandleSystemFilesystems handles GET /api/v1/system/filesystems
func (h *SystemHandler) HandleSystemFilesystems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">fsData := h.getFilesystemData()
        utils.WriteJSON(w, http.StatusOK, fsData)</span>
}

// HandleSystemExecute handles POST /api/v1/system/execute
func (h *SystemHandler) HandleSystemExecute(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Parse request body
        <span class="cov8" title="1">var request requests.CommandExecuteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate command
        <span class="cov8" title="1">if strings.TrimSpace(request.Command) == "" </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, "Command is required")
                return
        }</span>

        // Set default timeout
        <span class="cov8" title="1">if request.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                request.Timeout = 30
        }</span>

        // Limit maximum timeout to 300 seconds (5 minutes)
        <span class="cov8" title="1">if request.Timeout &gt; 300 </span><span class="cov0" title="0">{
                request.Timeout = 300
        }</span>

        // Security: Basic command sanitization
        <span class="cov8" title="1">if h.isCommandBlacklisted(request.Command) </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusForbidden, "Command not allowed")
                return
        }</span>

        // Execute command
        <span class="cov8" title="1">response := h.executeCommand(request)
        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// Helper methods

// getCPUData returns CPU data in standard format
func (h *SystemHandler) getCPUData() map[string]interface{} <span class="cov8" title="1">{
        // Implementation would call h.api.GetSystem().GetCPUInfo()
        // For now, return placeholder
        return map[string]interface{}{
                "usage":        0.0,
                "temperature":  0.0,
                "cores":        0,
                "model":        "Unknown",
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getMemoryData returns memory data in standard format
func (h *SystemHandler) getMemoryData() map[string]interface{} <span class="cov8" title="1">{
        // Implementation would call h.api.GetSystem().GetMemoryInfo()
        // For now, return placeholder
        return map[string]interface{}{
                "total":        0,
                "used":         0,
                "free":         0,
                "available":    0,
                "usage":        0.0,
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getTemperatureData returns temperature data in standard format
func (h *SystemHandler) getTemperatureData() map[string]interface{} <span class="cov0" title="0">{
        // Implementation would call h.api.GetSystem().GetEnhancedTemperatureData()
        // For now, return placeholder
        return map[string]interface{}{
                "sensors":      []interface{}{},
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getNetworkData returns network data in standard format
func (h *SystemHandler) getNetworkData() map[string]interface{} <span class="cov0" title="0">{
        // Implementation would call h.api.GetSystem().GetNetworkInfo()
        // For now, return placeholder
        return map[string]interface{}{
                "interfaces":   []interface{}{},
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getUPSData returns UPS data in standard format
func (h *SystemHandler) getUPSData() map[string]interface{} <span class="cov0" title="0">{
        // Implementation would get UPS data from system
        // For now, return placeholder
        return map[string]interface{}{
                "status":         "unknown",
                "battery_charge": 0.0,
                "runtime":        0,
                "load":           0.0,
                "last_updated":   time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getIntelGPUData returns Intel GPU data in standard format
func (h *SystemHandler) getIntelGPUData() map[string]interface{} <span class="cov0" title="0">{
        // Implementation would get Intel GPU data
        // For now, return placeholder
        return map[string]interface{}{
                "name":         "Unknown",
                "usage":        0.0,
                "memory_used":  0,
                "memory_total": 0,
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// getFilesystemData returns filesystem data in standard format
func (h *SystemHandler) getFilesystemData() map[string]interface{} <span class="cov0" title="0">{
        // Implementation would get filesystem data
        // For now, return placeholder
        return map[string]interface{}{
                "filesystems":  []interface{}{},
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// HandleSystemScripts handles GET/POST /api/v1/system/scripts
func (h *SystemHandler) HandleSystemScripts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // List all user scripts
                scripts, err := h.getUserScripts()
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get user scripts: %v", err))
                        return
                }</span>

                <span class="cov8" title="1">response := map[string]interface{}{"scripts": scripts}
                utils.WriteJSON(w, http.StatusOK, response)</span>

        case http.MethodPost:<span class="cov0" title="0">
                // Execute a script
                scriptName := r.URL.Query().Get("name")
                if scriptName == "" </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusBadRequest, "Script name is required")
                        return
                }</span>

                <span class="cov0" title="0">var req map[string]interface{}
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                        return
                }</span>

                <span class="cov0" title="0">response, err := h.executeUserScript(scriptName, req)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to execute script: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, response)</span>

        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// isCommandBlacklisted checks if a command is blacklisted for security
func (h *SystemHandler) isCommandBlacklisted(command string) bool <span class="cov8" title="1">{
        return utils.IsCommandBlacklisted(command)
}</span>

// executeCommand executes a command and returns the response
func (h *SystemHandler) executeCommand(request requests.CommandExecuteRequest) responses.CommandExecuteResponse <span class="cov8" title="1">{
        start := time.Now()

        // For now, return a placeholder response
        // Real implementation would execute the command safely
        return responses.CommandExecuteResponse{
                ExitCode:        0,
                Stdout:          "Command execution not implemented",
                Stderr:          "",
                ExecutionTimeMs: time.Since(start).Milliseconds(),
                Command:         request.Command,
                WorkingDir:      request.WorkingDirectory,
        }
}</span>

// getUserScripts returns a list of available user scripts
func (h *SystemHandler) getUserScripts() ([]interface{}, error) <span class="cov8" title="1">{
        // Placeholder implementation
        // Real implementation would scan /boot/config/plugins/user.scripts/scripts/
        return []interface{}{
                map[string]interface{}{
                        "name":        "example_script",
                        "description": "Example user script",
                        "enabled":     true,
                        "last_run":    time.Now().Add(-24 * time.Hour).Format(time.RFC3339),
                },
        }, nil
}</span>

// executeUserScript executes a user script and returns the response
func (h *SystemHandler) executeUserScript(scriptName string, req map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Placeholder implementation
        // Real implementation would execute the script safely
        return map[string]interface{}{
                "success":      true,
                "script_name":  scriptName,
                "execution_id": fmt.Sprintf("exec_%d", time.Now().Unix()),
                "started_at":   time.Now().Format(time.RFC3339),
                "status":       "running",
                "message":      "Script execution started",
        }, nil
}</span>

// HandleSystemReboot handles POST /api/v1/system/reboot
func (h *SystemHandler) HandleSystemReboot(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var req map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Allow empty body with default values
                req = map[string]interface{}{
                        "delay_seconds": 0,
                        "message":       "System reboot initiated via UMA API",
                        "force":         false,
                }
        }</span>

        // Extract and validate delay
        <span class="cov8" title="1">delaySeconds := 0
        if delay, ok := req["delay_seconds"].(float64); ok </span><span class="cov8" title="1">{
                delaySeconds = int(delay)
        }</span>
        <span class="cov8" title="1">if delaySeconds &lt; 0 || delaySeconds &gt; 300 </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, "Delay must be between 0 and 300 seconds")
                return
        }</span>

        <span class="cov8" title="1">message := "System reboot initiated via UMA API"
        if msg, ok := req["message"].(string); ok &amp;&amp; msg != "" </span><span class="cov8" title="1">{
                message = msg
        }</span>

        <span class="cov8" title="1">force := false
        if f, ok := req["force"].(bool); ok </span><span class="cov8" title="1">{
                force = f
        }</span>

        <span class="cov8" title="1">err := h.executeSystemReboot(delaySeconds, message, force)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to initiate reboot: %v", err))
                return
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "success":        true,
                "message":        "System reboot initiated",
                "operation_id":   fmt.Sprintf("reboot_%d", time.Now().Unix()),
                "scheduled_time": time.Now().Add(time.Duration(delaySeconds) * time.Second).Format(time.RFC3339),
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// HandleSystemShutdown handles POST /api/v1/system/shutdown
func (h *SystemHandler) HandleSystemShutdown(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Allow empty body with default values
                req = map[string]interface{}{
                        "delay_seconds": 0,
                        "message":       "System shutdown initiated via UMA API",
                        "force":         false,
                }
        }</span>

        // Extract and validate delay
        <span class="cov0" title="0">delaySeconds := 0
        if delay, ok := req["delay_seconds"].(float64); ok </span><span class="cov0" title="0">{
                delaySeconds = int(delay)
        }</span>
        <span class="cov0" title="0">if delaySeconds &lt; 0 || delaySeconds &gt; 300 </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Delay must be between 0 and 300 seconds")
                return
        }</span>

        <span class="cov0" title="0">message := "System shutdown initiated via UMA API"
        if msg, ok := req["message"].(string); ok &amp;&amp; msg != "" </span><span class="cov0" title="0">{
                message = msg
        }</span>

        <span class="cov0" title="0">force := false
        if f, ok := req["force"].(bool); ok </span><span class="cov0" title="0">{
                force = f
        }</span>

        <span class="cov0" title="0">err := h.executeSystemShutdown(delaySeconds, message, force)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to initiate shutdown: %v", err))
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":        true,
                "message":        "System shutdown initiated",
                "operation_id":   fmt.Sprintf("shutdown_%d", time.Now().Unix()),
                "scheduled_time": time.Now().Add(time.Duration(delaySeconds) * time.Second).Format(time.RFC3339),
        }

        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// executeSystemReboot executes a system reboot
func (h *SystemHandler) executeSystemReboot(delaySeconds int, message string, force bool) error <span class="cov8" title="1">{
        // Placeholder implementation
        // Real implementation would execute: shutdown -r +delaySeconds "message"
        // For safety, this is just a placeholder
        return nil
}</span>

// executeSystemShutdown executes a system shutdown
func (h *SystemHandler) executeSystemShutdown(delaySeconds int, message string, force bool) error <span class="cov0" title="0">{
        // Placeholder implementation
        // Real implementation would execute: shutdown -h +delaySeconds "message"
        // For safety, this is just a placeholder
        return nil
}</span>

// HandleSystemLogs handles GET /api/v1/system/logs
func (h *SystemHandler) HandleSystemLogs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">logType := r.URL.Query().Get("type")
        if logType == "" </span><span class="cov0" title="0">{
                logType = "system"
        }</span>

        // Support custom log file path
        <span class="cov8" title="1">customPath := r.URL.Query().Get("path")

        // Support grep filtering
        grepFilter := r.URL.Query().Get("grep")

        // Support tail parameter (alias for lines)
        lines := 100
        if linesParam := r.URL.Query().Get("lines"); linesParam != "" </span><span class="cov8" title="1">{
                // Parse lines parameter (simplified)
                lines = 100 // Default fallback
        }</span>
        <span class="cov8" title="1">if tailParam := r.URL.Query().Get("tail"); tailParam != "" </span><span class="cov0" title="0">{
                // Parse tail parameter (simplified)
                lines = 100 // Default fallback
        }</span>

        <span class="cov8" title="1">follow := r.URL.Query().Get("follow") == "true"
        since := r.URL.Query().Get("since") // ISO 8601 format

        var logs []string
        var err error

        if customPath != "" </span><span class="cov0" title="0">{
                // Use custom log file path
                logs, err = h.getCustomLogFile(customPath, lines, grepFilter, since)
        }</span> else<span class="cov8" title="1"> {
                // Use standard log types
                logs, err = h.getSystemLogs(logType, lines, follow, since)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get system logs: %v", err))
                return
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "type":  logType,
                "lines": lines,
                "logs":  logs,
        }

        if customPath != "" </span><span class="cov0" title="0">{
                response["path"] = customPath
        }</span>
        <span class="cov8" title="1">if grepFilter != "" </span><span class="cov0" title="0">{
                response["grep_filter"] = grepFilter
        }</span>

        <span class="cov8" title="1">utils.WriteJSON(w, http.StatusOK, response)</span>
}

// getSystemLogs returns system logs of the specified type
func (h *SystemHandler) getSystemLogs(logType string, lines int, follow bool, since string) ([]string, error) <span class="cov8" title="1">{
        // Placeholder implementation
        // Real implementation would read from /var/log/syslog, /var/log/messages, etc.
        return []string{
                fmt.Sprintf("[%s] System log entry 1", time.Now().Format(time.RFC3339)),
                fmt.Sprintf("[%s] System log entry 2", time.Now().Add(-time.Minute).Format(time.RFC3339)),
                fmt.Sprintf("[%s] System log entry 3", time.Now().Add(-2*time.Minute).Format(time.RFC3339)),
        }, nil
}</span>

// getCustomLogFile reads a custom log file with filtering
func (h *SystemHandler) getCustomLogFile(filePath string, lines int, grepFilter, since string) ([]string, error) <span class="cov0" title="0">{
        // Placeholder implementation
        // Real implementation would read the specified file with security checks
        return []string{
                fmt.Sprintf("[%s] Custom log entry from %s", time.Now().Format(time.RFC3339), filePath),
                fmt.Sprintf("[%s] Custom log entry 2", time.Now().Add(-time.Minute).Format(time.RFC3339)),
        }, nil
}</span>

// HandleSystemLogsAll handles GET /api/v1/system/logs/all
func (h *SystemHandler) HandleSystemLogsAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">directory := r.URL.Query().Get("directory")
        if directory == "" </span><span class="cov0" title="0">{
                directory = "/var/log"
        }</span>

        <span class="cov0" title="0">recursive := r.URL.Query().Get("recursive") != "false" // Default to true
        filePattern := r.URL.Query().Get("file_pattern")
        maxFiles := 50

        // Security: Restrict to /var/log and subdirectories only
        if !strings.HasPrefix(directory, "/var/log") </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusForbidden, "Access restricted to /var/log directory")
                return
        }</span>

        <span class="cov0" title="0">logFiles, err := h.scanLogFiles(directory, recursive, filePattern, maxFiles)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to scan log files: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, map[string]interface{}{
                "directory":    directory,
                "recursive":    recursive,
                "file_pattern": filePattern,
                "max_files":    maxFiles,
                "total_found":  len(logFiles),
                "files":        logFiles,
        })</span>
}

// scanLogFiles scans for log files in the specified directory
func (h *SystemHandler) scanLogFiles(directory string, recursive bool, filePattern string, maxFiles int) ([]interface{}, error) <span class="cov0" title="0">{
        // Placeholder implementation
        // Real implementation would scan the directory for log files
        return []interface{}{
                map[string]interface{}{
                        "path":          "/var/log/syslog",
                        "name":          "syslog",
                        "size":          1024000,
                        "modified_time": time.Now().Add(-time.Hour).Format(time.RFC3339),
                        "readable":      true,
                },
                map[string]interface{}{
                        "path":          "/var/log/messages",
                        "name":          "messages",
                        "size":          512000,
                        "modified_time": time.Now().Add(-2 * time.Hour).Format(time.RFC3339),
                        "readable":      true,
                },
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "github.com/domalab/uma/daemon/services/api/utils"
)

// MockAPIInterface provides a mock implementation of the API interface for testing
type MockAPIInterface struct{}

// GetInfo returns mock system info
func (m *MockAPIInterface) GetInfo() interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "version": "test-version",
                "status":  "healthy",
        }
}</span>

// GetSystem returns a mock system interface
func (m *MockAPIInterface) GetSystem() utils.SystemInterface <span class="cov8" title="1">{
        return &amp;MockSystemInterface{}
}</span>

// GetStorage returns a mock storage interface
func (m *MockAPIInterface) GetStorage() utils.StorageInterface <span class="cov8" title="1">{
        return &amp;MockStorageInterface{}
}</span>

// GetDocker returns a mock Docker interface
func (m *MockAPIInterface) GetDocker() utils.DockerInterface <span class="cov8" title="1">{
        return &amp;MockDockerInterface{}
}</span>

// GetVM returns a mock VM interface
func (m *MockAPIInterface) GetVM() utils.VMInterface <span class="cov0" title="0">{
        return &amp;MockVMInterface{}
}</span>

// GetAuth returns a mock auth interface
func (m *MockAPIInterface) GetAuth() utils.AuthInterface <span class="cov8" title="1">{
        return &amp;MockAuthInterface{}
}</span>

// MockSystemInterface provides mock system functionality
type MockSystemInterface struct{}

func (m *MockSystemInterface) GetCPUInfo() (interface{}, error) <span class="cov8" title="1">{
        return map[string]interface{}{"cores": 4, "usage": 25.5}, nil
}</span>

func (m *MockSystemInterface) GetMemoryInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"total": 8192, "used": 4096}, nil
}</span>

func (m *MockSystemInterface) GetLoadInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"load1": 1.5, "load5": 1.2, "load15": 1.0}, nil
}</span>

func (m *MockSystemInterface) GetUptimeInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"uptime": 86400}, nil
}</span>

func (m *MockSystemInterface) GetNetworkInfo() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (m *MockSystemInterface) GetEnhancedTemperatureData() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{}, nil
}</span>

// MockStorageInterface provides mock storage functionality
type MockStorageInterface struct{}

func (m *MockStorageInterface) GetArrayInfo() (interface{}, error) <span class="cov8" title="1">{
        return map[string]interface{}{"status": "started"}, nil
}</span>

func (m *MockStorageInterface) GetDisks() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (m *MockStorageInterface) GetZFSPools() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (m *MockStorageInterface) GetCacheInfo() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{}, nil
}</span>

func (m *MockStorageInterface) StartArray(request interface{}) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockStorageInterface) StopArray(request interface{}) error <span class="cov0" title="0">{
        return nil
}</span>

// MockDockerInterface provides mock Docker functionality
type MockDockerInterface struct{}

func (m *MockDockerInterface) GetContainers() (interface{}, error) <span class="cov8" title="1">{
        return []interface{}{}, nil
}</span>

func (m *MockDockerInterface) GetContainer(id string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"id": id, "name": "test-container"}, nil
}</span>

func (m *MockDockerInterface) StartContainer(id string) error <span class="cov8" title="1">{
        return nil
}</span>

func (m *MockDockerInterface) StopContainer(id string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockDockerInterface) RestartContainer(id string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockDockerInterface) GetImages() (interface{}, error) <span class="cov8" title="1">{
        return []interface{}{}, nil
}</span>

func (m *MockDockerInterface) GetNetworks() (interface{}, error) <span class="cov8" title="1">{
        return []interface{}{}, nil
}</span>

func (m *MockDockerInterface) GetSystemInfo() (interface{}, error) <span class="cov8" title="1">{
        return map[string]interface{}{}, nil
}</span>

// MockVMInterface provides mock VM functionality
type MockVMInterface struct{}

func (m *MockVMInterface) GetVMs() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (m *MockVMInterface) GetVM(name string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"name": name}, nil
}</span>

func (m *MockVMInterface) StartVM(name string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockVMInterface) StopVM(name string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockVMInterface) RestartVM(name string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockVMInterface) GetVMStats(name string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{}, nil
}</span>

func (m *MockVMInterface) GetVMConsole(name string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{}, nil
}</span>

func (m *MockVMInterface) SetVMAutostart(name string, autostart bool) error <span class="cov0" title="0">{
        return nil
}</span>

// MockAuthInterface provides mock authentication functionality
type MockAuthInterface struct{}

func (m *MockAuthInterface) Login(username, password string) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"token": "test-token"}, nil
}</span>

func (m *MockAuthInterface) GetUsers() (interface{}, error) <span class="cov0" title="0">{
        return []interface{}{}, nil
}</span>

func (m *MockAuthInterface) GetStats() (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{}, nil
}</span>

func (m *MockAuthInterface) IsEnabled() bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/domalab/uma/daemon/services/api/types/requests"
        "github.com/domalab/uma/daemon/services/api/types/responses"
        "github.com/domalab/uma/daemon/services/api/utils"
)

// VMHandler handles VM-related HTTP requests
type VMHandler struct {
        api utils.APIInterface
}

// NewVMHandler creates a new VM handler
func NewVMHandler(api utils.APIInterface) *VMHandler <span class="cov0" title="0">{
        return &amp;VMHandler{api: api}
}</span>

// HandleVMList handles GET /api/v1/vms
func (h *VMHandler) HandleVMList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">vms, err := h.api.GetVM().GetVMs()
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get VMs: %v", err))
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, vms)</span>
}

// HandleVM handles VM operations
func (h *VMHandler) HandleVM(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract VM name from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/vms/")
        parts := strings.Split(path, "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "VM name required")
                return
        }</span>

        <span class="cov0" title="0">vmName := parts[0]
        action := ""
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                action = parts[1]
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetVM(w, r, vmName, action)</span>
        case http.MethodPost:<span class="cov0" title="0">
                h.handleVMAction(w, r, vmName, action)</span>
        case http.MethodPut:<span class="cov0" title="0">
                h.handleUpdateVM(w, r, vmName)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                h.handleDeleteVM(w, r, vmName)</span>
        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// Helper methods

// handleGetVM handles GET requests for VMs
func (h *VMHandler) handleGetVM(w http.ResponseWriter, r *http.Request, vmName, action string) <span class="cov0" title="0">{
        switch action </span>{
        case "stats":<span class="cov0" title="0">
                stats, err := h.api.GetVM().GetVMStats(vmName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get VM stats: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, stats)</span>

        case "console":<span class="cov0" title="0">
                console, err := h.api.GetVM().GetVMConsole(vmName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get VM console: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, map[string]interface{}{"console": console})</span>

        case "":<span class="cov0" title="0">
                // Get VM info
                vm, err := h.api.GetVM().GetVM(vmName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusNotFound, fmt.Sprintf("VM not found: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">utils.WriteJSON(w, http.StatusOK, vm)</span>

        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusBadRequest, "Invalid action")</span>
        }
}

// handleVMAction handles POST requests for VM actions
func (h *VMHandler) handleVMAction(w http.ResponseWriter, r *http.Request, vmName, action string) <span class="cov0" title="0">{
        var err error
        var message string

        switch action </span>{
        case "start":<span class="cov0" title="0">
                err = h.api.GetVM().StartVM(vmName)
                message = "VM started successfully"</span>

        case "stop":<span class="cov0" title="0">
                err = h.api.GetVM().StopVM(vmName)
                message = "VM stopped successfully"</span>

        case "restart":<span class="cov0" title="0">
                err = h.api.GetVM().RestartVM(vmName)
                message = "VM restarted successfully"</span>

        case "pause":<span class="cov0" title="0">
                // Implementation would pause VM
                message = "VM paused successfully"</span>

        case "resume":<span class="cov0" title="0">
                // Implementation would resume VM
                message = "VM resumed successfully"</span>

        case "reset":<span class="cov0" title="0">
                // Implementation would reset VM
                message = "VM reset successfully"</span>

        case "autostart":<span class="cov0" title="0">
                autostart := r.URL.Query().Get("enable") == "true"
                err = h.api.GetVM().SetVMAutostart(vmName, autostart)
                if autostart </span><span class="cov0" title="0">{
                        message = "VM autostart enabled"
                }</span> else<span class="cov0" title="0"> {
                        message = "VM autostart disabled"
                }</span>

        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusBadRequest, "Invalid action")
                return</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to %s VM: %v", action, err))
                return
        }</span>

        <span class="cov0" title="0">response := responses.VMOperationResponse{
                Success:     true,
                Message:     message,
                OperationID: fmt.Sprintf("vm_%s_%s_%d", vmName, action, time.Now().Unix()),
                VMName:      vmName,
        }
        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// handleUpdateVM handles PUT requests to update VM configuration
func (h *VMHandler) handleUpdateVM(w http.ResponseWriter, r *http.Request, vmName string) <span class="cov0" title="0">{
        var request requests.VMUpdateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the update request
        <span class="cov0" title="0">if err := utils.ValidateStruct(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Implementation would update VM configuration
        // For now, return success
        <span class="cov0" title="0">response := responses.VMOperationResponse{
                Success:     true,
                Message:     "VM configuration updated successfully",
                OperationID: fmt.Sprintf("vm_update_%s_%d", vmName, time.Now().Unix()),
                VMName:      vmName,
        }
        utils.WriteJSON(w, http.StatusOK, response)</span>
}

// handleDeleteVM handles DELETE requests to remove a VM
func (h *VMHandler) handleDeleteVM(w http.ResponseWriter, r *http.Request, vmName string) <span class="cov0" title="0">{
        // Implementation would delete VM
        // For now, return success
        response := responses.VMOperationResponse{
                Success:     true,
                Message:     "VM deleted successfully",
                OperationID: fmt.Sprintf("vm_delete_%s_%d", vmName, time.Now().Unix()),
                VMName:      vmName,
        }
        utils.WriteJSON(w, http.StatusOK, response)
}</span>

// HandleVMCreate handles POST /api/v1/vms (create new VM)
func (h *VMHandler) HandleVMCreate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var request requests.VMCreateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate the create request
        <span class="cov0" title="0">if err := utils.ValidateVMCreateRequest(&amp;request); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return
        }</span>

        // Implementation would create VM
        // For now, return success
        <span class="cov0" title="0">response := responses.VMOperationResponse{
                Success:     true,
                Message:     "VM created successfully",
                OperationID: fmt.Sprintf("vm_create_%s_%d", request.Name, time.Now().Unix()),
                VMName:      request.Name,
        }
        utils.WriteJSON(w, http.StatusCreated, response)</span>
}

// HandleVMSnapshot handles VM snapshot operations
func (h *VMHandler) HandleVMSnapshot(w http.ResponseWriter, r *http.Request, vmName string) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                // List snapshots
                snapshots := h.getVMSnapshots(vmName)
                utils.WriteJSON(w, http.StatusOK, snapshots)</span>

        case http.MethodPost:<span class="cov0" title="0">
                // Create snapshot
                var request requests.VMSnapshotRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusBadRequest, "Invalid JSON request")
                        return
                }</span>

                <span class="cov0" title="0">err := h.createVMSnapshot(vmName, request)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to create snapshot: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">response := responses.VMOperationResponse{
                        Success:     true,
                        Message:     "VM snapshot created successfully",
                        OperationID: fmt.Sprintf("vm_snapshot_%s_%d", vmName, time.Now().Unix()),
                        VMName:      vmName,
                }
                utils.WriteJSON(w, http.StatusCreated, response)</span>

        default:<span class="cov0" title="0">
                utils.WriteError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// Helper methods for snapshots

// getVMSnapshots returns a list of snapshots for a VM
func (h *VMHandler) getVMSnapshots(vmName string) []responses.VMSnapshotInfo <span class="cov0" title="0">{
        // Implementation would get actual snapshots
        // For now, return empty list
        return []responses.VMSnapshotInfo{}
}</span>

// createVMSnapshot creates a snapshot for a VM
func (h *VMHandler) createVMSnapshot(vmName string, request requests.VMSnapshotRequest) error <span class="cov0" title="0">{
        // Implementation would create actual snapshot
        // For now, return success
        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/logger"
        "github.com/domalab/uma/daemon/services/api/utils"
        "github.com/gorilla/websocket"
)

// WebSocketHandler handles WebSocket-related HTTP requests
type WebSocketHandler struct {
        api      utils.APIInterface
        upgrader websocket.Upgrader
}

// NewWebSocketHandler creates a new WebSocket handler
func NewWebSocketHandler(api utils.APIInterface) *WebSocketHandler <span class="cov0" title="0">{
        return &amp;WebSocketHandler{
                api: api,
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                // Allow all origins for now - should be configurable in production
                                return true
                        }</span>,
                },
        }
}

// HandleSystemStatsWebSocket handles WebSocket connections for system stats
func (h *WebSocketHandler) HandleSystemStatsWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := h.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("WebSocket upgrade failed: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        logger.Green("System stats WebSocket connection established")

        // Send system stats every 5 seconds
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        stats := h.getSystemStats()
                        if err := conn.WriteJSON(stats); err != nil </span><span class="cov0" title="0">{
                                logger.Yellow("Failed to send system stats: %v", err)
                                return
                        }</span>
                }
        }
}

// HandleDockerEventsWebSocket handles WebSocket connections for Docker events
func (h *WebSocketHandler) HandleDockerEventsWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := h.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("WebSocket upgrade failed: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        logger.Green("Docker events WebSocket connection established")

        // Send Docker events every 10 seconds
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        events := h.getDockerEvents()
                        if err := conn.WriteJSON(events); err != nil </span><span class="cov0" title="0">{
                                logger.Yellow("Failed to send Docker events: %v", err)
                                return
                        }</span>
                }
        }
}

// HandleStorageStatusWebSocket handles WebSocket connections for storage status
func (h *WebSocketHandler) HandleStorageStatusWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := h.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("WebSocket upgrade failed: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        logger.Green("Storage status WebSocket connection established")

        // Send storage status every 15 seconds
        ticker := time.NewTicker(15 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        status := h.getStorageStatus()
                        if err := conn.WriteJSON(status); err != nil </span><span class="cov0" title="0">{
                                logger.Yellow("Failed to send storage status: %v", err)
                                return
                        }</span>
                }
        }
}

// Helper methods for WebSocket data

// getSystemStats returns current system statistics
func (h *WebSocketHandler) getSystemStats() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get CPU info
        if cpuInfo, err := h.api.GetSystem().GetCPUInfo(); err == nil </span><span class="cov0" title="0">{
                stats["cpu"] = cpuInfo
        }</span>

        // Get memory info
        <span class="cov0" title="0">if memInfo, err := h.api.GetSystem().GetMemoryInfo(); err == nil </span><span class="cov0" title="0">{
                stats["memory"] = memInfo
        }</span>

        // Get load info
        <span class="cov0" title="0">if loadInfo, err := h.api.GetSystem().GetLoadInfo(); err == nil </span><span class="cov0" title="0">{
                stats["load"] = loadInfo
        }</span>

        // Get network info
        <span class="cov0" title="0">if networkInfo, err := h.api.GetSystem().GetNetworkInfo(); err == nil </span><span class="cov0" title="0">{
                stats["network"] = networkInfo
        }</span>

        <span class="cov0" title="0">stats["timestamp"] = time.Now().UTC().Format(time.RFC3339)
        stats["type"] = "system_stats"

        return stats</span>
}

// getDockerEvents returns current Docker events/status
func (h *WebSocketHandler) getDockerEvents() map[string]interface{} <span class="cov0" title="0">{
        events := make(map[string]interface{})

        // Get container status
        if containers, err := h.api.GetDocker().GetContainers(); err == nil </span><span class="cov0" title="0">{
                events["containers"] = containers
        }</span>

        // Get Docker system info
        <span class="cov0" title="0">if info, err := h.api.GetDocker().GetSystemInfo(); err == nil </span><span class="cov0" title="0">{
                events["system_info"] = info
        }</span>

        <span class="cov0" title="0">events["timestamp"] = time.Now().UTC().Format(time.RFC3339)
        events["type"] = "docker_events"

        return events</span>
}

// getStorageStatus returns current storage status
func (h *WebSocketHandler) getStorageStatus() map[string]interface{} <span class="cov0" title="0">{
        status := make(map[string]interface{})

        // Get array info
        if arrayInfo, err := h.api.GetStorage().GetArrayInfo(); err == nil </span><span class="cov0" title="0">{
                status["array"] = arrayInfo
        }</span>

        // Get disk info
        <span class="cov0" title="0">if disks, err := h.api.GetStorage().GetDisks(); err == nil </span><span class="cov0" title="0">{
                status["disks"] = disks
        }</span>

        // Get cache info
        <span class="cov0" title="0">if cacheInfo, err := h.api.GetStorage().GetCacheInfo(); err == nil </span><span class="cov0" title="0">{
                status["cache"] = cacheInfo
        }</span>

        <span class="cov0" title="0">status["timestamp"] = time.Now().UTC().Format(time.RFC3339)
        status["type"] = "storage_status"

        return status</span>
}

// HandleWebSocketMessage handles incoming WebSocket messages
func (h *WebSocketHandler) HandleWebSocketMessage(conn *websocket.Conn, messageType int, data []byte) error <span class="cov0" title="0">{
        var message map[string]interface{}
        if err := json.Unmarshal(data, &amp;message); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle different message types
        <span class="cov0" title="0">msgType, ok := message["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil // Ignore messages without type
        }</span>

        <span class="cov0" title="0">switch msgType </span>{
        case "ping":<span class="cov0" title="0">
                // Respond to ping with pong
                response := map[string]interface{}{
                        "type":      "pong",
                        "timestamp": time.Now().UTC().Format(time.RFC3339),
                }
                return conn.WriteJSON(response)</span>

        case "subscribe":<span class="cov0" title="0">
                // Handle subscription requests
                return h.handleSubscription(conn, message)</span>

        case "unsubscribe":<span class="cov0" title="0">
                // Handle unsubscription requests
                return h.handleUnsubscription(conn, message)</span>

        default:<span class="cov0" title="0">
                logger.Yellow("Unknown WebSocket message type: %s", msgType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleSubscription handles WebSocket subscription requests
func (h *WebSocketHandler) handleSubscription(conn *websocket.Conn, message map[string]interface{}) error <span class="cov0" title="0">{
        channel, ok := message["channel"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "type":      "subscription_ack",
                "channel":   channel,
                "status":    "subscribed",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        return conn.WriteJSON(response)</span>
}

// handleUnsubscription handles WebSocket unsubscription requests
func (h *WebSocketHandler) handleUnsubscription(conn *websocket.Conn, message map[string]interface{}) error <span class="cov0" title="0">{
        channel, ok := message["channel"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "type":      "unsubscription_ack",
                "channel":   channel,
                "status":    "unsubscribed",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        return conn.WriteJSON(response)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/domalab/uma/daemon/domain"
        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/lib"
        "github.com/domalab/uma/daemon/logger"
        "github.com/domalab/uma/daemon/plugins/notifications"
        "github.com/domalab/uma/daemon/plugins/storage"
        "github.com/domalab/uma/daemon/services/api/adapters"
        "github.com/domalab/uma/daemon/services/api/handlers"
        "github.com/domalab/uma/daemon/services/api/middleware"
        "github.com/domalab/uma/daemon/services/api/utils"
        "github.com/domalab/uma/daemon/services/auth"
        "github.com/domalab/uma/daemon/services/command"
        "github.com/domalab/uma/daemon/services/config"
        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// Context key types for type safety
type contextKey string

const (
        requestIDKey  contextKey = "request_id"
        apiVersionKey contextKey = "api_version"
)

// Array control request/response structures
type ArrayStartRequest struct {
        MaintenanceMode bool `json:"maintenance_mode"`
        CheckFilesystem bool `json:"check_filesystem"`
}

type ArrayStopRequest struct {
        Force          bool `json:"force"`
        UnmountShares  bool `json:"unmount_shares"`
        StopContainers bool `json:"stop_containers"`
        StopVMs        bool `json:"stop_vms"`
}

type ParityCheckRequest struct {
        Type     string `json:"type"`     // "check" or "correct"
        Priority string `json:"priority"` // "low", "normal", "high"
}

type DiskAddRequest struct {
        Device   string `json:"device"`   // e.g., "/dev/sdc"
        Position string `json:"position"` // e.g., "disk1", "parity2"
}

type DiskRemoveRequest struct {
        Position string `json:"position"` // e.g., "disk1", "parity2"
}

type ArrayOperationResponse struct {
        Success       bool   `json:"success"`
        Message       string `json:"message"`
        OperationID   string `json:"operation_id,omitempty"`
        EstimatedTime int    `json:"estimated_time,omitempty"` // seconds
}

type ParityCheckStatus struct {
        Active        bool    `json:"active"`
        Type          string  `json:"type,omitempty"`           // "check" or "correct"
        Progress      float64 `json:"progress,omitempty"`       // 0-100
        Speed         string  `json:"speed,omitempty"`          // e.g., "45.2 MB/s"
        TimeRemaining string  `json:"time_remaining,omitempty"` // e.g., "2h 15m"
        Errors        int     `json:"errors,omitempty"`
}

// Power management request/response structures
type SystemShutdownRequest struct {
        DelaySeconds int    `json:"delay_seconds"` // Delay before shutdown (0-300 seconds)
        Message      string `json:"message"`       // Message to display to users
        Force        bool   `json:"force"`         // Force shutdown even if users are logged in
}

type SystemRebootRequest struct {
        DelaySeconds int    `json:"delay_seconds"` // Delay before reboot (0-300 seconds)
        Message      string `json:"message"`       // Message to display to users
        Force        bool   `json:"force"`         // Force reboot even if users are logged in
}

type SystemSleepRequest struct {
        Type string `json:"type"` // "suspend", "hibernate", or "hybrid"
}

type SystemWakeRequest struct {
        TargetMAC   string `json:"target_mac"`   // MAC address to wake
        BroadcastIP string `json:"broadcast_ip"` // Broadcast IP (optional, defaults to 255.255.255.255)
        Port        int    `json:"port"`         // Port for WOL packet (optional, defaults to 9)
        RepeatCount int    `json:"repeat_count"` // Number of packets to send (optional, defaults to 3)
}

type PowerOperationResponse struct {
        Success       bool   `json:"success"`
        Message       string `json:"message"`
        OperationID   string `json:"operation_id,omitempty"`
        ScheduledTime string `json:"scheduled_time,omitempty"` // ISO 8601 format
}

// User Script Management data structures
type UserScript struct {
        Name        string `json:"name"`
        Description string `json:"description"`
        Path        string `json:"path"`
        Status      string `json:"status"`      // "idle", "running", "completed", "failed"
        LastRun     string `json:"last_run"`    // ISO 8601 format
        LastResult  string `json:"last_result"` // "success", "failed", "unknown"
        PID         int    `json:"pid,omitempty"`
}

type ScriptListResponse struct {
        Scripts []UserScript `json:"scripts"`
}

type ScriptExecuteRequest struct {
        Background bool     `json:"background"`
        Arguments  []string `json:"arguments,omitempty"`
}

type ScriptExecuteResponse struct {
        Success     bool   `json:"success"`
        Message     string `json:"message"`
        ExecutionID string `json:"execution_id,omitempty"`
        PID         int    `json:"pid,omitempty"`
}

type ScriptStatusResponse struct {
        Name      string `json:"name"`
        Status    string `json:"status"`
        PID       int    `json:"pid,omitempty"`
        StartTime string `json:"start_time,omitempty"`
        Duration  string `json:"duration,omitempty"`
        ExitCode  int    `json:"exit_code,omitempty"`
}

type ScriptLogsResponse struct {
        Name string   `json:"name"`
        Logs []string `json:"logs"`
}

// Share Management data structures
type Share struct {
        Name             string   `json:"name"`
        Comment          string   `json:"comment"`
        Path             string   `json:"path"`
        AllocatorMethod  string   `json:"allocator_method"` // "high-water", "most-free", "fill-up"
        MinimumFreeSpace string   `json:"minimum_free_space"`
        SplitLevel       int      `json:"split_level"`
        IncludedDisks    []string `json:"included_disks"`
        ExcludedDisks    []string `json:"excluded_disks"`
        UseCache         string   `json:"use_cache"`  // "yes", "no", "only", "prefer"
        CachePool        string   `json:"cache_pool"` // "cache", "cache2", etc.
        SMBEnabled       bool     `json:"smb_enabled"`
        SMBSecurity      string   `json:"smb_security"` // "public", "secure", "private"
        SMBGuests        bool     `json:"smb_guests"`
        NFSEnabled       bool     `json:"nfs_enabled"`
        NFSSecurity      string   `json:"nfs_security"` // "public", "secure", "private"
        AFPEnabled       bool     `json:"afp_enabled"`
        FTPEnabled       bool     `json:"ftp_enabled"`
        CreatedAt        string   `json:"created_at"`
        ModifiedAt       string   `json:"modified_at"`
}

type ShareUsage struct {
        Name           string  `json:"name"`
        TotalSize      int64   `json:"total_size"`   // bytes
        UsedSize       int64   `json:"used_size"`    // bytes
        FreeSize       int64   `json:"free_size"`    // bytes
        UsedPercent    float64 `json:"used_percent"` // 0-100
        FileCount      int64   `json:"file_count"`
        DirectoryCount int64   `json:"directory_count"`
        LastAccessed   string  `json:"last_accessed"` // ISO 8601 format
}

type ShareListResponse struct {
        Shares []Share `json:"shares"`
}

type ShareCreateRequest struct {
        Name             string   `json:"name"`
        Comment          string   `json:"comment,omitempty"`
        AllocatorMethod  string   `json:"allocator_method,omitempty"`
        MinimumFreeSpace string   `json:"minimum_free_space,omitempty"`
        SplitLevel       int      `json:"split_level,omitempty"`
        IncludedDisks    []string `json:"included_disks,omitempty"`
        ExcludedDisks    []string `json:"excluded_disks,omitempty"`
        UseCache         string   `json:"use_cache,omitempty"`
        CachePool        string   `json:"cache_pool,omitempty"`
        SMBEnabled       bool     `json:"smb_enabled,omitempty"`
        SMBSecurity      string   `json:"smb_security,omitempty"`
        SMBGuests        bool     `json:"smb_guests,omitempty"`
        NFSEnabled       bool     `json:"nfs_enabled,omitempty"`
        NFSSecurity      string   `json:"nfs_security,omitempty"`
        AFPEnabled       bool     `json:"afp_enabled,omitempty"`
        FTPEnabled       bool     `json:"ftp_enabled,omitempty"`
}

type ShareUpdateRequest struct {
        Comment          string   `json:"comment,omitempty"`
        AllocatorMethod  string   `json:"allocator_method,omitempty"`
        MinimumFreeSpace string   `json:"minimum_free_space,omitempty"`
        SplitLevel       int      `json:"split_level,omitempty"`
        IncludedDisks    []string `json:"included_disks,omitempty"`
        ExcludedDisks    []string `json:"excluded_disks,omitempty"`
        UseCache         string   `json:"use_cache,omitempty"`
        CachePool        string   `json:"cache_pool,omitempty"`
        SMBEnabled       bool     `json:"smb_enabled,omitempty"`
        SMBSecurity      string   `json:"smb_security,omitempty"`
        SMBGuests        bool     `json:"smb_guests,omitempty"`
        NFSEnabled       bool     `json:"nfs_enabled,omitempty"`
        NFSSecurity      string   `json:"nfs_security,omitempty"`
        AFPEnabled       bool     `json:"afp_enabled,omitempty"`
        FTPEnabled       bool     `json:"ftp_enabled,omitempty"`
}

type ShareOperationResponse struct {
        Success   bool   `json:"success"`
        Message   string `json:"message"`
        ShareName string `json:"share_name,omitempty"`
}

// CacheEntry represents a cached data entry with expiration
type CacheEntry struct {
        Data      interface{}
        ExpiresAt time.Time
}

// GeneralFormatCache caches expensive operations for the general format endpoint
type GeneralFormatCache struct {
        mu                sync.RWMutex
        systemData        *CacheEntry
        dockerData        *CacheEntry
        vmData            *CacheEntry
        cacheDuration     time.Duration
        lastArrayInfoHash string
}

// HTTPServer handles REST API requests
type HTTPServer struct {
        api             *Api
        server          *http.Server
        port            int
        commandExecutor *command.CommandExecutor
        generalCache    *GeneralFormatCache
        wsManager       *WebSocketManager
        authService     *auth.AuthService
        configService   *config.ViperConfigService
        validator       *validator.Validate

        // Handler instances
        systemHandler    *handlers.SystemHandler
        storageHandler   *handlers.StorageHandler
        dockerHandler    *handlers.DockerHandler
        vmHandler        *handlers.VMHandler
        authHandler      *handlers.AuthHandler
        healthHandler    *handlers.HealthHandler
        docsHandler      *handlers.DocsHandler
        websocketHandler *handlers.WebSocketHandler

        // API adapter
        apiAdapter utils.APIInterface
}

// NewHTTPServer creates a new HTTP server instance
func NewHTTPServer(api *Api, port int) *HTTPServer <span class="cov8" title="1">{
        httpServer := &amp;HTTPServer{
                api:             api,
                port:            port,
                commandExecutor: command.NewCommandExecutor(),
                generalCache: &amp;GeneralFormatCache{
                        cacheDuration: 30 * time.Second, // Cache for 30 seconds
                },
                authService:   api.authService, // Use auth service from API
                configService: config.NewViperConfigService(),
                validator:     validator.New(),
        }

        // Initialize API adapter
        httpServer.apiAdapter = adapters.NewAPIAdapter(api)

        // Initialize handlers
        httpServer.systemHandler = handlers.NewSystemHandler(httpServer.apiAdapter)
        httpServer.storageHandler = handlers.NewStorageHandler(httpServer.apiAdapter)
        httpServer.dockerHandler = handlers.NewDockerHandler(httpServer.apiAdapter)
        httpServer.vmHandler = handlers.NewVMHandler(httpServer.apiAdapter)
        httpServer.authHandler = handlers.NewAuthHandler(httpServer.apiAdapter)
        httpServer.healthHandler = handlers.NewHealthHandler(httpServer.apiAdapter, api.ctx.Config.Version)
        httpServer.docsHandler = handlers.NewDocsHandler(api.ctx.Config.Version, fmt.Sprintf("http://localhost:%d", port))
        httpServer.websocketHandler = handlers.NewWebSocketHandler(httpServer.apiAdapter)

        // Initialize WebSocket manager
        httpServer.wsManager = NewWebSocketManager(httpServer)

        return httpServer
}</span>

// authMiddleware wraps the auth service middleware for HTTP mux
func (h *HTTPServer) authMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        if h.authService != nil &amp;&amp; h.authService.IsEnabled() </span><span class="cov8" title="1">{
                return h.authService.AuthMiddleware(next)
        }</span>
        <span class="cov8" title="1">return next</span>
}

// Start starts the HTTP server
func (h *HTTPServer) Start() error <span class="cov8" title="1">{
        // Setup HTTP mux with all API routes
        mux := http.NewServeMux()

        // Health and documentation endpoints
        mux.HandleFunc("/api/v1/health", h.healthHandler.HandleHealth)
        mux.HandleFunc("/api/v1/docs", h.docsHandler.SwaggerUIHandler)
        mux.HandleFunc("/api/v1/openapi.json", h.docsHandler.OpenAPIHandler)

        // Async operations endpoints
        mux.HandleFunc("/api/v1/operations", h.AsyncOperationsHandler)
        mux.HandleFunc("/api/v1/operations/", h.AsyncOperationHandler)
        mux.HandleFunc("/api/v1/operations/stats", h.AsyncStatsHandler)

        // Rate limiting endpoints
        mux.HandleFunc("/api/v1/rate-limits/stats", h.RateLimitStatsHandler)
        mux.HandleFunc("/api/v1/rate-limits/config", h.RateLimitConfigHandler)
        mux.HandleFunc("/metrics", middleware.GetMetricsHandler().ServeHTTP)

        // System monitoring endpoints
        mux.HandleFunc("/api/v1/system/info", h.systemHandler.HandleSystemInfo)
        mux.HandleFunc("/api/v1/system/cpu", h.systemHandler.HandleSystemCPU)
        mux.HandleFunc("/api/v1/system/memory", h.systemHandler.HandleSystemMemory)
        mux.HandleFunc("/api/v1/system/fans", h.systemHandler.HandleSystemFans)
        mux.HandleFunc("/api/v1/system/temperature", h.systemHandler.HandleSystemTemperature)
        mux.HandleFunc("/api/v1/system/gpu", h.systemHandler.HandleSystemGPU)
        mux.HandleFunc("/api/v1/system/ups", h.systemHandler.HandleSystemUPS)
        mux.HandleFunc("/api/v1/system/network", h.systemHandler.HandleSystemNetwork)
        mux.HandleFunc("/api/v1/system/resources", h.systemHandler.HandleSystemResources)
        mux.HandleFunc("/api/v1/system/filesystems", h.systemHandler.HandleSystemFilesystems)

        // System control endpoints
        mux.HandleFunc("/api/v1/system/scripts", h.systemHandler.HandleSystemScripts)
        mux.HandleFunc("/api/v1/system/execute", h.systemHandler.HandleSystemExecute)
        mux.HandleFunc("/api/v1/system/reboot", h.systemHandler.HandleSystemReboot)
        mux.HandleFunc("/api/v1/system/shutdown", h.systemHandler.HandleSystemShutdown)
        mux.HandleFunc("/api/v1/system/logs", h.systemHandler.HandleSystemLogs)
        mux.HandleFunc("/api/v1/system/logs/all", h.systemHandler.HandleSystemLogsAll)
        mux.HandleFunc("/api/v1/system/parity/disk", h.storageHandler.HandleParityDisk)
        mux.HandleFunc("/api/v1/system/parity/check", h.storageHandler.HandleParityCheck)

        // Storage management endpoints
        mux.HandleFunc("/api/v1/storage/disks", h.storageHandler.HandleStorageDisks)
        mux.HandleFunc("/api/v1/storage/array", h.storageHandler.HandleStorageArray)
        mux.HandleFunc("/api/v1/storage/cache", h.storageHandler.HandleStorageCache)
        mux.HandleFunc("/api/v1/storage/boot", h.storageHandler.HandleStorageBoot)
        mux.HandleFunc("/api/v1/storage/zfs", h.storageHandler.HandleStorageZFS)
        mux.HandleFunc("/api/v1/storage/general", h.storageHandler.HandleStorageGeneral)

        // Array control endpoints with enhanced orchestration
        mux.HandleFunc("/api/v1/storage/array/start", h.storageHandler.HandleArrayStart)
        mux.HandleFunc("/api/v1/storage/array/stop", h.storageHandler.HandleArrayStop)

        // Docker endpoints
        mux.HandleFunc("/api/v1/docker/containers", h.dockerHandler.HandleDockerContainers)
        mux.HandleFunc("/api/v1/docker/networks", h.dockerHandler.HandleDockerNetworks)
        mux.HandleFunc("/api/v1/docker/images", h.dockerHandler.HandleDockerImages)
        mux.HandleFunc("/api/v1/docker/info", h.dockerHandler.HandleDockerInfo)
        mux.HandleFunc("/api/v1/docker/containers/bulk/start", h.dockerHandler.HandleDockerBulkStart)
        mux.HandleFunc("/api/v1/docker/containers/bulk/stop", h.dockerHandler.HandleDockerBulkStop)
        mux.HandleFunc("/api/v1/docker/containers/bulk/restart", h.dockerHandler.HandleDockerBulkRestart)

        // Individual Docker container control endpoints
        mux.HandleFunc("/api/v1/docker/containers/", h.dockerHandler.HandleDockerContainer) // Handles individual container operations

        // VM management endpoints
        mux.HandleFunc("/api/v1/vms", h.vmHandler.HandleVMList)
        mux.HandleFunc("/api/v1/vms/", h.vmHandler.HandleVM) // Handles all VM operations with path parsing

        // Authentication endpoints
        mux.HandleFunc("/api/v1/auth/login", h.authHandler.HandleAuthLogin)
        mux.HandleFunc("/api/v1/auth/users", h.authHandler.HandleAuthUsers)
        mux.HandleFunc("/api/v1/auth/stats", h.authHandler.HandleAuthStats)

        // WebSocket endpoints
        mux.HandleFunc("/api/v1/ws/system/stats", h.websocketHandler.HandleSystemStatsWebSocket)
        mux.HandleFunc("/api/v1/ws/docker/events", h.websocketHandler.HandleDockerEventsWebSocket)
        mux.HandleFunc("/api/v1/ws/storage/status", h.websocketHandler.HandleStorageStatusWebSocket)

        // Notification endpoints
        mux.HandleFunc("/api/v1/notifications", h.handleNotifications)
        mux.HandleFunc("/api/v1/notifications/", h.handleNotification)
        mux.HandleFunc("/api/v1/notifications/clear", h.handleNotificationsClear)
        mux.HandleFunc("/api/v1/notifications/stats", h.handleNotificationsStats)
        mux.HandleFunc("/api/v1/notifications/mark-all-read", h.handleNotificationsMarkAllRead)

        // Build middleware chain using extracted middleware
        handler := middleware.CORS()(mux)
        handler = middleware.RequestID()(handler)
        handler = middleware.Versioning()(handler)
        handler = middleware.Compression()(handler)
        handler = middleware.Metrics()(handler)
        handler = middleware.Logging()(handler)
        // Authentication middleware ready for production (temporarily disabled for testing)
        // handler = middleware.Auth(h.authService)(handler)

        h.server = &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", h.port),
                Handler:      handler,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        logger.Blue("Starting HTTP API server on port %d", h.port)

        go func() </span><span class="cov8" title="1">{
                if err := h.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Yellow("HTTP server error: %v", err)
                }</span>
        }()

        // Start WebSocket broadcasters
        <span class="cov8" title="1">h.startWebSocketBroadcasters()

        return nil</span>
}

// Stop gracefully stops the HTTP server
func (h *HTTPServer) Stop() error <span class="cov8" title="1">{
        if h.server == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        logger.Blue("Shutting down HTTP API server...")
        return h.server.Shutdown(ctx)</span>
}

// Cache helper methods for general format optimization

// getCachedData retrieves cached data if valid, otherwise returns nil
func (cache *GeneralFormatCache) getCachedData(entry **CacheEntry) interface{} <span class="cov8" title="1">{
        cache.mu.RLock()
        defer cache.mu.RUnlock()

        if *entry != nil &amp;&amp; time.Now().Before((*entry).ExpiresAt) </span><span class="cov8" title="1">{
                return (*entry).Data
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// setCachedData stores data in cache with expiration
func (cache *GeneralFormatCache) setCachedData(entry **CacheEntry, data interface{}) <span class="cov8" title="1">{
        cache.mu.Lock()
        defer cache.mu.Unlock()

        *entry = &amp;CacheEntry{
                Data:      data,
                ExpiresAt: time.Now().Add(cache.cacheDuration),
        }
}</span>

// Response helper methods for standardized API responses

// parsePaginationParams extracts pagination parameters from request
func (h *HTTPServer) parsePaginationParams(r *http.Request) *dto.PaginationParams <span class="cov8" title="1">{
        params := &amp;dto.PaginationParams{}

        if pageStr := r.URL.Query().Get("page"); pageStr != "" </span><span class="cov8" title="1">{
                if page, err := strconv.Atoi(pageStr); err == nil </span><span class="cov8" title="1">{
                        params.Page = page
                }</span>
        }

        <span class="cov8" title="1">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.Atoi(limitStr); err == nil </span><span class="cov8" title="1">{
                        params.Limit = limit
                }</span>
        }

        <span class="cov8" title="1">if perPageStr := r.URL.Query().Get("per_page"); perPageStr != "" </span><span class="cov8" title="1">{
                if perPage, err := strconv.Atoi(perPageStr); err == nil </span><span class="cov8" title="1">{
                        params.PerPage = perPage
                }</span>
        }

        <span class="cov8" title="1">return params</span>
}

// writeStandardResponse writes a standardized API response
func (h *HTTPServer) writeStandardResponse(w http.ResponseWriter, status int, data interface{}, pagination *dto.PaginationInfo) <span class="cov8" title="1">{
        response := dto.StandardResponse{
                Data:       data,
                Pagination: pagination,
                Meta: &amp;dto.ResponseMeta{
                        RequestID: h.getRequestID(w),
                        Version:   h.api.ctx.Config.Version,
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                },
        }

        h.writeJSON(w, status, response)
}</span>

// writePaginatedResponse writes a paginated API response
func (h *HTTPServer) writePaginatedResponse(w http.ResponseWriter, status int, data interface{}, total int, params *dto.PaginationParams) <span class="cov8" title="1">{
        pagination := dto.CalculatePagination(total, params)
        h.writeStandardResponse(w, status, data, pagination)
}</span>

// getRequestID gets the request ID from context or response header
func (h *HTTPServer) getRequestID(w http.ResponseWriter) string <span class="cov8" title="1">{
        // Check if request ID was set in response headers by middleware
        if requestID := w.Header().Get("X-Request-ID"); requestID != "" </span><span class="cov8" title="1">{
                return requestID
        }</span>

        // Generate a simple request ID as fallback
        <span class="cov8" title="1">return fmt.Sprintf("req_%d", time.Now().UnixNano())</span>
}

// getRequestIDFromContext gets the request ID from request context
func (h *HTTPServer) getRequestIDFromContext(r *http.Request) string <span class="cov8" title="1">{
        if requestID, ok := r.Context().Value(requestIDKey).(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// paginateSlice applies pagination to a slice and returns the paginated subset
func (h *HTTPServer) paginateSlice(items interface{}, params *dto.PaginationParams) (interface{}, int) <span class="cov0" title="0">{
        // This is a generic pagination helper - in practice, you'd implement type-specific versions
        // For now, we'll handle common slice types

        switch v := items.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                total := len(v)
                start := (params.GetPage() - 1) * params.GetLimit()
                end := start + params.GetLimit()

                if start &gt;= total </span><span class="cov0" title="0">{
                        return []interface{}{}, total
                }</span>
                <span class="cov0" title="0">if end &gt; total </span><span class="cov0" title="0">{
                        end = total
                }</span>

                <span class="cov0" title="0">return v[start:end], total</span>
        default:<span class="cov0" title="0">
                // For other types, return as-is (no pagination)
                return items, 0</span>
        }
}

// handleSystemInfo handles GET /api/v1/system/info
func (h *HTTPServer) handleSystemInfo(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">info := h.api.getInfo()
        h.writeJSON(w, http.StatusOK, info)</span>
}

// handleHealth handles GET /api/v1/health
func (h *HTTPServer) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Get request ID for tracking and start timing
        <span class="cov8" title="1">requestID := h.getRequestIDFromContext(r)
        startTime := time.Now()

        health := h.getEnhancedHealthStatus()

        // Record health check metrics
        duration := time.Since(startTime)
        if dependencies, ok := health["dependencies"].(map[string]string); ok </span><span class="cov8" title="1">{
                status, _ := health["status"].(string)
                RecordHealthCheck(status, dependencies, duration, requestID)
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, health)</span>
}

// getEnhancedHealthStatus returns comprehensive health status information
func (h *HTTPServer) getEnhancedHealthStatus() map[string]interface{} <span class="cov8" title="1">{
        startTime := time.Now()

        // Check dependencies
        dependencies := h.checkDependencies()

        // Calculate overall status
        overallStatus := "healthy"
        for _, status := range dependencies </span><span class="cov8" title="1">{
                if status != "healthy" </span><span class="cov8" title="1">{
                        overallStatus = "degraded"
                        break</span>
                }
        }

        // Get metrics
        <span class="cov8" title="1">metrics := h.getHealthMetrics()

        health := map[string]interface{}{
                "status":       overallStatus,
                "version":      h.api.ctx.Config.Version,
                "service":      "uma",
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
                "dependencies": dependencies,
                "metrics":      metrics,
                "checks": map[string]interface{}{
                        "response_time_ms": time.Since(startTime).Milliseconds(),
                },
        }

        return health</span>
}

// checkDependencies checks the health of various system dependencies
func (h *HTTPServer) checkDependencies() map[string]string <span class="cov8" title="1">{
        dependencies := make(map[string]string)

        // Check Docker
        dependencies["docker"] = h.checkDockerHealth()

        // Check libvirt (VMs)
        dependencies["libvirt"] = h.checkLibvirtHealth()

        // Check storage
        dependencies["storage"] = h.checkStorageHealth()

        // Check notifications system
        dependencies["notifications"] = h.checkNotificationsHealth()

        return dependencies
}</span>

// checkDockerHealth checks if Docker daemon is accessible
func (h *HTTPServer) checkDockerHealth() string <span class="cov8" title="1">{
        if h.api.docker == nil </span><span class="cov8" title="1">{
                return "unavailable"
        }</span>

        // Try to get Docker info
        <span class="cov0" title="0">_, err := h.api.docker.GetDockerInfo()
        if err != nil </span><span class="cov0" title="0">{
                return "unhealthy"
        }</span>

        <span class="cov0" title="0">return "healthy"</span>
}

// checkLibvirtHealth checks if libvirt is accessible
func (h *HTTPServer) checkLibvirtHealth() string <span class="cov8" title="1">{
        if h.api.vm == nil </span><span class="cov8" title="1">{
                return "unavailable"
        }</span>

        // Try to list VMs
        <span class="cov0" title="0">_, err := h.api.vm.ListVMs(false)
        if err != nil </span><span class="cov0" title="0">{
                return "unhealthy"
        }</span>

        <span class="cov0" title="0">return "healthy"</span>
}

// checkStorageHealth checks if storage monitoring is working
func (h *HTTPServer) checkStorageHealth() string <span class="cov8" title="1">{
        if h.api.storage == nil </span><span class="cov8" title="1">{
                return "unavailable"
        }</span>

        // Try to get array info
        <span class="cov0" title="0">_, err := h.api.storage.GetArrayInfo()
        if err != nil </span><span class="cov0" title="0">{
                return "unhealthy"
        }</span>

        <span class="cov0" title="0">return "healthy"</span>
}

// checkNotificationsHealth checks if notifications system is working
func (h *HTTPServer) checkNotificationsHealth() string <span class="cov8" title="1">{
        if h.api.notifications == nil </span><span class="cov8" title="1">{
                return "unavailable"
        }</span>

        // Try to get notification stats
        <span class="cov0" title="0">_, err := h.api.notifications.GetNotificationStats()
        if err != nil </span><span class="cov0" title="0">{
                return "unhealthy"
        }</span>

        <span class="cov0" title="0">return "healthy"</span>
}

// getHealthMetrics returns system metrics for health monitoring
func (h *HTTPServer) getHealthMetrics() map[string]interface{} <span class="cov8" title="1">{
        metrics := make(map[string]interface{})

        // Get uptime from system
        if uptimeInfo, err := h.api.system.GetUptimeInfo(); err == nil </span><span class="cov0" title="0">{
                metrics["uptime_seconds"] = int64(uptimeInfo.Uptime)
                metrics["uptime_human"] = fmt.Sprintf("%.0f seconds", uptimeInfo.Uptime)
        }</span>

        // Get memory usage
        <span class="cov8" title="1">if memInfo, err := h.api.system.GetMemoryInfo(); err == nil </span><span class="cov0" title="0">{
                metrics["memory_usage_percent"] = memInfo.UsedPercent
                metrics["memory_total_bytes"] = memInfo.Total
                metrics["memory_used_bytes"] = memInfo.Used
                metrics["memory_total_formatted"] = memInfo.TotalFormatted
                metrics["memory_used_formatted"] = memInfo.UsedFormatted

                // Add detailed memory breakdown
                metrics["memory_available_bytes"] = memInfo.Available
                metrics["memory_available_formatted"] = memInfo.AvailableFormatted
                metrics["memory_free_bytes"] = memInfo.Free
                metrics["memory_free_formatted"] = memInfo.FreeFormatted
                metrics["memory_cached_bytes"] = memInfo.Cached
                metrics["memory_cached_formatted"] = memInfo.CachedFormatted
                metrics["memory_buffers_bytes"] = memInfo.Buffers
                metrics["memory_buffers_formatted"] = memInfo.BuffersFormatted

                // Add memory breakdown by category if available
                if memInfo.Breakdown != nil </span><span class="cov0" title="0">{
                        metrics["memory_vm_bytes"] = memInfo.Breakdown.VM
                        metrics["memory_vm_formatted"] = memInfo.Breakdown.VMFormatted
                        metrics["memory_docker_bytes"] = memInfo.Breakdown.Docker
                        metrics["memory_docker_formatted"] = memInfo.Breakdown.DockerFormatted
                        metrics["memory_zfs_arc_bytes"] = memInfo.Breakdown.ZFSCache
                        metrics["memory_zfs_arc_formatted"] = memInfo.Breakdown.ZFSCacheFormatted
                }</span>
        }

        // Get basic system info
        <span class="cov8" title="1">if cpuInfo, err := h.api.system.GetCPUInfo(); err == nil </span><span class="cov8" title="1">{
                metrics["cpu_usage_percent"] = cpuInfo.Usage
                metrics["cpu_temperature"] = cpuInfo.Temperature
                metrics["cpu_cores"] = cpuInfo.Cores
                metrics["cpu_model"] = cpuInfo.Model
        }</span>

        // Get CPU load averages
        <span class="cov8" title="1">if loadInfo, err := h.api.system.GetLoadInfo(); err == nil </span><span class="cov0" title="0">{
                metrics["cpu_load_1m"] = loadInfo.Load1
                metrics["cpu_load_5m"] = loadInfo.Load5
                metrics["cpu_load_15m"] = loadInfo.Load15
        }</span>

        // Add API call metrics (placeholder - would need actual implementation)
        <span class="cov8" title="1">metrics["api_calls_total"] = 0 // This would be tracked by middleware

        // Add global timestamp
        metrics["last_updated"] = time.Now().UTC().Format(time.RFC3339)

        return metrics</span>
}

// handleConfig handles GET/PUT /api/v1/config
func (h *HTTPServer) handleConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                config := h.api.configManager.GetConfig()
                // Remove sensitive information
                config.Auth.APIKey = ""
                config.Auth.JWTSecret = ""
                h.writeJSON(w, http.StatusOK, config)</span>

        case http.MethodPut:<span class="cov0" title="0">
                var newConfig domain.Config
                if err := json.NewDecoder(r.Body).Decode(&amp;newConfig); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid JSON")
                        return
                }</span>

                // Preserve sensitive fields if not provided
                <span class="cov0" title="0">currentConfig := h.api.configManager.GetConfig()
                if newConfig.Auth.APIKey == "" </span><span class="cov0" title="0">{
                        newConfig.Auth.APIKey = currentConfig.Auth.APIKey
                }</span>
                <span class="cov0" title="0">if newConfig.Auth.JWTSecret == "" </span><span class="cov0" title="0">{
                        newConfig.Auth.JWTSecret = currentConfig.Auth.JWTSecret
                }</span>

                <span class="cov0" title="0">h.api.configManager.UpdateConfig(newConfig)
                if err := h.api.configManager.Save(); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, "Failed to save configuration")
                        return
                }</span>

                <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "Configuration updated"})</span>

        default:<span class="cov8" title="1">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// handleSystemResources handles GET /api/v1/system/resources
func (h *HTTPServer) handleSystemResources(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">resources := make(map[string]interface{})

        // CPU information
        if cpuInfo, err := h.api.system.GetCPUInfo(); err == nil </span><span class="cov8" title="1">{
                resources["cpu"] = cpuInfo
        }</span>

        // Memory information
        <span class="cov8" title="1">if memInfo, err := h.api.system.GetMemoryInfo(); err == nil </span><span class="cov0" title="0">{
                resources["memory"] = memInfo
        }</span>

        // Load information
        <span class="cov8" title="1">if loadInfo, err := h.api.system.GetLoadInfo(); err == nil </span><span class="cov0" title="0">{
                resources["load"] = loadInfo
        }</span>

        // Uptime information
        <span class="cov8" title="1">if uptimeInfo, err := h.api.system.GetUptimeInfo(); err == nil </span><span class="cov0" title="0">{
                resources["uptime"] = uptimeInfo
        }</span>

        // Network information
        <span class="cov8" title="1">if networkInfo, err := h.api.system.GetNetworkInfo(); err == nil </span><span class="cov0" title="0">{
                resources["network"] = networkInfo
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, resources)</span>
}

// handleSystemCPU handles GET /api/v1/system/cpu
func (h *HTTPServer) handleSystemCPU(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">cpuData := h.getCPUData()
        if cpuData == nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get CPU information")
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, cpuData)</span>
}

// handleSystemMemory handles GET /api/v1/system/memory
func (h *HTTPServer) handleSystemMemory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">memoryData := h.getMemoryData()
        if memoryData == nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get memory information")
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, memoryData)</span>
}

// handleSystemTemperature handles GET /api/v1/system/temperature
func (h *HTTPServer) handleSystemTemperature(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">tempData := h.getTemperatureData()
        if tempData == nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get temperature information")
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, tempData)</span>
}

// handleSystemNetwork handles GET /api/v1/system/network
func (h *HTTPServer) handleSystemNetwork(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">networkData := h.getNetworkData()
        if networkData == nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get network information")
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, networkData)</span>
}

// handleSystemUPS handles GET /api/v1/system/ups
func (h *HTTPServer) handleSystemUPS(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">upsData := h.getUPSData()
        h.writeJSON(w, http.StatusOK, upsData)</span>
}

// handleSystemGPU handles GET /api/v1/system/gpu
func (h *HTTPServer) handleSystemGPU(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">gpuData := h.getIntelGPUData()
        if gpuData == nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get GPU information")
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, gpuData)</span>
}

// handleSystemFans handles GET /api/v1/system/fans
func (h *HTTPServer) handleSystemFans(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">timestamp := time.Now().UTC().Format(time.RFC3339)

        // Get enhanced temperature data which includes fan information
        enhancedData, err := h.api.system.GetEnhancedTemperatureData()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get fan information: %v", err))
                return
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "fans":         enhancedData.Fans,
                "last_updated": timestamp,
        }

        h.writeJSON(w, http.StatusOK, response)</span>
}

// handleSystemFilesystems handles GET /api/v1/system/filesystems
func (h *HTTPServer) handleSystemFilesystems(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">fsData := h.getFilesystemData()
        h.writeJSON(w, http.StatusOK, fsData)</span>
}

// handleStorageArray handles GET /api/v1/storage/array
func (h *HTTPServer) handleStorageArray(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">arrayInfo, err := h.api.storage.GetArrayInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get array info: %v", err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, arrayInfo)</span>
}

// handleStorageCache handles GET /api/v1/storage/cache
func (h *HTTPServer) handleStorageCache(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">cacheInfo, err := h.api.storage.GetCacheInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get cache info: %v", err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, cacheInfo)</span>
}

// handleStorageBoot handles GET /api/v1/storage/boot
func (h *HTTPServer) handleStorageBoot(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">bootInfo, err := h.api.storage.GetBootDiskInfo()
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get boot disk info: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, bootInfo)</span>
}

// handleStorageZFS handles GET /api/v1/storage/zfs
func (h *HTTPServer) handleStorageZFS(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">zfsInfo, err := h.api.storage.GetZFSInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get ZFS info: %v", err))
                return
        }</span>

        // Return appropriate response based on ZFS availability
        <span class="cov8" title="1">if !zfsInfo.Available </span><span class="cov8" title="1">{
                h.writeJSON(w, http.StatusOK, map[string]interface{}{
                        "available":    false,
                        "message":      "ZFS is not available on this system",
                        "last_updated": zfsInfo.LastUpdated,
                })
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, zfsInfo)</span>
}

// handleStorageGeneral handles GET /api/v1/storage/general
// Returns storage data in general format with optimized caching and parallel processing
func (h *HTTPServer) handleStorageGeneral(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">startTime := time.Now()
        logger.Blue("Starting optimized general format data collection...")

        // Get array information (this is the core data that changes less frequently)
        arrayInfo, err := h.api.storage.GetArrayInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get array info: %v", err))
                return
        }</span>

        // Convert to general format with optimized parallel data collection
        <span class="cov8" title="1">generalFormat := h.convertToGeneralFormatOptimized(arrayInfo)

        duration := time.Since(startTime)
        logger.Blue("General format data collection completed in %v", duration)

        h.writeJSON(w, http.StatusOK, generalFormat)</span>
}

// handleStorageDisks handles GET /api/v1/storage/disks
func (h *HTTPServer) handleStorageDisks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Check if client wants paginated response
        <span class="cov8" title="1">params := h.parsePaginationParams(r)
        usePagination := r.URL.Query().Get("page") != "" || r.URL.Query().Get("limit") != ""

        disksInfo, err := h.api.storage.GetConsolidatedDisksInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get consolidated disks info: %v", err))
                return
        }</span>

        <span class="cov8" title="1">if usePagination </span><span class="cov0" title="0">{
                // For pagination, we'll flatten all disks into a single array
                allDisks := make([]interface{}, 0)
                for _, disk := range disksInfo.ArrayDisks </span><span class="cov0" title="0">{
                        allDisks = append(allDisks, disk)
                }</span>
                <span class="cov0" title="0">for _, disk := range disksInfo.ParityDisks </span><span class="cov0" title="0">{
                        allDisks = append(allDisks, disk)
                }</span>
                <span class="cov0" title="0">for _, disk := range disksInfo.CacheDisks </span><span class="cov0" title="0">{
                        allDisks = append(allDisks, disk)
                }</span>
                <span class="cov0" title="0">if disksInfo.BootDisk != nil </span><span class="cov0" title="0">{
                        allDisks = append(allDisks, *disksInfo.BootDisk)
                }</span>

                <span class="cov0" title="0">paginatedDisks, total := h.paginateSlice(allDisks, params)
                h.writePaginatedResponse(w, http.StatusOK, paginatedDisks, total, params)</span>
        } else<span class="cov8" title="1"> {
                // Return the original structured format for backward compatibility
                h.writeJSON(w, http.StatusOK, disksInfo)
        }</span>
}

// convertToGeneralFormatOptimized converts array info to general format with caching and parallel processing
func (h *HTTPServer) convertToGeneralFormatOptimized(arrayInfo *storage.ArrayInfo) map[string]interface{} <span class="cov8" title="1">{
        startTime := time.Now()

        // Use channels for parallel data collection
        type dataResult struct {
                name string
                data interface{}
                err  error
        }

        resultChan := make(chan dataResult, 8) // Buffer for 8 concurrent operations
        var wg sync.WaitGroup

        // Parallel data collection functions
        collectSystemData := func() </span><span class="cov8" title="1">{
                defer wg.Done()

                // Check cache first
                if cached := h.generalCache.getCachedData(&amp;h.generalCache.systemData); cached != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- dataResult{name: "system", data: cached}
                        return
                }</span>

                // Collect system data in parallel
                <span class="cov8" title="1">var systemWg sync.WaitGroup
                systemResults := make(map[string]interface{})
                systemMutex := sync.Mutex{}

                // CPU data
                systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getCPUData(); data != nil </span><span class="cov8" title="1">{
                                systemMutex.Lock()
                                systemResults["cpu"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                // Memory data
                <span class="cov8" title="1">systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getMemoryData(); data != nil </span><span class="cov0" title="0">{
                                systemMutex.Lock()
                                systemResults["memory"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                // Temperature data
                <span class="cov8" title="1">systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getTemperatureData(); data != nil </span><span class="cov8" title="1">{
                                systemMutex.Lock()
                                systemResults["temperature"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                // Network data
                <span class="cov8" title="1">systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getNetworkData(); data != nil </span><span class="cov0" title="0">{
                                systemMutex.Lock()
                                systemResults["network"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                // UPS data
                <span class="cov8" title="1">systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getUPSData(); data != nil </span><span class="cov8" title="1">{
                                systemMutex.Lock()
                                systemResults["ups"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                // Intel GPU data
                <span class="cov8" title="1">systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getIntelGPUData(); data != nil </span><span class="cov8" title="1">{
                                systemMutex.Lock()
                                systemResults["intel_gpu"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                // Filesystem data
                <span class="cov8" title="1">systemWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer systemWg.Done()
                        if data := h.getFilesystemData(); data != nil </span><span class="cov8" title="1">{
                                systemMutex.Lock()
                                systemResults["filesystem"] = data
                                systemMutex.Unlock()
                        }</span>
                }()

                <span class="cov8" title="1">systemWg.Wait()

                // Cache the results
                h.generalCache.setCachedData(&amp;h.generalCache.systemData, systemResults)
                resultChan &lt;- dataResult{name: "system", data: systemResults}</span>
        }

        <span class="cov8" title="1">collectDockerData := func() </span><span class="cov8" title="1">{
                defer wg.Done()

                // Check cache first
                if cached := h.generalCache.getCachedData(&amp;h.generalCache.dockerData); cached != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- dataResult{name: "docker", data: cached}
                        return
                }</span>

                <span class="cov8" title="1">if data := h.getDockerDataOptimized(); data != nil </span><span class="cov0" title="0">{
                        h.generalCache.setCachedData(&amp;h.generalCache.dockerData, data)
                        resultChan &lt;- dataResult{name: "docker", data: data}
                }</span> else<span class="cov8" title="1"> {
                        resultChan &lt;- dataResult{name: "docker", data: nil}
                }</span>
        }

        <span class="cov8" title="1">collectVMData := func() </span><span class="cov8" title="1">{
                defer wg.Done()

                // Check cache first
                if cached := h.generalCache.getCachedData(&amp;h.generalCache.vmData); cached != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- dataResult{name: "vm", data: cached}
                        return
                }</span>

                <span class="cov8" title="1">if data := h.getVMDataOptimized(); data != nil </span><span class="cov0" title="0">{
                        h.generalCache.setCachedData(&amp;h.generalCache.vmData, data)
                        resultChan &lt;- dataResult{name: "vm", data: data}
                }</span> else<span class="cov8" title="1"> {
                        resultChan &lt;- dataResult{name: "vm", data: nil}
                }</span>
        }

        // Start parallel data collection
        <span class="cov8" title="1">wg.Add(3)
        go collectSystemData()
        go collectDockerData()
        go collectVMData()

        // Close channel when all goroutines complete
        go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
        }</span>()

        // Collect results
        <span class="cov8" title="1">results := make(map[string]interface{})
        for result := range resultChan </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov0" title="0">{
                        logger.Red("Error collecting %s data: %v", result.name, result.err)
                        continue</span>
                }
                <span class="cov8" title="1">if result.data != nil </span><span class="cov8" title="1">{
                        results[result.name] = result.data
                }</span>
        }

        // Build the final system format
        <span class="cov8" title="1">systemFormat := map[string]interface{}{
                "array_usage": map[string]interface{}{
                        "total":        arrayInfo.TotalSize,
                        "used":         arrayInfo.UsedSize,
                        "free":         arrayInfo.FreeSize,
                        "used_percent": arrayInfo.UsedPercent,
                },
                "array_state": map[string]interface{}{
                        "state":       arrayInfo.State,
                        "num_devices": arrayInfo.NumDevices,
                        "num_disks":   arrayInfo.NumDisks,
                        "num_parity":  arrayInfo.NumParity,
                },
                "disks": h.convertDisksOptimized(arrayInfo.Disks),
        }

        // Add collected data to system format
        if systemData, ok := results["system"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if cpu, exists := systemData["cpu"]; exists </span><span class="cov8" title="1">{
                        systemFormat["cpu"] = cpu
                }</span>
                <span class="cov8" title="1">if memory, exists := systemData["memory"]; exists </span><span class="cov0" title="0">{
                        systemFormat["memory"] = memory
                }</span>
                <span class="cov8" title="1">if temp, exists := systemData["temperature"]; exists </span><span class="cov8" title="1">{
                        systemFormat["temperature"] = temp
                }</span>
                <span class="cov8" title="1">if network, exists := systemData["network"]; exists </span><span class="cov0" title="0">{
                        systemFormat["network"] = network
                }</span>
                <span class="cov8" title="1">if ups, exists := systemData["ups"]; exists </span><span class="cov8" title="1">{
                        systemFormat["ups"] = ups
                }</span>
                <span class="cov8" title="1">if gpu, exists := systemData["intel_gpu"]; exists </span><span class="cov8" title="1">{
                        systemFormat["intel_gpu"] = gpu
                }</span>
                <span class="cov8" title="1">if fs, exists := systemData["filesystem"]; exists </span><span class="cov8" title="1">{
                        systemFormat["filesystem"] = fs
                }</span>
        }

        <span class="cov8" title="1">if dockerData, ok := results["docker"]; ok </span><span class="cov0" title="0">{
                systemFormat["docker"] = dockerData
        }</span>

        <span class="cov8" title="1">if vmData, ok := results["vm"]; ok </span><span class="cov0" title="0">{
                systemFormat["vms"] = vmData
        }</span>

        <span class="cov8" title="1">duration := time.Since(startTime)
        logger.Blue("System format conversion completed in %v", duration)

        return systemFormat</span>
}

// getDockerDataOptimized collects Docker data with parallel container processing
func (h *HTTPServer) getDockerDataOptimized() interface{} <span class="cov8" title="1">{
        dockerManager := h.api.docker
        if dockerManager == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">containers, err := dockerManager.ListContainers(false) // false = don't include all containers
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to get Docker containers: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">if len(containers) == 0 </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "containers": []interface{}{},
                        "total":      0,
                }
        }</span>

        // Process containers in parallel
        <span class="cov0" title="0">containerChan := make(chan interface{}, len(containers))
        var wg sync.WaitGroup

        for _, container := range containers </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(c interface{}) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Get container stats in parallel
                        if containerMap, ok := c.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if id, exists := containerMap["id"].(string); exists </span><span class="cov0" title="0">{
                                        if stats, err := dockerManager.GetContainerStats(id); err == nil </span><span class="cov0" title="0">{
                                                containerMap["stats"] = stats
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">containerChan &lt;- c</span>
                }(container)
        }

        // Close channel when all goroutines complete
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(containerChan)
        }</span>()

        // Collect results
        <span class="cov0" title="0">var processedContainers []interface{}
        for container := range containerChan </span><span class="cov0" title="0">{
                processedContainers = append(processedContainers, container)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "containers": processedContainers,
                "total":      len(processedContainers),
        }</span>
}

// getVMDataOptimized collects VM data with parallel VM processing
func (h *HTTPServer) getVMDataOptimized() interface{} <span class="cov8" title="1">{
        vmManager := h.api.vm
        if vmManager == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">vms, err := vmManager.ListVMs(false) // false = don't include inactive VMs
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to get VMs: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">if len(vms) == 0 </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "vms":   []interface{}{},
                        "total": 0,
                }
        }</span>

        // Process VMs in parallel
        <span class="cov0" title="0">vmChan := make(chan interface{}, len(vms))
        var wg sync.WaitGroup

        for _, vm := range vms </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(v interface{}) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Get VM stats in parallel
                        if vmMap, ok := v.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if name, exists := vmMap["name"].(string); exists </span><span class="cov0" title="0">{
                                        if stats, err := vmManager.GetVMStats(name); err == nil </span><span class="cov0" title="0">{
                                                vmMap["stats"] = stats
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">vmChan &lt;- v</span>
                }(vm)
        }

        // Close channel when all goroutines complete
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(vmChan)
        }</span>()

        // Collect results
        <span class="cov0" title="0">var processedVMs []interface{}
        for vm := range vmChan </span><span class="cov0" title="0">{
                processedVMs = append(processedVMs, vm)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "vms":   processedVMs,
                "total": len(processedVMs),
        }</span>
}

// convertDisksOptimized processes disk data with parallel disk information collection
func (h *HTTPServer) convertDisksOptimized(disks []storage.DiskInfo) []map[string]interface{} <span class="cov8" title="1">{
        if len(disks) == 0 </span><span class="cov8" title="1">{
                return []map[string]interface{}{}
        }</span>

        // Process disks in parallel
        <span class="cov0" title="0">diskChan := make(chan map[string]interface{}, len(disks))
        var wg sync.WaitGroup

        for _, disk := range disks </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(d storage.DiskInfo) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        diskInfo := map[string]interface{}{
                                "name":         d.Name,
                                "device":       d.Device,
                                "size":         d.Size,
                                "used":         d.Used,
                                "available":    d.Available,
                                "used_percent": d.UsedPercent,
                                "mount_point":  d.MountPoint,
                                "file_system":  d.FileSystem,
                                "status":       d.Status,
                                "health":       d.Health,
                                "power_state":  d.PowerState,
                                "disk_type":    d.DiskType,
                                "interface":    d.Interface,
                                "model":        d.Model,
                        }

                        // Add temperature if available
                        if d.Temperature &gt; 0 </span><span class="cov0" title="0">{
                                diskInfo["temperature"] = d.Temperature
                        }</span>

                        // Add serial number if available
                        <span class="cov0" title="0">if d.SerialNumber != "" </span><span class="cov0" title="0">{
                                diskInfo["serial_number"] = d.SerialNumber
                        }</span>

                        // Add spin down delay if available
                        <span class="cov0" title="0">if d.SpinDownDelay &gt; 0 </span><span class="cov0" title="0">{
                                diskInfo["spin_down_delay"] = d.SpinDownDelay
                        }</span>
                        <span class="cov0" title="0">diskChan &lt;- diskInfo</span>
                }(disk)
        }

        // Close channel when all goroutines complete
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(diskChan)
        }</span>()

        // Collect results
        <span class="cov0" title="0">var processedDisks []map[string]interface{}
        for diskInfo := range diskChan </span><span class="cov0" title="0">{
                processedDisks = append(processedDisks, diskInfo)
        }</span>

        <span class="cov0" title="0">return processedDisks</span>
}

// handleDockerContainer handles individual Docker container operations
func (h *HTTPServer) handleDockerContainer(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Extract container ID and operation from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/docker/containers/")
        parts := strings.Split(path, "/")

        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Container ID and operation are required")
                return
        }</span>

        <span class="cov8" title="1">containerID := parts[0]
        operation := parts[1]

        if containerID == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Container ID is required")
                return
        }</span>

        // Only allow POST methods for container operations
        <span class="cov8" title="1">if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Handle different container operations
        <span class="cov8" title="1">switch operation </span>{
        case "start":<span class="cov8" title="1">
                h.handleDockerContainerStart(w, r, containerID)</span>
        case "stop":<span class="cov8" title="1">
                h.handleDockerContainerStop(w, r, containerID)</span>
        case "restart":<span class="cov8" title="1">
                h.handleDockerContainerRestart(w, r, containerID)</span>
        case "pause":<span class="cov0" title="0">
                h.handleDockerContainerPause(w, r, containerID)</span>
        case "resume", "unpause":<span class="cov0" title="0">
                h.handleDockerContainerResume(w, r, containerID)</span>
        default:<span class="cov8" title="1">
                h.writeError(w, http.StatusBadRequest, fmt.Sprintf("Unknown operation: %s", operation))</span>
        }
}

// handleDockerContainerStart handles starting an individual Docker container
func (h *HTTPServer) handleDockerContainerStart(w http.ResponseWriter, r *http.Request, containerID string) <span class="cov8" title="1">{
        err := h.api.docker.StartContainer(containerID)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to start container %s: %v", containerID, err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]interface{}{
                "message":      "Container started successfully",
                "container_id": containerID,
                "operation":    "start",
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
        })</span>
}

// handleDockerContainerStop handles stopping an individual Docker container
func (h *HTTPServer) handleDockerContainerStop(w http.ResponseWriter, r *http.Request, containerID string) <span class="cov8" title="1">{
        // Default timeout of 10 seconds, can be overridden with query parameter
        timeout := 10
        if timeoutParam := r.URL.Query().Get("timeout"); timeoutParam != "" </span><span class="cov0" title="0">{
                if t, err := strconv.Atoi(timeoutParam); err == nil </span><span class="cov0" title="0">{
                        timeout = t
                }</span>
        }

        <span class="cov8" title="1">err := h.api.docker.StopContainer(containerID, timeout)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to stop container %s: %v", containerID, err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, map[string]interface{}{
                "message":      "Container stopped successfully",
                "container_id": containerID,
                "operation":    "stop",
                "timeout":      timeout,
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
        })</span>
}

// handleDockerContainerRestart handles restarting an individual Docker container
func (h *HTTPServer) handleDockerContainerRestart(w http.ResponseWriter, r *http.Request, containerID string) <span class="cov8" title="1">{
        // Default timeout of 10 seconds, can be overridden with query parameter
        timeout := 10
        if timeoutParam := r.URL.Query().Get("timeout"); timeoutParam != "" </span><span class="cov0" title="0">{
                if t, err := strconv.Atoi(timeoutParam); err == nil </span><span class="cov0" title="0">{
                        timeout = t
                }</span>
        }

        <span class="cov8" title="1">err := h.api.docker.RestartContainer(containerID, timeout)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to restart container %s: %v", containerID, err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, map[string]interface{}{
                "message":      "Container restarted successfully",
                "container_id": containerID,
                "operation":    "restart",
                "timeout":      timeout,
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
        })</span>
}

// CommandExecuteRequest represents a command execution request
type CommandExecuteRequest struct {
        Command          string `json:"command"`
        Timeout          int    `json:"timeout,omitempty"`           // Timeout in seconds, default 30
        WorkingDirectory string `json:"working_directory,omitempty"` // Optional working directory
}

// CommandExecuteResponse represents a command execution response
type CommandExecuteResponse struct {
        ExitCode        int    `json:"exit_code"`
        Stdout          string `json:"stdout"`
        Stderr          string `json:"stderr"`
        ExecutionTimeMs int64  `json:"execution_time_ms"`
        Command         string `json:"command"`
        WorkingDir      string `json:"working_directory,omitempty"`
}

// handleSystemExecute handles POST /api/v1/system/execute
func (h *HTTPServer) handleSystemExecute(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var request CommandExecuteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate command
        <span class="cov0" title="0">if strings.TrimSpace(request.Command) == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Command is required")
                return
        }</span>

        // Set default timeout
        <span class="cov0" title="0">if request.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                request.Timeout = 30
        }</span>

        // Limit maximum timeout to 300 seconds (5 minutes)
        <span class="cov0" title="0">if request.Timeout &gt; 300 </span><span class="cov0" title="0">{
                request.Timeout = 300
        }</span>

        // Security: Basic command sanitization
        <span class="cov0" title="0">if h.isCommandBlacklisted(request.Command) </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusForbidden, "Command not allowed")
                return
        }</span>

        // Execute command
        <span class="cov0" title="0">response := h.executeCommand(request)
        h.writeJSON(w, http.StatusOK, response)</span>
}

// LogFileInfo represents metadata about a log file
type LogFileInfo struct {
        Path         string `json:"path"`
        Name         string `json:"name"`
        Size         int64  `json:"size"`
        ModifiedTime string `json:"modified_time"`
        Readable     bool   `json:"readable"`
}

// handleParityDisk handles GET /api/v1/system/parity/disk
func (h *HTTPServer) handleParityDisk(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">parityDisk, err := h.api.system.GetParityDiskInfo()
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get parity disk information: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, parityDisk)</span>
}

// handleParityCheck handles GET /api/v1/system/parity/check
func (h *HTTPServer) handleParityCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">parityCheck, err := h.api.system.GetParityCheckInfo()
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get parity check information: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, parityCheck)</span>
}

// handleDockerContainerPause handles pausing an individual Docker container
func (h *HTTPServer) handleDockerContainerPause(w http.ResponseWriter, r *http.Request, containerID string) <span class="cov0" title="0">{
        err := h.api.docker.PauseContainer(containerID)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to pause container %s: %v", containerID, err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]interface{}{
                "message":      "Container paused successfully",
                "container_id": containerID,
                "operation":    "pause",
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
        })</span>
}

// handleDockerContainerResume handles resuming an individual Docker container
func (h *HTTPServer) handleDockerContainerResume(w http.ResponseWriter, r *http.Request, containerID string) <span class="cov0" title="0">{
        err := h.api.docker.UnpauseContainer(containerID)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to resume container %s: %v", containerID, err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]interface{}{
                "message":      "Container resumed successfully",
                "container_id": containerID,
                "operation":    "resume",
                "timestamp":    time.Now().UTC().Format(time.RFC3339),
        })</span>
}

// getCPUData returns CPU data in standard format
func (h *HTTPServer) getCPUData() map[string]interface{} <span class="cov8" title="1">{
        timestamp := time.Now().UTC().Format(time.RFC3339)

        cpuInfo, err := h.api.system.GetCPUInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "usage_percent":     cpuInfo.Usage,
                "cores":             cpuInfo.Cores,
                "threads":           cpuInfo.Threads,
                "threads_per_core":  cpuInfo.ThreadsPerCore,
                "sockets":           cpuInfo.Sockets,
                "model":             cpuInfo.Model,
                "frequency_mhz":     cpuInfo.Frequency,
                "max_frequency_mhz": cpuInfo.MaxFrequency,
                "min_frequency_mhz": cpuInfo.MinFrequency,
                "temperature":       cpuInfo.Temperature,
                "last_updated":      timestamp,
        }

        // Get CPU load averages
        if loadInfo, err := h.api.system.GetLoadInfo(); err == nil </span><span class="cov0" title="0">{
                response["load_1min"] = loadInfo.Load1
                response["load_5min"] = loadInfo.Load5
                response["load_15min"] = loadInfo.Load15
        }</span>

        <span class="cov8" title="1">return response</span>
}

// getMemoryData returns memory data in standard format
func (h *HTTPServer) getMemoryData() map[string]interface{} <span class="cov8" title="1">{
        timestamp := time.Now().UTC().Format(time.RFC3339)

        memInfo, err := h.api.system.GetMemoryInfo()
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "usage_percent":       memInfo.UsedPercent,
                "total_bytes":         memInfo.Total,
                "used_bytes":          memInfo.Used,
                "free_bytes":          memInfo.Free,
                "available_bytes":     memInfo.Available,
                "buffers_bytes":       memInfo.Buffers,
                "cached_bytes":        memInfo.Cached,
                "total_formatted":     memInfo.TotalFormatted,
                "used_formatted":      memInfo.UsedFormatted,
                "free_formatted":      memInfo.FreeFormatted,
                "available_formatted": memInfo.AvailableFormatted,
                "buffers_formatted":   memInfo.BuffersFormatted,
                "cached_formatted":    memInfo.CachedFormatted,
                "last_updated":        timestamp,
        }

        // Add memory breakdown if available
        if memInfo.Breakdown != nil </span><span class="cov0" title="0">{
                response["breakdown"] = map[string]interface{}{
                        "system_bytes":        memInfo.Breakdown.System,
                        "system_formatted":    memInfo.Breakdown.SystemFormatted,
                        "system_percent":      memInfo.Breakdown.SystemPercent,
                        "vm_bytes":            memInfo.Breakdown.VM,
                        "vm_formatted":        memInfo.Breakdown.VMFormatted,
                        "vm_percent":          memInfo.Breakdown.VMPercent,
                        "docker_bytes":        memInfo.Breakdown.Docker,
                        "docker_formatted":    memInfo.Breakdown.DockerFormatted,
                        "docker_percent":      memInfo.Breakdown.DockerPercent,
                        "zfs_cache_bytes":     memInfo.Breakdown.ZFSCache,
                        "zfs_cache_formatted": memInfo.Breakdown.ZFSCacheFormatted,
                        "zfs_cache_percent":   memInfo.Breakdown.ZFSCachePercent,
                        "other_bytes":         memInfo.Breakdown.Other,
                        "other_formatted":     memInfo.Breakdown.OtherFormatted,
                        "other_percent":       memInfo.Breakdown.OtherPercent,
                }
        }</span>

        <span class="cov0" title="0">return response</span>
}

// getTemperatureData returns temperature sensor data in standard format
func (h *HTTPServer) getTemperatureData() map[string]interface{} <span class="cov8" title="1">{
        // Get enhanced temperature data
        enhancedData, err := h.api.system.GetEnhancedTemperatureData()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to basic temperature data
                return h.getBasicTemperatureData()
        }</span>

        // Convert enhanced data to API format
        <span class="cov8" title="1">result := make(map[string]interface{})

        // Add sensor chips
        if len(enhancedData.Sensors) &gt; 0 </span><span class="cov0" title="0">{
                result["sensor_chips"] = enhancedData.Sensors
        }</span>

        // Add standalone fan data
        <span class="cov8" title="1">if len(enhancedData.Fans) &gt; 0 </span><span class="cov0" title="0">{
                result["fans"] = enhancedData.Fans
        }</span>

        // Add backward compatibility sensors array
        <span class="cov8" title="1">sensors := make([]map[string]interface{}, 0)
        for chipName, chip := range enhancedData.Sensors </span><span class="cov0" title="0">{
                for _, temp := range chip.Temperatures </span><span class="cov0" title="0">{
                        sensors = append(sensors, map[string]interface{}{
                                "name":  fmt.Sprintf("%s - %s", chipName, temp.Label),
                                "value": float64(temp.Value) / 1000.0, // Convert back to Celsius for compatibility
                                "unit":  "C",
                                "chip":  chipName,
                        })
                }</span>
        }

        // Add CPU temperature from system plugin for compatibility
        <span class="cov8" title="1">if cpuInfo, err := h.api.system.GetCPUInfo(); err == nil &amp;&amp; cpuInfo.Temperature &gt; 0 </span><span class="cov0" title="0">{
                sensors = append(sensors, map[string]interface{}{
                        "name":  "CPU",
                        "value": cpuInfo.Temperature,
                        "unit":  "C",
                        "chip":  "system",
                })
        }</span>

        <span class="cov8" title="1">if len(sensors) &gt; 0 </span><span class="cov0" title="0">{
                result["sensors"] = sensors
        }</span>

        <span class="cov8" title="1">return result</span>
}

// getBasicTemperatureData returns basic temperature data as fallback
func (h *HTTPServer) getBasicTemperatureData() map[string]interface{} <span class="cov0" title="0">{
        sensors := make([]map[string]interface{}, 0)

        // Get CPU temperature from system plugin
        if cpuInfo, err := h.api.system.GetCPUInfo(); err == nil &amp;&amp; cpuInfo.Temperature &gt; 0 </span><span class="cov0" title="0">{
                sensors = append(sensors, map[string]interface{}{
                        "name":  "CPU",
                        "value": cpuInfo.Temperature,
                        "unit":  "C",
                })
        }</span>

        // Get additional sensors from sensor plugin
        <span class="cov0" title="0">if h.api.sensor != nil </span><span class="cov0" title="0">{
                prefs := dto.Prefs{Unit: "C"} // Default to Celsius
                samples := h.api.sensor.GetReadings(prefs)
                for _, sample := range samples </span><span class="cov0" title="0">{
                        if sample.Unit == "C" </span><span class="cov0" title="0">{
                                sensors = append(sensors, map[string]interface{}{
                                        "name":  sample.Key,
                                        "value": sample.Value,
                                        "unit":  sample.Unit,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(sensors) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "sensors": sensors,
        }</span>
}

// getNetworkData returns network statistics in standard format
func (h *HTTPServer) getNetworkData() map[string]interface{} <span class="cov8" title="1">{
        networkInfo, err := h.api.system.GetNetworkInfo()
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">interfaces := make([]map[string]interface{}, 0)
        for _, netInfo := range networkInfo </span><span class="cov0" title="0">{
                interfaceData := map[string]interface{}{
                        "name":       netInfo.Interface,
                        "rx_bytes":   netInfo.BytesRecv,
                        "tx_bytes":   netInfo.BytesSent,
                        "rx_packets": netInfo.PacketsRecv,
                        "tx_packets": netInfo.PacketsSent,
                        "rx_errors":  netInfo.ErrorsRecv,
                        "tx_errors":  netInfo.ErrorsSent,
                        "connected":  netInfo.Connected,
                }

                // Add speed and duplex if available
                if netInfo.SpeedMbps &gt; 0 </span><span class="cov0" title="0">{
                        interfaceData["speed_mbps"] = netInfo.SpeedMbps
                }</span>
                <span class="cov0" title="0">if netInfo.Duplex != "" </span><span class="cov0" title="0">{
                        interfaceData["duplex"] = netInfo.Duplex
                }</span>

                <span class="cov0" title="0">interfaces = append(interfaces, interfaceData)</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "interfaces":   interfaces,
                "last_updated": time.Now().UTC().Format(time.RFC3339),
        }</span>
}

// getUPSData returns UPS information in standard format
func (h *HTTPServer) getUPSData() map[string]interface{} <span class="cov8" title="1">{
        // Default UPS data structure
        upsData := map[string]interface{}{
                "status":         "unknown",
                "battery_charge": 0,
                "runtime":        0,
                "load_percent":   0,
                "input_voltage":  0,
                "output_voltage": 0,
                "model":          "unknown",
                "connected":      false,
                "last_updated":   time.Now().UTC().Format(time.RFC3339),
        }

        // Always check for UPS hardware regardless of config setting
        // Check for APC UPS daemon first (most common)
        if _, err := os.Stat("/var/run/apcupsd.pid"); err == nil </span><span class="cov0" title="0">{
                // apcupsd is running, try to get UPS data
                if apcData := h.getAPCUPSData(); apcData != nil </span><span class="cov0" title="0">{
                        return apcData
                }</span>
        }

        // Check for NUT (Network UPS Tools) as fallback
        <span class="cov8" title="1">if _, err := os.Stat("/var/run/nut/upsmon.pid"); err == nil </span><span class="cov0" title="0">{
                // NUT is running, try to get UPS data
                if nutData := h.getNUTUPSData(); nutData != nil </span><span class="cov0" title="0">{
                        return nutData
                }</span>
        }

        // Fallback to legacy UPS API if available
        <span class="cov8" title="1">if h.api.ups != nil </span><span class="cov0" title="0">{
                samples := h.api.ups.GetStatus()
                for _, sample := range samples </span><span class="cov0" title="0">{
                        switch sample.Key </span>{
                        case "UPS STATUS":<span class="cov0" title="0">
                                if sample.Condition == "green" </span><span class="cov0" title="0">{
                                        upsData["status"] = "online"
                                }</span> else<span class="cov0" title="0"> if sample.Condition == "red" </span><span class="cov0" title="0">{
                                        upsData["status"] = "offline"
                                }</span> else<span class="cov0" title="0"> {
                                        upsData["status"] = "unknown"
                                }</span>
                        case "UPS CHARGE":<span class="cov0" title="0">
                                if charge, err := strconv.ParseFloat(sample.Value, 64); err == nil </span><span class="cov0" title="0">{
                                        upsData["battery_charge"] = charge
                                }</span>
                        case "UPS RUNTIME":<span class="cov0" title="0">
                                if runtime, err := strconv.ParseFloat(sample.Value, 64); err == nil </span><span class="cov0" title="0">{
                                        upsData["runtime"] = runtime
                                }</span>
                        }
                }
                <span class="cov0" title="0">upsData["connected"] = true</span>
        }

        <span class="cov8" title="1">return upsData</span>
}

// isCommandBlacklisted checks if a command is blacklisted for security
func (h *HTTPServer) isCommandBlacklisted(command string) bool <span class="cov0" title="0">{
        // List of dangerous commands that should not be allowed
        blacklistedCommands := []string{
                "rm -rf /",
                "dd if=/dev/zero",
                ":(){ :|:&amp; };:", // Fork bomb
                "mkfs",
                "fdisk",
                "parted",
                "format",
                "shutdown",
                "reboot",
                "halt",
                "poweroff",
                "init 0",
                "init 6",
                "telinit",
                "systemctl poweroff",
                "systemctl reboot",
                "systemctl halt",
        }

        // Convert command to lowercase for comparison
        lowerCommand := strings.ToLower(strings.TrimSpace(command))

        // Check against blacklisted commands
        for _, blacklisted := range blacklistedCommands </span><span class="cov0" title="0">{
                if strings.Contains(lowerCommand, strings.ToLower(blacklisted)) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Additional security checks
        <span class="cov0" title="0">if strings.Contains(lowerCommand, "&gt;/dev/") ||
                strings.Contains(lowerCommand, "rm -rf") ||
                strings.Contains(lowerCommand, "chmod 777") ||
                strings.Contains(lowerCommand, "chown root") ||
                strings.Contains(lowerCommand, "sudo su") ||
                strings.Contains(lowerCommand, "su -") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// executeCommand executes a system command with timeout and returns the result
func (h *HTTPServer) executeCommand(request CommandExecuteRequest) CommandExecuteResponse <span class="cov0" title="0">{
        startTime := time.Now()

        // Prepare command
        cmd := exec.Command("/bin/bash", "-c", request.Command)

        // Set working directory if specified
        if request.WorkingDirectory != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(request.WorkingDirectory); err == nil </span><span class="cov0" title="0">{
                        cmd.Dir = request.WorkingDirectory
                }</span>
        }

        // Set timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(request.Timeout)*time.Second)
        defer cancel()
        cmd = exec.CommandContext(ctx, "/bin/bash", "-c", request.Command)

        // Capture stdout and stderr
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Execute command
        err := cmd.Run()
        executionTime := time.Since(startTime)

        // Prepare response
        response := CommandExecuteResponse{
                Command:         request.Command,
                Stdout:          stdout.String(),
                Stderr:          stderr.String(),
                ExecutionTimeMs: executionTime.Milliseconds(),
                WorkingDir:      request.WorkingDirectory,
        }

        // Set exit code
        if err != nil </span><span class="cov0" title="0">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        response.ExitCode = exitError.ExitCode()
                }</span> else<span class="cov0" title="0"> {
                        response.ExitCode = -1
                }</span>
        } else<span class="cov0" title="0"> {
                response.ExitCode = 0
        }</span>

        <span class="cov0" title="0">return response</span>
}

// getAPCUPSData retrieves UPS data from apcupsd daemon
func (h *HTTPServer) getAPCUPSData() map[string]interface{} <span class="cov0" title="0">{
        // Execute apcaccess command to get UPS status
        cmd := exec.Command("apcaccess")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse apcaccess output
        <span class="cov0" title="0">upsData := map[string]interface{}{
                "status":         "unknown",
                "battery_charge": 0.0,
                "runtime":        0.0,
                "load_percent":   0.0,
                "input_voltage":  0.0,
                "output_voltage": 0.0,
                "model":          "unknown",
                "connected":      true,
                "ups_type":       "apc",
                "last_updated":   time.Now().UTC().Format(time.RFC3339),
        }

        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Split on colon and spaces
                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "STATUS":<span class="cov0" title="0">
                        upsData["status"] = strings.ToLower(value)</span>
                case "BCHARGE":<span class="cov0" title="0">
                        if charge, err := strconv.ParseFloat(strings.TrimSuffix(value, " Percent"), 64); err == nil </span><span class="cov0" title="0">{
                                upsData["battery_charge"] = charge
                        }</span>
                case "TIMELEFT":<span class="cov0" title="0">
                        if runtime, err := strconv.ParseFloat(strings.TrimSuffix(value, " Minutes"), 64); err == nil </span><span class="cov0" title="0">{
                                upsData["runtime"] = runtime
                        }</span>
                case "LOADPCT":<span class="cov0" title="0">
                        if load, err := strconv.ParseFloat(strings.TrimSuffix(value, " Percent"), 64); err == nil </span><span class="cov0" title="0">{
                                upsData["load_percent"] = load
                        }</span>
                case "LINEV":<span class="cov0" title="0">
                        if voltage, err := strconv.ParseFloat(strings.TrimSuffix(value, " Volts"), 64); err == nil </span><span class="cov0" title="0">{
                                upsData["input_voltage"] = voltage
                        }</span>
                case "OUTPUTV":<span class="cov0" title="0">
                        if voltage, err := strconv.ParseFloat(strings.TrimSuffix(value, " Volts"), 64); err == nil </span><span class="cov0" title="0">{
                                upsData["output_voltage"] = voltage
                        }</span>
                case "MODEL":<span class="cov0" title="0">
                        upsData["model"] = value</span>
                case "UPSNAME":<span class="cov0" title="0">
                        upsData["name"] = value</span>
                case "SERIALNO":<span class="cov0" title="0">
                        upsData["serial_number"] = value</span>
                case "NOMPOWER":<span class="cov0" title="0">
                        if power, err := strconv.ParseFloat(strings.TrimSuffix(value, " Watts"), 64); err == nil </span><span class="cov0" title="0">{
                                upsData["nominal_power"] = power
                        }</span>
                }
        }

        <span class="cov0" title="0">return upsData</span>
}

// getNUTUPSData retrieves UPS data from NUT (Network UPS Tools)
func (h *HTTPServer) getNUTUPSData() map[string]interface{} <span class="cov0" title="0">{
        // Execute upsc command to get UPS status
        cmd := exec.Command("upsc", "ups")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // Try with different UPS name
                cmd = exec.Command("upsc", "ups@localhost")
                output, err = cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Parse upsc output
        <span class="cov0" title="0">upsData := map[string]interface{}{
                "status":         "unknown",
                "battery_charge": 0.0,
                "runtime":        0.0,
                "load_percent":   0.0,
                "input_voltage":  0.0,
                "output_voltage": 0.0,
                "model":          "unknown",
                "connected":      true,
                "ups_type":       "nut",
                "last_updated":   time.Now().UTC().Format(time.RFC3339),
        }

        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Split on colon and spaces
                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "ups.status":<span class="cov0" title="0">
                        upsData["status"] = strings.ToLower(value)</span>
                case "battery.charge":<span class="cov0" title="0">
                        if charge, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                upsData["battery_charge"] = charge
                        }</span>
                case "battery.runtime":<span class="cov0" title="0">
                        if runtime, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                upsData["runtime"] = runtime / 60 // Convert seconds to minutes
                        }</span>
                case "ups.load":<span class="cov0" title="0">
                        if load, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                upsData["load_percent"] = load
                        }</span>
                case "input.voltage":<span class="cov0" title="0">
                        if voltage, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                upsData["input_voltage"] = voltage
                        }</span>
                case "output.voltage":<span class="cov0" title="0">
                        if voltage, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                upsData["output_voltage"] = voltage
                        }</span>
                case "ups.model":<span class="cov0" title="0">
                        upsData["model"] = value</span>
                case "ups.serial":<span class="cov0" title="0">
                        upsData["serial_number"] = value</span>
                }
        }

        <span class="cov0" title="0">return upsData</span>
}

// getIntelGPUData returns Intel GPU data in standard format
func (h *HTTPServer) getIntelGPUData() map[string]interface{} <span class="cov8" title="1">{
        if h.api.gpu == nil </span><span class="cov8" title="1">{
                return map[string]interface{}{
                        "usage":       0,
                        "temperature": 0,
                        "name":        "GPU monitoring not available",
                }
        }</span>

        <span class="cov0" title="0">gpuInfo, err := h.api.gpu.GetGPUInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Look for Intel GPU
        <span class="cov0" title="0">for _, gpu := range gpuInfo </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(gpu.Name), "intel") </span><span class="cov0" title="0">{
                        return map[string]interface{}{
                                "usage":        gpu.UtilizationGPU,
                                "temperature":  gpu.Temperature,
                                "name":         gpu.Name,
                                "memory_used":  gpu.MemoryUsed,
                                "memory_total": gpu.MemoryTotal,
                        }
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "usage":       0,
                "temperature": 0,
                "name":        "No Intel GPU detected",
        }</span>
}

// getFilesystemData returns filesystem usage data in standard format
func (h *HTTPServer) getFilesystemData() map[string]interface{} <span class="cov8" title="1">{
        result := make(map[string]interface{})

        // Docker vDisk usage
        if dockerVDisk := h.getDockerVDiskUsage(); dockerVDisk != nil </span><span class="cov8" title="1">{
                result["docker_vdisk"] = dockerVDisk
        }</span>

        // Log filesystem usage
        <span class="cov8" title="1">if logFS := h.getLogFilesystemUsage(); logFS != nil </span><span class="cov8" title="1">{
                result["log_filesystem"] = logFS
        }</span>

        // Boot usage
        <span class="cov8" title="1">if bootUsage := h.getBootUsage(); bootUsage != nil </span><span class="cov8" title="1">{
                result["boot_usage"] = bootUsage
        }</span>

        <span class="cov8" title="1">return result</span>
}

// getDockerVDiskUsage returns Docker vDisk usage information
func (h *HTTPServer) getDockerVDiskUsage() map[string]interface{} <span class="cov8" title="1">{
        // Check common Docker vDisk locations
        dockerPaths := []string{"/var/lib/docker", "/mnt/user/system/docker/docker.img"}

        for _, path := range dockerPaths </span><span class="cov8" title="1">{
                if usage := h.getPathUsage(path); usage != nil </span><span class="cov8" title="1">{
                        return usage
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "total": 0,
                "used":  0,
                "free":  0,
        }</span>
}

// getLogFilesystemUsage returns log filesystem usage information
func (h *HTTPServer) getLogFilesystemUsage() map[string]interface{} <span class="cov8" title="1">{
        return h.getPathUsage("/var/log")
}</span>

// getBootUsage returns boot filesystem usage information
func (h *HTTPServer) getBootUsage() map[string]interface{} <span class="cov8" title="1">{
        return h.getPathUsage("/boot")
}</span>

// getPathUsage returns filesystem usage for a given path
func (h *HTTPServer) getPathUsage(path string) map[string]interface{} <span class="cov8" title="1">{
        var stat syscall.Statfs_t
        if err := syscall.Statfs(path, &amp;stat); err != nil </span><span class="cov8" title="1">{
                return map[string]interface{}{
                        "total": 0,
                        "used":  0,
                        "free":  0,
                }
        }</span>

        <span class="cov8" title="1">total := stat.Blocks * uint64(stat.Bsize)
        free := stat.Bavail * uint64(stat.Bsize)
        used := total - free

        return map[string]interface{}{
                "total": total,
                "used":  used,
                "free":  free,
        }</span>
}

// getDockerData returns Docker container data in standard format
func (h *HTTPServer) getDockerData() []map[string]interface{} <span class="cov0" title="0">{
        containers, err := h.api.docker.ListContainers(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]map[string]interface{}, 0)
        for _, container := range containers </span><span class="cov0" title="0">{
                // Get container stats for CPU and memory usage
                stats, err := h.api.docker.GetContainerStats(container.ID)
                var cpuUsage float64
                var memoryUsage uint64

                if err == nil &amp;&amp; stats != nil </span><span class="cov0" title="0">{
                        cpuUsage = stats.CPUPercent
                        memoryUsage = stats.MemUsage
                }</span>

                <span class="cov0" title="0">containerData := map[string]interface{}{
                        "name":         container.Name,
                        "state":        container.State,
                        "status":       container.Status,
                        "cpu_usage":    cpuUsage,
                        "memory_usage": memoryUsage,
                        "image":        container.Image,
                        "created":      container.Created,
                }

                result = append(result, containerData)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// getVMData returns VM data in standard format
func (h *HTTPServer) getVMData() []map[string]interface{} <span class="cov0" title="0">{
        vms, err := h.api.vm.ListVMs(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]map[string]interface{}, 0)
        for _, vm := range vms </span><span class="cov0" title="0">{
                // Get VM stats for CPU and memory usage
                stats, err := h.api.vm.GetVMStats(vm.Name)
                var cpuUsage float64
                var memoryUsage uint64

                if err == nil &amp;&amp; stats != nil </span><span class="cov0" title="0">{
                        cpuUsage = stats.CPUUsage
                        memoryUsage = stats.MemoryUsage
                }</span>

                <span class="cov0" title="0">vmData := map[string]interface{}{
                        "name":         vm.Name,
                        "state":        vm.State,
                        "cpu_usage":    cpuUsage,
                        "memory_usage": memoryUsage,
                        "uuid":         vm.UUID,
                }

                result = append(result, vmData)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// handleGPU handles GET /api/v1/gpu
func (h *HTTPServer) handleGPU(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">gpuInfo, err := h.api.gpu.GetGPUInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get GPU info: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, gpuInfo)</span>
}

// handleDockerContainers handles GET /api/v1/docker/containers
func (h *HTTPServer) handleDockerContainers(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">all := r.URL.Query().Get("all") == "true"
        params := h.parsePaginationParams(r)
        usePagination := r.URL.Query().Get("page") != "" || r.URL.Query().Get("limit") != ""

        containers, err := h.api.docker.ListContainers(all)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to list containers: %v", err))
                return
        }</span>

        <span class="cov8" title="1">if usePagination </span><span class="cov0" title="0">{
                // Convert containers to interface{} slice for pagination
                containerList := make([]interface{}, len(containers))
                for i, container := range containers </span><span class="cov0" title="0">{
                        containerList[i] = container
                }</span>

                <span class="cov0" title="0">paginatedContainers, total := h.paginateSlice(containerList, params)
                h.writePaginatedResponse(w, http.StatusOK, paginatedContainers, total, params)</span>
        } else<span class="cov8" title="1"> {
                // Return original format for backward compatibility
                h.writeJSON(w, http.StatusOK, containers)
        }</span>
}

// handleDockerNetworks handles GET /api/v1/docker/networks
func (h *HTTPServer) handleDockerNetworks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">networks, err := h.api.docker.ListNetworks()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to list networks: %v", err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, networks)</span>
}

// handleDockerImages handles GET /api/v1/docker/images
func (h *HTTPServer) handleDockerImages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">images, err := h.api.docker.ListImages()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to list images: %v", err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, images)</span>
}

// handleDockerInfo handles GET /api/v1/docker/info
func (h *HTTPServer) handleDockerInfo(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">info, err := h.api.docker.GetDockerInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get Docker info: %v", err))
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, info)</span>
}

// handleVMList handles GET /api/v1/vm/list
func (h *HTTPServer) handleVMList(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">all := r.URL.Query().Get("all") == "true"
        vms, err := h.api.vm.ListVMs(all)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to list VMs: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, vms)</span>
}

// handleVM handles VM operations
func (h *HTTPServer) handleVM(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Extract VM name from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/vms/")
        parts := strings.Split(path, "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "VM name required")
                return
        }</span>

        <span class="cov8" title="1">vmName := parts[0]
        action := ""
        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                action = parts[1]
        }</span>

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if action == "stats" </span><span class="cov0" title="0">{
                        stats, err := h.api.vm.GetVMStats(vmName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get VM stats: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, stats)</span>
                } else<span class="cov8" title="1"> if action == "console" </span><span class="cov0" title="0">{
                        console, err := h.api.vm.GetVMConsole(vmName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get VM console: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"console": console})</span>
                } else<span class="cov8" title="1"> {
                        vm, err := h.api.vm.GetVM(vmName)
                        if err != nil </span><span class="cov8" title="1">{
                                h.writeError(w, http.StatusNotFound, fmt.Sprintf("VM not found: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, vm)</span>
                }

        case http.MethodPost:<span class="cov8" title="1">
                switch action </span>{
                case "start":<span class="cov8" title="1">
                        err := h.api.vm.StartVM(vmName)
                        if err != nil </span><span class="cov8" title="1">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to start VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM started"})</span>

                case "stop":<span class="cov8" title="1">
                        force := r.URL.Query().Get("force") == "true"
                        err := h.api.vm.StopVM(vmName, force)
                        if err != nil </span><span class="cov8" title="1">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to stop VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM stopped"})</span>

                case "restart":<span class="cov8" title="1">
                        err := h.api.vm.RestartVM(vmName)
                        if err != nil </span><span class="cov8" title="1">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to restart VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM restarted"})</span>

                case "pause":<span class="cov8" title="1">
                        err := h.api.vm.PauseVM(vmName)
                        if err != nil </span><span class="cov8" title="1">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to pause VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM paused"})</span>

                case "resume":<span class="cov8" title="1">
                        err := h.api.vm.ResumeVM(vmName)
                        if err != nil </span><span class="cov8" title="1">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to resume VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM resumed"})</span>

                case "hibernate":<span class="cov0" title="0">
                        err := h.api.vm.HibernateVM(vmName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to hibernate VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM hibernated"})</span>

                case "restore":<span class="cov0" title="0">
                        err := h.api.vm.RestoreVM(vmName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to restore VM: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM restored"})</span>

                case "autostart":<span class="cov0" title="0">
                        autostart := r.URL.Query().Get("enable") == "true"
                        err := h.api.vm.SetVMAutostart(vmName, autostart)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to set autostart: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "VM autostart updated"})</span>

                default:<span class="cov8" title="1">
                        h.writeError(w, http.StatusBadRequest, "Invalid action")</span>
                }

        default:<span class="cov8" title="1">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// handleDiagnosticsHealth handles GET /api/v1/diagnostics/health
func (h *HTTPServer) handleDiagnosticsHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">health, err := h.api.diagnostics.RunHealthChecks()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to run health checks: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, health)</span>
}

// handleDiagnosticsInfo handles GET /api/v1/diagnostics/info
func (h *HTTPServer) handleDiagnosticsInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">info, err := h.api.diagnostics.GetDiagnosticInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get diagnostic info: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, info)</span>
}

// handleDiagnosticsRepair handles GET/POST /api/v1/diagnostics/repair
func (h *HTTPServer) handleDiagnosticsRepair(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                repairs := h.api.diagnostics.GetAvailableRepairs()
                h.writeJSON(w, http.StatusOK, repairs)</span>

        case http.MethodPost:<span class="cov0" title="0">
                repairName := r.URL.Query().Get("action")
                if repairName == "" </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Repair action required")
                        return
                }</span>

                <span class="cov0" title="0">err := h.api.diagnostics.ExecuteRepair(repairName)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to execute repair: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "Repair executed successfully"})</span>

        default:<span class="cov0" title="0">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// Array Control Handlers

// handleArrayStart handles POST /api/v1/array/start
func (h *HTTPServer) handleArrayStart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var req ArrayStartRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Check current array state
        <span class="cov8" title="1">arrayInfo, err := h.api.storage.GetArrayInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get array state: %v", err))
                return
        }</span>

        <span class="cov8" title="1">if arrayInfo.State == "started" </span><span class="cov0" title="0">{
                response := ArrayOperationResponse{
                        Success: false,
                        Message: "Array is already started",
                }
                h.writeJSON(w, http.StatusConflict, response)
                return
        }</span>

        // Start the array
        <span class="cov8" title="1">err = h.api.storage.StartArray(req.MaintenanceMode, req.CheckFilesystem)
        if err != nil </span><span class="cov8" title="1">{
                response := ArrayOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to start array: %v", err),
                }
                h.writeJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := ArrayOperationResponse{
                Success:       true,
                Message:       "Array start initiated",
                OperationID:   fmt.Sprintf("array_start_%d", time.Now().Unix()),
                EstimatedTime: 30, // seconds
        }
        h.writeJSON(w, http.StatusOK, response)</span>
}

// handleArrayStop handles POST /api/v1/array/stop
func (h *HTTPServer) handleArrayStop(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var req ArrayStopRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Check current array state
        <span class="cov8" title="1">arrayInfo, err := h.api.storage.GetArrayInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get array state: %v", err))
                return
        }</span>

        <span class="cov8" title="1">if arrayInfo.State == "stopped" </span><span class="cov8" title="1">{
                response := ArrayOperationResponse{
                        Success: false,
                        Message: "Array is already stopped",
                }
                h.writeJSON(w, http.StatusConflict, response)
                return
        }</span>

        // Stop the array with enhanced orchestration
        <span class="cov0" title="0">err = h.api.storage.StopArray(req.Force, req.UnmountShares, req.StopContainers, req.StopVMs)
        if err != nil </span><span class="cov0" title="0">{
                response := ArrayOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to stop array: %v", err),
                }
                h.writeJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := ArrayOperationResponse{
                Success:       true,
                Message:       "Array stop initiated",
                OperationID:   fmt.Sprintf("array_stop_%d", time.Now().Unix()),
                EstimatedTime: 15, // seconds
        }
        h.writeJSON(w, http.StatusOK, response)</span>
}

// handleArrayParityCheck handles GET/POST/DELETE /api/v1/array/parity-check
func (h *HTTPServer) handleArrayParityCheck(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                // Get parity check status
                status, err := h.api.storage.GetParityCheckStatus()
                if err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get parity check status: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, status)</span>

        case http.MethodPost:<span class="cov0" title="0">
                // Start parity check
                var req ParityCheckRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                        return
                }</span>

                // Validate request
                <span class="cov0" title="0">if req.Type != "check" &amp;&amp; req.Type != "correct" </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid parity check type. Must be 'check' or 'correct'")
                        return
                }</span>

                <span class="cov0" title="0">if req.Priority != "low" &amp;&amp; req.Priority != "normal" &amp;&amp; req.Priority != "high" </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid priority. Must be 'low', 'normal', or 'high'")
                        return
                }</span>

                <span class="cov0" title="0">err := h.api.storage.StartParityCheck(req.Type, req.Priority)
                if err != nil </span><span class="cov0" title="0">{
                        response := ArrayOperationResponse{
                                Success: false,
                                Message: fmt.Sprintf("Failed to start parity check: %v", err),
                        }
                        h.writeJSON(w, http.StatusInternalServerError, response)
                        return
                }</span>

                <span class="cov0" title="0">response := ArrayOperationResponse{
                        Success:       true,
                        Message:       fmt.Sprintf("Parity %s started", req.Type),
                        OperationID:   fmt.Sprintf("parity_%s_%d", req.Type, time.Now().Unix()),
                        EstimatedTime: 3600, // 1 hour estimate
                }
                h.writeJSON(w, http.StatusOK, response)</span>

        case http.MethodDelete:<span class="cov0" title="0">
                // Cancel parity check
                err := h.api.storage.CancelParityCheck()
                if err != nil </span><span class="cov0" title="0">{
                        response := ArrayOperationResponse{
                                Success: false,
                                Message: fmt.Sprintf("Failed to cancel parity check: %v", err),
                        }
                        h.writeJSON(w, http.StatusInternalServerError, response)
                        return
                }</span>

                <span class="cov0" title="0">response := ArrayOperationResponse{
                        Success: true,
                        Message: "Parity check cancelled",
                }
                h.writeJSON(w, http.StatusOK, response)</span>

        default:<span class="cov0" title="0">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// handleArrayDiskAdd handles POST /api/v1/array/disk/add
func (h *HTTPServer) handleArrayDiskAdd(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req DiskAddRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if req.Device == "" || req.Position == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Device and position are required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.storage.AddDisk(req.Device, req.Position)
        if err != nil </span><span class="cov0" title="0">{
                response := ArrayOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to add disk: %v", err),
                }
                h.writeJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := ArrayOperationResponse{
                Success:       true,
                Message:       fmt.Sprintf("Disk %s added to position %s", req.Device, req.Position),
                OperationID:   fmt.Sprintf("disk_add_%d", time.Now().Unix()),
                EstimatedTime: 10, // seconds
        }
        h.writeJSON(w, http.StatusOK, response)</span>
}

// handleArrayDiskRemove handles POST /api/v1/array/disk/remove
func (h *HTTPServer) handleArrayDiskRemove(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req DiskRemoveRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if req.Position == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Position is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.storage.RemoveDisk(req.Position)
        if err != nil </span><span class="cov0" title="0">{
                response := ArrayOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to remove disk: %v", err),
                }
                h.writeJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := ArrayOperationResponse{
                Success:       true,
                Message:       fmt.Sprintf("Disk removed from position %s", req.Position),
                OperationID:   fmt.Sprintf("disk_remove_%d", time.Now().Unix()),
                EstimatedTime: 10, // seconds
        }
        h.writeJSON(w, http.StatusOK, response)</span>
}

// handleSystemSleep handles POST /api/v1/system/sleep
func (h *HTTPServer) handleSystemSleep(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req SystemSleepRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate sleep type
        <span class="cov0" title="0">if req.Type != "suspend" &amp;&amp; req.Type != "hibernate" &amp;&amp; req.Type != "hybrid" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid sleep type. Must be 'suspend', 'hibernate', or 'hybrid'")
                return
        }</span>

        // Execute sleep
        <span class="cov0" title="0">err := h.executeSystemSleep(req.Type)
        if err != nil </span><span class="cov0" title="0">{
                response := PowerOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to %s system: %v", req.Type, err),
                }
                h.writeJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := PowerOperationResponse{
                Success:     true,
                Message:     fmt.Sprintf("System %s initiated", req.Type),
                OperationID: fmt.Sprintf("%s_%d", req.Type, time.Now().Unix()),
        }
        h.writeJSON(w, http.StatusOK, response)</span>
}

// handleSystemWake handles POST /api/v1/system/wake
func (h *HTTPServer) handleSystemWake(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req SystemWakeRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate MAC address
        <span class="cov0" title="0">if req.TargetMAC == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Target MAC address is required")
                return
        }</span>

        // Set defaults
        <span class="cov0" title="0">if req.BroadcastIP == "" </span><span class="cov0" title="0">{
                req.BroadcastIP = "255.255.255.255"
        }</span>
        <span class="cov0" title="0">if req.Port == 0 </span><span class="cov0" title="0">{
                req.Port = 9
        }</span>
        <span class="cov0" title="0">if req.RepeatCount == 0 </span><span class="cov0" title="0">{
                req.RepeatCount = 3
        }</span>

        // Execute Wake-on-LAN
        <span class="cov0" title="0">err := h.executeWakeOnLAN(req.TargetMAC, req.BroadcastIP, req.Port, req.RepeatCount)
        if err != nil </span><span class="cov0" title="0">{
                response := PowerOperationResponse{
                        Success: false,
                        Message: fmt.Sprintf("Failed to send Wake-on-LAN packet: %v", err),
                }
                h.writeJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">response := PowerOperationResponse{
                Success:     true,
                Message:     fmt.Sprintf("Wake-on-LAN packet sent to %s", req.TargetMAC),
                OperationID: fmt.Sprintf("wake_%d", time.Now().Unix()),
        }
        h.writeJSON(w, http.StatusOK, response)</span>
}

// Power Management Execution Functions

// executeSystemShutdown executes a system shutdown with the specified parameters
func (h *HTTPServer) executeSystemShutdown(delaySeconds int, message string, force bool) error <span class="cov0" title="0">{
        // Build shutdown command
        cmd := "shutdown"

        // Add delay
        if delaySeconds &gt; 0 </span><span class="cov0" title="0">{
                cmd += fmt.Sprintf(" +%d", delaySeconds/60) // Convert to minutes for shutdown command
        }</span> else<span class="cov0" title="0"> {
                cmd += " now"
        }</span>

        // Add message if provided
        <span class="cov0" title="0">if message != "" </span><span class="cov0" title="0">{
                cmd += fmt.Sprintf(" \"%s\"", message)
        }</span>

        // Add force flag if needed
        <span class="cov0" title="0">if force </span><span class="cov0" title="0">{
                cmd = "shutdown -f" + cmd[8:] // Replace "shutdown" with "shutdown -f"
        }</span>

        // Execute the command in background
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if delaySeconds &gt; 0 &amp;&amp; delaySeconds &lt; 60 </span><span class="cov0" title="0">{
                        // For delays less than 1 minute, use sleep + immediate shutdown
                        time.Sleep(time.Duration(delaySeconds) * time.Second)
                        cmd = "shutdown now"
                        if message != "" </span><span class="cov0" title="0">{
                                cmd += fmt.Sprintf(" \"%s\"", message)
                        }</span>
                }

                // Execute shutdown command
                <span class="cov0" title="0">output := lib.GetCmdOutput("sh", "-c", cmd)
                for _, line := range output </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(line), "error") </span><span class="cov0" title="0">{
                                logger.Red("Shutdown error: %s", line)
                        }</span>
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// executeSystemReboot executes a system reboot with the specified parameters
func (h *HTTPServer) executeSystemReboot(delaySeconds int, message string, force bool) error <span class="cov0" title="0">{
        // Build reboot command
        cmd := "reboot"

        // Add force flag if needed
        if force </span><span class="cov0" title="0">{
                cmd = "reboot -f"
        }</span>

        // Execute the command in background with delay
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if delaySeconds &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(delaySeconds) * time.Second)
                }</span>

                // Send wall message if provided
                <span class="cov0" title="0">if message != "" </span><span class="cov0" title="0">{
                        wallCmd := fmt.Sprintf("wall \"%s - System rebooting now\"", message)
                        lib.GetCmdOutput("sh", "-c", wallCmd)
                        time.Sleep(2 * time.Second) // Give time for message to be displayed
                }</span>

                // Execute reboot command
                <span class="cov0" title="0">output := lib.GetCmdOutput("sh", "-c", cmd)
                for _, line := range output </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(line), "error") </span><span class="cov0" title="0">{
                                logger.Red("Reboot error: %s", line)
                        }</span>
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// executeSystemSleep executes a system sleep/suspend operation
func (h *HTTPServer) executeSystemSleep(sleepType string) error <span class="cov0" title="0">{
        var cmd string

        switch sleepType </span>{
        case "suspend":<span class="cov0" title="0">
                cmd = "systemctl suspend"</span>
        case "hibernate":<span class="cov0" title="0">
                cmd = "systemctl hibernate"</span>
        case "hybrid":<span class="cov0" title="0">
                cmd = "systemctl hybrid-sleep"</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid sleep type: %s", sleepType)</span>
        }

        // Execute the command in background
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                output := lib.GetCmdOutput("sh", "-c", cmd)
                for _, line := range output </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(line), "error") </span><span class="cov0" title="0">{
                                logger.Red("Sleep error: %s", line)
                        }</span>
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// executeWakeOnLAN sends a Wake-on-LAN packet to the specified MAC address
func (h *HTTPServer) executeWakeOnLAN(targetMAC, broadcastIP string, port, repeatCount int) error <span class="cov0" title="0">{
        // Validate and parse MAC address
        macBytes, err := parseMACAddress(targetMAC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MAC address: %v", err)
        }</span>

        // Create Wake-on-LAN packet
        <span class="cov0" title="0">packet := createWOLPacket(macBytes)

        // Send packets
        for i := 0; i &lt; repeatCount; i++ </span><span class="cov0" title="0">{
                err := sendWOLPacket(packet, broadcastIP, port)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send WOL packet %d: %v", i+1, err)
                }</span>

                // Small delay between packets
                <span class="cov0" title="0">if i &lt; repeatCount-1 </span><span class="cov0" title="0">{
                        time.Sleep(100 * time.Millisecond)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// parseMACAddress parses a MAC address string into bytes
func parseMACAddress(mac string) ([]byte, error) <span class="cov0" title="0">{
        // Remove common separators
        mac = strings.ReplaceAll(mac, ":", "")
        mac = strings.ReplaceAll(mac, "-", "")
        mac = strings.ReplaceAll(mac, ".", "")

        // Validate length
        if len(mac) != 12 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MAC address must be 12 hex characters")
        }</span>

        // Parse hex string
        <span class="cov0" title="0">macBytes := make([]byte, 6)
        for i := 0; i &lt; 6; i++ </span><span class="cov0" title="0">{
                b, err := strconv.ParseUint(mac[i*2:i*2+2], 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid hex in MAC address: %v", err)
                }</span>
                <span class="cov0" title="0">macBytes[i] = byte(b)</span>
        }

        <span class="cov0" title="0">return macBytes, nil</span>
}

// createWOLPacket creates a Wake-on-LAN magic packet
func createWOLPacket(macBytes []byte) []byte <span class="cov0" title="0">{
        // WOL packet: 6 bytes of 0xFF followed by 16 repetitions of the MAC address
        packet := make([]byte, 102) // 6 + (6 * 16) = 102 bytes

        // Fill first 6 bytes with 0xFF
        for i := 0; i &lt; 6; i++ </span><span class="cov0" title="0">{
                packet[i] = 0xFF
        }</span>

        // Repeat MAC address 16 times
        <span class="cov0" title="0">for i := 0; i &lt; 16; i++ </span><span class="cov0" title="0">{
                copy(packet[6+i*6:6+(i+1)*6], macBytes)
        }</span>

        <span class="cov0" title="0">return packet</span>
}

// sendWOLPacket sends a Wake-on-LAN packet via UDP
func sendWOLPacket(packet []byte, broadcastIP string, port int) error <span class="cov0" title="0">{
        // Create UDP address
        addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf("%s:%d", broadcastIP, port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve UDP address: %v", err)
        }</span>

        // Create UDP connection
        <span class="cov0" title="0">conn, err := net.DialUDP("udp", nil, addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create UDP connection: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Send packet
        _, err = conn.Write(packet)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send packet: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// User Script Management Handlers

// handleScripts handles GET /api/v1/scripts
// NOTE: This handler is currently unused (no route registration) and references removed methods
// TODO: Remove or refactor if needed in the future
/*
func (h *HTTPServer) handleScripts(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }

        scripts, err := h.getUserScripts()
        if err != nil {
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get user scripts: %v", err))
                return
        }

        response := ScriptListResponse{Scripts: scripts}
        h.writeJSON(w, http.StatusOK, response)
}
*/

// handleScript handles script operations
func (h *HTTPServer) handleScript(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract script name from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/scripts/")
        parts := strings.Split(path, "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Script name required")
                return
        }</span>

        <span class="cov0" title="0">scriptName := parts[0]
        action := ""
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                action = parts[1]
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                switch action </span>{
                case "status":<span class="cov0" title="0">
                        status, err := h.getScriptStatus(scriptName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get script status: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, status)</span>

                case "logs":<span class="cov0" title="0">
                        logs, err := h.getScriptLogs(scriptName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get script logs: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">response := ScriptLogsResponse{Name: scriptName, Logs: logs}
                        h.writeJSON(w, http.StatusOK, response)</span>

                default:<span class="cov0" title="0">
                        h.writeError(w, http.StatusBadRequest, "Invalid action. Use 'status' or 'logs'")</span>
                }

        case http.MethodPost:<span class="cov0" title="0">
                switch action </span>{
                case "execute":<span class="cov0" title="0">
                        var req ScriptExecuteRequest
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                                return
                        }</span>

                        <span class="cov0" title="0">response, err := h.executeScript(scriptName, req)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to execute script: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, response)</span>

                case "stop":<span class="cov0" title="0">
                        err := h.stopScript(scriptName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to stop script: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "Script stopped successfully"})</span>

                default:<span class="cov0" title="0">
                        h.writeError(w, http.StatusBadRequest, "Invalid action. Use 'execute' or 'stop'")</span>
                }

        default:<span class="cov0" title="0">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// Share Management Handlers

// handleShares handles GET /api/v1/shares
func (h *HTTPServer) handleShares(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                shares, err := h.getShares()
                if err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get shares: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">response := ShareListResponse{Shares: shares}
                h.writeJSON(w, http.StatusOK, response)
                return</span>
        }

        <span class="cov0" title="0">if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                var req ShareCreateRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                        return
                }</span>

                <span class="cov0" title="0">if err := h.validateShareCreateRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, fmt.Sprintf("Invalid request: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">if err := h.createShare(&amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to create share: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">response := ShareOperationResponse{
                        Success:   true,
                        Message:   fmt.Sprintf("Share '%s' created successfully", req.Name),
                        ShareName: req.Name,
                }
                h.writeJSON(w, http.StatusCreated, response)
                return</span>
        }

        <span class="cov0" title="0">h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
}

// handleShare handles share operations
func (h *HTTPServer) handleShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract share name from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/shares/")
        parts := strings.Split(path, "/")
        if len(parts) == 0 || parts[0] == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Share name required")
                return
        }</span>

        <span class="cov0" title="0">shareName := parts[0]
        action := ""
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                action = parts[1]
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                if action == "usage" </span><span class="cov0" title="0">{
                        usage, err := h.getShareUsage(shareName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get share usage: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, usage)</span>
                } else<span class="cov0" title="0"> if action == "" </span><span class="cov0" title="0">{
                        share, err := h.getShare(shareName)
                        if err != nil </span><span class="cov0" title="0">{
                                h.writeError(w, http.StatusNotFound, fmt.Sprintf("Share not found: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, share)</span>
                } else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusBadRequest, "Invalid action. Use 'usage' or omit for share details")
                }</span>

        case http.MethodPut:<span class="cov0" title="0">
                if action != "" </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Action not allowed for PUT requests")
                        return
                }</span>

                <span class="cov0" title="0">var req ShareUpdateRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                        return
                }</span>

                <span class="cov0" title="0">if err := h.validateShareUpdateRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, fmt.Sprintf("Invalid request: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">if err := h.updateShare(shareName, &amp;req); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to update share: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">response := ShareOperationResponse{
                        Success:   true,
                        Message:   fmt.Sprintf("Share '%s' updated successfully", shareName),
                        ShareName: shareName,
                }
                h.writeJSON(w, http.StatusOK, response)</span>

        case http.MethodDelete:<span class="cov0" title="0">
                if action != "" </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusBadRequest, "Action not allowed for DELETE requests")
                        return
                }</span>

                <span class="cov0" title="0">if err := h.deleteShare(shareName); err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to delete share: %v", err))
                        return
                }</span>

                <span class="cov0" title="0">response := ShareOperationResponse{
                        Success:   true,
                        Message:   fmt.Sprintf("Share '%s' deleted successfully", shareName),
                        ShareName: shareName,
                }
                h.writeJSON(w, http.StatusOK, response)</span>

        default:<span class="cov0" title="0">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// getScriptDescription reads the script description from the description file
func (h *HTTPServer) getScriptDescription(scriptName string) string <span class="cov0" title="0">{
        descPath := fmt.Sprintf("/boot/config/plugins/user.scripts/scripts/%s/description", scriptName)
        content, err := os.ReadFile(descPath)
        if err != nil </span><span class="cov0" title="0">{
                return "No description available"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(content))</span>
}

// getScriptCurrentStatus returns the current status of a script
func (h *HTTPServer) getScriptCurrentStatus(scriptName string) string <span class="cov0" title="0">{
        // Check if script is currently running by looking for PID file
        pidPath := fmt.Sprintf("/tmp/user.scripts.%s.pid", scriptName)
        if pidData, err := os.ReadFile(pidPath); err == nil </span><span class="cov0" title="0">{
                pidStr := strings.TrimSpace(string(pidData))
                if pid, err := strconv.Atoi(pidStr); err == nil </span><span class="cov0" title="0">{
                        // Check if process is still running
                        if h.isProcessRunning(pid) </span><span class="cov0" title="0">{
                                return "running"
                        }</span>
                }
        }

        <span class="cov0" title="0">return "idle"</span>
}

// getScriptLastRun returns the last run time and result of a script
func (h *HTTPServer) getScriptLastRun(scriptName string) (string, string) <span class="cov0" title="0">{
        // Check for log file to determine last run
        logPath := fmt.Sprintf("/tmp/user.scripts/tmpScripts/%s.log", scriptName)
        if stat, err := os.Stat(logPath); err == nil </span><span class="cov0" title="0">{
                lastRun := stat.ModTime().Format(time.RFC3339)

                // Try to determine result from log content
                if content, err := os.ReadFile(logPath); err == nil </span><span class="cov0" title="0">{
                        logContent := string(content)
                        if strings.Contains(logContent, "error") || strings.Contains(logContent, "failed") </span><span class="cov0" title="0">{
                                return lastRun, "failed"
                        }</span>
                        <span class="cov0" title="0">return lastRun, "success"</span>
                }

                <span class="cov0" title="0">return lastRun, "unknown"</span>
        }

        <span class="cov0" title="0">return "", "unknown"</span>
}

// isProcessRunning checks if a process with the given PID is still running
func (h *HTTPServer) isProcessRunning(pid int) bool <span class="cov0" title="0">{
        process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // On Unix systems, sending signal 0 checks if process exists
        <span class="cov0" title="0">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

// getScriptStatus returns detailed status information for a script
func (h *HTTPServer) getScriptStatus(scriptName string) (*ScriptStatusResponse, error) <span class="cov0" title="0">{
        status := &amp;ScriptStatusResponse{
                Name:   scriptName,
                Status: "idle",
        }

        // Check if script is currently running
        pidPath := fmt.Sprintf("/tmp/user.scripts.%s.pid", scriptName)
        if pidData, err := os.ReadFile(pidPath); err == nil </span><span class="cov0" title="0">{
                pidStr := strings.TrimSpace(string(pidData))
                if pid, err := strconv.Atoi(pidStr); err == nil </span><span class="cov0" title="0">{
                        status.PID = pid
                        if h.isProcessRunning(pid) </span><span class="cov0" title="0">{
                                status.Status = "running"

                                // Try to get start time from process
                                if startTime, err := h.getProcessStartTime(pid); err == nil </span><span class="cov0" title="0">{
                                        status.StartTime = startTime.Format(time.RFC3339)
                                        status.Duration = time.Since(startTime).String()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Process not running, check for exit code
                                status.Status = "completed"
                                if exitCode, err := h.getScriptExitCode(scriptName); err == nil </span><span class="cov0" title="0">{
                                        status.ExitCode = exitCode
                                        if exitCode != 0 </span><span class="cov0" title="0">{
                                                status.Status = "failed"
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return status, nil</span>
}

// getScriptLogs returns the log output for a script
func (h *HTTPServer) getScriptLogs(scriptName string) ([]string, error) <span class="cov0" title="0">{
        logPath := fmt.Sprintf("/tmp/user.scripts/tmpScripts/%s.log", scriptName)

        content, err := os.ReadFile(logPath)
        if err != nil </span><span class="cov0" title="0">{
                // Return empty logs if file doesn't exist
                return []string{}, nil
        }</span>

        // Split content into lines
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")

        // Remove empty lines at the end
        for len(lines) &gt; 0 &amp;&amp; strings.TrimSpace(lines[len(lines)-1]) == "" </span><span class="cov0" title="0">{
                lines = lines[:len(lines)-1]
        }</span>

        <span class="cov0" title="0">return lines, nil</span>
}

// executeScript executes a user script with the given parameters
func (h *HTTPServer) executeScript(scriptName string, req ScriptExecuteRequest) (*ScriptExecuteResponse, error) <span class="cov0" title="0">{
        // Validate script exists
        scriptPath := fmt.Sprintf("/boot/config/plugins/user.scripts/scripts/%s/script", scriptName)
        if _, err := os.Stat(scriptPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        // Check if script is already running
        <span class="cov0" title="0">if h.getScriptCurrentStatus(scriptName) == "running" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("script '%s' is already running", scriptName)
        }</span>

        // Build command arguments
        <span class="cov0" title="0">args := []string{scriptPath}
        args = append(args, req.Arguments...)

        // Create execution ID
        executionID := fmt.Sprintf("%s_%d", scriptName, time.Now().Unix())

        // Execute script
        if req.Background </span><span class="cov0" title="0">{
                // Execute in background
                cmd := exec.Command("/bin/bash", args...)

                // Set up logging
                logPath := fmt.Sprintf("/tmp/user.scripts/tmpScripts/%s.log", scriptName)
                logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create log file: %v", err)
                }</span>

                <span class="cov0" title="0">cmd.Stdout = logFile
                cmd.Stderr = logFile

                // Start the process
                if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                        logFile.Close()
                        return nil, fmt.Errorf("failed to start script: %v", err)
                }</span>

                // Save PID
                <span class="cov0" title="0">pidPath := fmt.Sprintf("/tmp/user.scripts.%s.pid", scriptName)
                pidFile, err := os.Create(pidPath)
                if err != nil </span><span class="cov0" title="0">{
                        logFile.Close()
                        return nil, fmt.Errorf("failed to create PID file: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(pidFile, "%d", cmd.Process.Pid)
                pidFile.Close()

                // Monitor process completion in background
                go func() </span><span class="cov0" title="0">{
                        defer logFile.Close()
                        cmd.Wait()
                        // Remove PID file when process completes
                        os.Remove(pidPath)
                }</span>()

                <span class="cov0" title="0">return &amp;ScriptExecuteResponse{
                        Success:     true,
                        Message:     fmt.Sprintf("Script '%s' started successfully", scriptName),
                        ExecutionID: executionID,
                        PID:         cmd.Process.Pid,
                }, nil</span>
        } else<span class="cov0" title="0"> {
                // Execute synchronously
                cmd := exec.Command("/bin/bash", args...)
                output, err := cmd.CombinedOutput()

                // Save output to log file
                logPath := fmt.Sprintf("/tmp/user.scripts/tmpScripts/%s.log", scriptName)
                os.WriteFile(logPath, output, 0644)

                if err != nil </span><span class="cov0" title="0">{
                        return &amp;ScriptExecuteResponse{
                                Success:     false,
                                Message:     fmt.Sprintf("Script '%s' failed: %v", scriptName, err),
                                ExecutionID: executionID,
                        }, nil
                }</span>

                <span class="cov0" title="0">return &amp;ScriptExecuteResponse{
                        Success:     true,
                        Message:     fmt.Sprintf("Script '%s' completed successfully", scriptName),
                        ExecutionID: executionID,
                }, nil</span>
        }
}

// stopScript stops a running user script
func (h *HTTPServer) stopScript(scriptName string) error <span class="cov0" title="0">{
        // Check if script is running
        pidPath := fmt.Sprintf("/tmp/user.scripts.%s.pid", scriptName)
        pidData, err := os.ReadFile(pidPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("script '%s' is not running", scriptName)
        }</span>

        <span class="cov0" title="0">pidStr := strings.TrimSpace(string(pidData))
        pid, err := strconv.Atoi(pidStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid PID file for script '%s'", scriptName)
        }</span>

        // Find and terminate the process
        <span class="cov0" title="0">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find process %d: %v", pid, err)
        }</span>

        // Send SIGTERM first
        <span class="cov0" title="0">if err := process.Signal(syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to terminate process %d: %v", pid, err)
        }</span>

        // Wait a bit for graceful shutdown
        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Check if process is still running
        if h.isProcessRunning(pid) </span><span class="cov0" title="0">{
                // Force kill with SIGKILL
                if err := process.Signal(syscall.SIGKILL); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to kill process %d: %v", pid, err)
                }</span>
        }

        // Remove PID file
        <span class="cov0" title="0">os.Remove(pidPath)

        return nil</span>
}

// getProcessStartTime gets the start time of a process (Unix-specific)
func (h *HTTPServer) getProcessStartTime(pid int) (time.Time, error) <span class="cov0" title="0">{
        // Read process stat file
        statPath := fmt.Sprintf("/proc/%d/stat", pid)
        content, err := os.ReadFile(statPath)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        // Parse stat file (field 22 is start time in clock ticks)
        <span class="cov0" title="0">fields := strings.Fields(string(content))
        if len(fields) &lt; 22 </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid stat file format")
        }</span>

        <span class="cov0" title="0">startTicks, err := strconv.ParseInt(fields[21], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        // Get system boot time
        <span class="cov0" title="0">bootTime, err := h.getSystemBootTime()
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        // Calculate start time (assuming 100 ticks per second)
        <span class="cov0" title="0">startTime := bootTime.Add(time.Duration(startTicks*10) * time.Millisecond)

        return startTime, nil</span>
}

// getSystemBootTime gets the system boot time
func (h *HTTPServer) getSystemBootTime() (time.Time, error) <span class="cov0" title="0">{
        content, err := os.ReadFile("/proc/stat")
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "btime ") </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                                bootTimestamp, err := strconv.ParseInt(fields[1], 10, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        return time.Time{}, err
                                }</span>
                                <span class="cov0" title="0">return time.Unix(bootTimestamp, 0), nil</span>
                        }
                }
        }

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("boot time not found in /proc/stat")</span>
}

// getScriptExitCode gets the exit code of a completed script
func (h *HTTPServer) getScriptExitCode(scriptName string) (int, error) <span class="cov0" title="0">{
        // Try to read exit code from a status file (if User Scripts plugin creates one)
        statusPath := fmt.Sprintf("/tmp/user.scripts.%s.status", scriptName)
        if content, err := os.ReadFile(statusPath); err == nil </span><span class="cov0" title="0">{
                return strconv.Atoi(strings.TrimSpace(string(content)))
        }</span>

        // If no status file, assume success (0) if log exists, error (1) otherwise
        <span class="cov0" title="0">logPath := fmt.Sprintf("/tmp/user.scripts/tmpScripts/%s.log", scriptName)
        if _, err := os.Stat(logPath); err == nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">return 1, nil</span>
}

// Share Management Implementation Functions

// getShares returns a list of all configured shares
func (h *HTTPServer) getShares() ([]Share, error) <span class="cov0" title="0">{
        var shares []Share

        // Read share configuration files from /boot/config/shares/
        sharesDir := "/boot/config/shares"
        if _, err := os.Stat(sharesDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // No shares directory, return empty list
                return shares, nil
        }</span>

        <span class="cov0" title="0">entries, err := os.ReadDir(sharesDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read shares directory: %v", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".cfg") </span><span class="cov0" title="0">{
                        shareName := strings.TrimSuffix(entry.Name(), ".cfg")
                        share, err := h.parseShareConfig(shareName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log error but continue with other shares
                                continue</span>
                        }
                        <span class="cov0" title="0">shares = append(shares, *share)</span>
                }
        }

        <span class="cov0" title="0">return shares, nil</span>
}

// getShare returns detailed information for a specific share
func (h *HTTPServer) getShare(shareName string) (*Share, error) <span class="cov0" title="0">{
        return h.parseShareConfig(shareName)
}</span>

// parseShareConfig parses a share configuration file
func (h *HTTPServer) parseShareConfig(shareName string) (*Share, error) <span class="cov0" title="0">{
        configPath := fmt.Sprintf("/boot/config/shares/%s.cfg", shareName)

        content, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share '%s' not found", shareName)
        }</span>

        <span class="cov0" title="0">share := &amp;Share{
                Name: shareName,
                Path: fmt.Sprintf("/mnt/user/%s", shareName),
        }

        // Parse the configuration file (simple key=value format)
        lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), "\"")

                switch key </span>{
                case "shareComment":<span class="cov0" title="0">
                        share.Comment = value</span>
                case "shareAllocator":<span class="cov0" title="0">
                        share.AllocatorMethod = value</span>
                case "shareFloor":<span class="cov0" title="0">
                        share.MinimumFreeSpace = value</span>
                case "shareSplitLevel":<span class="cov0" title="0">
                        if level, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                share.SplitLevel = level
                        }</span>
                case "shareInclude":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                share.IncludedDisks = strings.Split(value, ",")
                        }</span>
                case "shareExclude":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                share.ExcludedDisks = strings.Split(value, ",")
                        }</span>
                case "shareUseCache":<span class="cov0" title="0">
                        share.UseCache = value</span>
                case "shareCachePool":<span class="cov0" title="0">
                        share.CachePool = value</span>
                case "shareExport":<span class="cov0" title="0">
                        share.SMBEnabled = (value == "yes")</span>
                case "shareSecurity":<span class="cov0" title="0">
                        share.SMBSecurity = value</span>
                case "shareGuest":<span class="cov0" title="0">
                        share.SMBGuests = (value == "yes")</span>
                case "shareNFSExport":<span class="cov0" title="0">
                        share.NFSEnabled = (value == "yes")</span>
                case "shareNFSSecurity":<span class="cov0" title="0">
                        share.NFSSecurity = value</span>
                case "shareAFPExport":<span class="cov0" title="0">
                        share.AFPEnabled = (value == "yes")</span>
                case "shareFTPExport":<span class="cov0" title="0">
                        share.FTPEnabled = (value == "yes")</span>
                }
        }

        // Get file timestamps
        <span class="cov0" title="0">if stat, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                share.ModifiedAt = stat.ModTime().Format(time.RFC3339)
                // For creation time, we'll use the same as modified time
                share.CreatedAt = share.ModifiedAt
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

// getShareUsage calculates usage statistics for a share
func (h *HTTPServer) getShareUsage(shareName string) (*ShareUsage, error) <span class="cov0" title="0">{
        sharePath := fmt.Sprintf("/mnt/user/%s", shareName)

        // Check if share path exists
        if _, err := os.Stat(sharePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share '%s' not found", shareName)
        }</span>

        <span class="cov0" title="0">usage := &amp;ShareUsage{
                Name: shareName,
        }

        // Get filesystem statistics using statvfs
        var stat syscall.Statfs_t
        if err := syscall.Statfs(sharePath, &amp;stat); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get filesystem stats: %v", err)
        }</span>

        // Calculate sizes
        <span class="cov0" title="0">blockSize := int64(stat.Bsize)
        usage.TotalSize = int64(stat.Blocks) * blockSize
        usage.FreeSize = int64(stat.Bavail) * blockSize
        usage.UsedSize = usage.TotalSize - usage.FreeSize

        if usage.TotalSize &gt; 0 </span><span class="cov0" title="0">{
                usage.UsedPercent = float64(usage.UsedSize) / float64(usage.TotalSize) * 100
        }</span>

        // Count files and directories (this can be expensive for large shares)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                fileCount, dirCount := h.countFilesAndDirs(sharePath)
                usage.FileCount = fileCount
                usage.DirectoryCount = dirCount
        }</span>()

        // Get last access time from directory stat
        <span class="cov0" title="0">if stat, err := os.Stat(sharePath); err == nil </span><span class="cov0" title="0">{
                usage.LastAccessed = stat.ModTime().Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return usage, nil</span>
}

// countFilesAndDirs counts files and directories in a path (runs in background)
func (h *HTTPServer) countFilesAndDirs(path string) (int64, int64) <span class="cov0" title="0">{
        var fileCount, dirCount int64

        filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Continue on errors
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        dirCount++
                }</span> else<span class="cov0" title="0"> {
                        fileCount++
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return fileCount, dirCount</span>
}

// validateShareCreateRequest validates a share creation request
func (h *HTTPServer) validateShareCreateRequest(req *ShareCreateRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("share name is required")
        }</span>

        // Validate share name (alphanumeric, underscore, hyphen only)
        <span class="cov0" title="0">if !isValidShareName(req.Name) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid share name: must contain only letters, numbers, underscore, and hyphen")
        }</span>

        // Check if share already exists
        <span class="cov0" title="0">if _, err := h.getShare(req.Name); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("share '%s' already exists", req.Name)
        }</span>

        // Validate allocator method
        <span class="cov0" title="0">if req.AllocatorMethod != "" </span><span class="cov0" title="0">{
                validMethods := []string{"high-water", "most-free", "fill-up"}
                if !contains(validMethods, req.AllocatorMethod) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid allocator method: must be one of %v", validMethods)
                }</span>
        }

        // Validate cache usage
        <span class="cov0" title="0">if req.UseCache != "" </span><span class="cov0" title="0">{
                validCache := []string{"yes", "no", "only", "prefer"}
                if !contains(validCache, req.UseCache) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cache usage: must be one of %v", validCache)
                }</span>
        }

        // Validate security settings
        <span class="cov0" title="0">if req.SMBSecurity != "" </span><span class="cov0" title="0">{
                validSecurity := []string{"public", "secure", "private"}
                if !contains(validSecurity, req.SMBSecurity) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid SMB security: must be one of %v", validSecurity)
                }</span>
        }

        <span class="cov0" title="0">if req.NFSSecurity != "" </span><span class="cov0" title="0">{
                validSecurity := []string{"public", "secure", "private"}
                if !contains(validSecurity, req.NFSSecurity) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid NFS security: must be one of %v", validSecurity)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateShareUpdateRequest validates a share update request
func (h *HTTPServer) validateShareUpdateRequest(req *ShareUpdateRequest) error <span class="cov0" title="0">{
        // Similar validation as create, but name is not required
        if req.AllocatorMethod != "" </span><span class="cov0" title="0">{
                validMethods := []string{"high-water", "most-free", "fill-up"}
                if !contains(validMethods, req.AllocatorMethod) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid allocator method: must be one of %v", validMethods)
                }</span>
        }

        <span class="cov0" title="0">if req.UseCache != "" </span><span class="cov0" title="0">{
                validCache := []string{"yes", "no", "only", "prefer"}
                if !contains(validCache, req.UseCache) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cache usage: must be one of %v", validCache)
                }</span>
        }

        <span class="cov0" title="0">if req.SMBSecurity != "" </span><span class="cov0" title="0">{
                validSecurity := []string{"public", "secure", "private"}
                if !contains(validSecurity, req.SMBSecurity) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid SMB security: must be one of %v", validSecurity)
                }</span>
        }

        <span class="cov0" title="0">if req.NFSSecurity != "" </span><span class="cov0" title="0">{
                validSecurity := []string{"public", "secure", "private"}
                if !contains(validSecurity, req.NFSSecurity) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid NFS security: must be one of %v", validSecurity)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createShare creates a new share
func (h *HTTPServer) createShare(req *ShareCreateRequest) error <span class="cov0" title="0">{
        configPath := fmt.Sprintf("/boot/config/shares/%s.cfg", req.Name)

        // Ensure shares directory exists
        sharesDir := "/boot/config/shares"
        if err := os.MkdirAll(sharesDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create shares directory: %v", err)
        }</span>

        // Create share configuration content
        <span class="cov0" title="0">config := h.buildShareConfig(req)

        // Write configuration file
        if err := os.WriteFile(configPath, []byte(config), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write share config: %v", err)
        }</span>

        // Create share directory
        <span class="cov0" title="0">sharePath := fmt.Sprintf("/mnt/user/%s", req.Name)
        if err := os.MkdirAll(sharePath, 0755); err != nil </span><span class="cov0" title="0">{
                // Clean up config file if directory creation fails
                os.Remove(configPath)
                return fmt.Errorf("failed to create share directory: %v", err)
        }</span>

        // Reload SMB configuration if SMB is enabled
        <span class="cov0" title="0">if req.SMBEnabled </span><span class="cov0" title="0">{
                h.reloadSMBConfig()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateShare updates an existing share
func (h *HTTPServer) updateShare(shareName string, req *ShareUpdateRequest) error <span class="cov0" title="0">{
        configPath := fmt.Sprintf("/boot/config/shares/%s.cfg", shareName)

        // Check if share exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("share '%s' not found", shareName)
        }</span>

        // Read existing configuration
        <span class="cov0" title="0">existingShare, err := h.parseShareConfig(shareName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read existing share config: %v", err)
        }</span>

        // Update fields that are provided
        <span class="cov0" title="0">h.updateShareFields(existingShare, req)

        // Build new configuration
        config := h.buildShareConfigFromShare(existingShare)

        // Write updated configuration
        if err := os.WriteFile(configPath, []byte(config), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update share config: %v", err)
        }</span>

        // Reload SMB configuration if SMB settings changed
        <span class="cov0" title="0">if req.SMBEnabled || req.SMBSecurity != "" </span><span class="cov0" title="0">{
                h.reloadSMBConfig()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// deleteShare deletes a share
func (h *HTTPServer) deleteShare(shareName string) error <span class="cov0" title="0">{
        configPath := fmt.Sprintf("/boot/config/shares/%s.cfg", shareName)

        // Check if share exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("share '%s' not found", shareName)
        }</span>

        // Remove configuration file
        <span class="cov0" title="0">if err := os.Remove(configPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove share config: %v", err)
        }</span>

        // Note: We don't remove the share directory as it may contain user data
        // The directory will remain at /mnt/user/{shareName} but won't be shared

        // Reload SMB configuration
        <span class="cov0" title="0">h.reloadSMBConfig()

        return nil</span>
}

// Helper functions

// isValidShareName validates a share name
func isValidShareName(name string) bool <span class="cov0" title="0">{
        if name == "" || len(name) &gt; 64 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, char := range name </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
                        (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
                        char == '_' || char == '-') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// buildShareConfig builds configuration content for a new share
func (h *HTTPServer) buildShareConfig(req *ShareCreateRequest) string <span class="cov0" title="0">{
        var config strings.Builder

        config.WriteString(fmt.Sprintf("shareName=\"%s\"\n", req.Name))

        if req.Comment != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareComment=\"%s\"\n", req.Comment))
        }</span>

        // Set defaults if not provided
        <span class="cov0" title="0">allocator := req.AllocatorMethod
        if allocator == "" </span><span class="cov0" title="0">{
                allocator = "high-water"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareAllocator=\"%s\"\n", allocator))

        if req.MinimumFreeSpace != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareFloor=\"%s\"\n", req.MinimumFreeSpace))
        }</span>

        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareSplitLevel=\"%d\"\n", req.SplitLevel))

        if len(req.IncludedDisks) &gt; 0 </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareInclude=\"%s\"\n", strings.Join(req.IncludedDisks, ",")))
        }</span>

        <span class="cov0" title="0">if len(req.ExcludedDisks) &gt; 0 </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareExclude=\"%s\"\n", strings.Join(req.ExcludedDisks, ",")))
        }</span>

        <span class="cov0" title="0">useCache := req.UseCache
        if useCache == "" </span><span class="cov0" title="0">{
                useCache = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareUseCache=\"%s\"\n", useCache))

        if req.CachePool != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareCachePool=\"%s\"\n", req.CachePool))
        }</span>

        // SMB settings
        <span class="cov0" title="0">smbExport := "no"
        if req.SMBEnabled </span><span class="cov0" title="0">{
                smbExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareExport=\"%s\"\n", smbExport))

        smbSecurity := req.SMBSecurity
        if smbSecurity == "" </span><span class="cov0" title="0">{
                smbSecurity = "private"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareSecurity=\"%s\"\n", smbSecurity))

        smbGuests := "no"
        if req.SMBGuests </span><span class="cov0" title="0">{
                smbGuests = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareGuest=\"%s\"\n", smbGuests))

        // NFS settings
        nfsExport := "no"
        if req.NFSEnabled </span><span class="cov0" title="0">{
                nfsExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareNFSExport=\"%s\"\n", nfsExport))

        if req.NFSSecurity != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareNFSSecurity=\"%s\"\n", req.NFSSecurity))
        }</span>

        // AFP settings
        <span class="cov0" title="0">afpExport := "no"
        if req.AFPEnabled </span><span class="cov0" title="0">{
                afpExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareAFPExport=\"%s\"\n", afpExport))

        // FTP settings
        ftpExport := "no"
        if req.FTPEnabled </span><span class="cov0" title="0">{
                ftpExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareFTPExport=\"%s\"\n", ftpExport))

        return config.String()</span>
}

// buildShareConfigFromShare builds configuration content from a Share struct
func (h *HTTPServer) buildShareConfigFromShare(share *Share) string <span class="cov0" title="0">{
        var config strings.Builder

        config.WriteString(fmt.Sprintf("shareName=\"%s\"\n", share.Name))

        if share.Comment != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareComment=\"%s\"\n", share.Comment))
        }</span>

        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareAllocator=\"%s\"\n", share.AllocatorMethod))

        if share.MinimumFreeSpace != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareFloor=\"%s\"\n", share.MinimumFreeSpace))
        }</span>

        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareSplitLevel=\"%d\"\n", share.SplitLevel))

        if len(share.IncludedDisks) &gt; 0 </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareInclude=\"%s\"\n", strings.Join(share.IncludedDisks, ",")))
        }</span>

        <span class="cov0" title="0">if len(share.ExcludedDisks) &gt; 0 </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareExclude=\"%s\"\n", strings.Join(share.ExcludedDisks, ",")))
        }</span>

        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareUseCache=\"%s\"\n", share.UseCache))

        if share.CachePool != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareCachePool=\"%s\"\n", share.CachePool))
        }</span>

        // SMB settings
        <span class="cov0" title="0">smbExport := "no"
        if share.SMBEnabled </span><span class="cov0" title="0">{
                smbExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareExport=\"%s\"\n", smbExport))

        config.WriteString(fmt.Sprintf("shareSecurity=\"%s\"\n", share.SMBSecurity))

        smbGuests := "no"
        if share.SMBGuests </span><span class="cov0" title="0">{
                smbGuests = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareGuest=\"%s\"\n", smbGuests))

        // NFS settings
        nfsExport := "no"
        if share.NFSEnabled </span><span class="cov0" title="0">{
                nfsExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareNFSExport=\"%s\"\n", nfsExport))

        if share.NFSSecurity != "" </span><span class="cov0" title="0">{
                config.WriteString(fmt.Sprintf("shareNFSSecurity=\"%s\"\n", share.NFSSecurity))
        }</span>

        // AFP settings
        <span class="cov0" title="0">afpExport := "no"
        if share.AFPEnabled </span><span class="cov0" title="0">{
                afpExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareAFPExport=\"%s\"\n", afpExport))

        // FTP settings
        ftpExport := "no"
        if share.FTPEnabled </span><span class="cov0" title="0">{
                ftpExport = "yes"
        }</span>
        <span class="cov0" title="0">config.WriteString(fmt.Sprintf("shareFTPExport=\"%s\"\n", ftpExport))

        return config.String()</span>
}

// updateShareFields updates share fields from update request
func (h *HTTPServer) updateShareFields(share *Share, req *ShareUpdateRequest) <span class="cov0" title="0">{
        if req.Comment != "" </span><span class="cov0" title="0">{
                share.Comment = req.Comment
        }</span>

        <span class="cov0" title="0">if req.AllocatorMethod != "" </span><span class="cov0" title="0">{
                share.AllocatorMethod = req.AllocatorMethod
        }</span>

        <span class="cov0" title="0">if req.MinimumFreeSpace != "" </span><span class="cov0" title="0">{
                share.MinimumFreeSpace = req.MinimumFreeSpace
        }</span>

        <span class="cov0" title="0">if req.SplitLevel &gt; 0 </span><span class="cov0" title="0">{
                share.SplitLevel = req.SplitLevel
        }</span>

        <span class="cov0" title="0">if len(req.IncludedDisks) &gt; 0 </span><span class="cov0" title="0">{
                share.IncludedDisks = req.IncludedDisks
        }</span>

        <span class="cov0" title="0">if len(req.ExcludedDisks) &gt; 0 </span><span class="cov0" title="0">{
                share.ExcludedDisks = req.ExcludedDisks
        }</span>

        <span class="cov0" title="0">if req.UseCache != "" </span><span class="cov0" title="0">{
                share.UseCache = req.UseCache
        }</span>

        <span class="cov0" title="0">if req.CachePool != "" </span><span class="cov0" title="0">{
                share.CachePool = req.CachePool
        }</span>

        // SMB settings
        <span class="cov0" title="0">if req.SMBEnabled </span><span class="cov0" title="0">{
                share.SMBEnabled = req.SMBEnabled
        }</span>

        <span class="cov0" title="0">if req.SMBSecurity != "" </span><span class="cov0" title="0">{
                share.SMBSecurity = req.SMBSecurity
        }</span>

        <span class="cov0" title="0">if req.SMBGuests </span><span class="cov0" title="0">{
                share.SMBGuests = req.SMBGuests
        }</span>

        // NFS settings
        <span class="cov0" title="0">if req.NFSEnabled </span><span class="cov0" title="0">{
                share.NFSEnabled = req.NFSEnabled
        }</span>

        <span class="cov0" title="0">if req.NFSSecurity != "" </span><span class="cov0" title="0">{
                share.NFSSecurity = req.NFSSecurity
        }</span>

        // AFP settings
        <span class="cov0" title="0">if req.AFPEnabled </span><span class="cov0" title="0">{
                share.AFPEnabled = req.AFPEnabled
        }</span>

        // FTP settings
        <span class="cov0" title="0">if req.FTPEnabled </span><span class="cov0" title="0">{
                share.FTPEnabled = req.FTPEnabled
        }</span>

        // Update modification time
        <span class="cov0" title="0">share.ModifiedAt = time.Now().Format(time.RFC3339)</span>
}

// reloadSMBConfig reloads the SMB configuration
func (h *HTTPServer) reloadSMBConfig() <span class="cov0" title="0">{
        // Execute command to reload SMB configuration
        // This is typically done by restarting the SMB service or reloading config
        exec.Command("/etc/rc.d/rc.samba", "reload").Run()
}</span>

// corsMiddleware adds CORS headers
func (h *HTTPServer) corsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID")

                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// requestIDMiddleware adds request ID tracking for debugging and tracing
func (h *HTTPServer) requestIDMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Check if request already has an ID from client
                requestID := r.Header.Get("X-Request-ID")

                // Generate a new request ID if not provided
                if requestID == "" </span><span class="cov8" title="1">{
                        requestID = h.generateRequestID()
                }</span>

                // Set the request ID in response headers
                <span class="cov8" title="1">w.Header().Set("X-Request-ID", requestID)

                // Add request ID to request context for use in handlers
                ctx := context.WithValue(r.Context(), requestIDKey, requestID)
                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)</span>
        })
}

// generateRequestID creates a unique request ID for tracing using UUID
func (h *HTTPServer) generateRequestID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>

// compressionMiddleware adds gzip compression for large responses
func (h *HTTPServer) compressionMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Check if client accepts gzip encoding
                if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Only compress responses for certain endpoints or large responses
                <span class="cov8" title="1">shouldCompress := h.shouldCompressResponse(r)
                if !shouldCompress </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Set compression headers
                <span class="cov8" title="1">w.Header().Set("Content-Encoding", "gzip")
                w.Header().Set("Vary", "Accept-Encoding")

                // Create gzip writer
                gzipWriter := gzip.NewWriter(w)
                defer gzipWriter.Close()

                // Create wrapper that writes to gzip writer
                gzipResponseWriter := &amp;gzipResponseWriter{
                        ResponseWriter: w,
                        Writer:         gzipWriter,
                }

                next.ServeHTTP(gzipResponseWriter, r)</span>
        })
}

// shouldCompressResponse determines if a response should be compressed
func (h *HTTPServer) shouldCompressResponse(r *http.Request) bool <span class="cov8" title="1">{
        // Compress responses for endpoints that typically return large data
        compressiblePaths := []string{
                "/api/v1/storage/disks",
                "/api/v1/storage/zfs",
                "/api/v1/docker/containers",
                "/api/v1/notifications",
                "/api/v1/openapi.json",
                "/api/v1/system/resources",
        }

        for _, path := range compressiblePaths </span><span class="cov8" title="1">{
                if strings.HasPrefix(r.URL.Path, path) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// gzipResponseWriter wraps http.ResponseWriter to compress responses
type gzipResponseWriter struct {
        http.ResponseWriter
        Writer io.Writer
}

func (w *gzipResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return w.Writer.Write(b)
}</span>

// versioningMiddleware handles API version negotiation
func (h *HTTPServer) versioningMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Parse Accept header for version negotiation
                acceptHeader := r.Header.Get("Accept")
                apiVersion := h.parseAPIVersion(acceptHeader)

                // Set the negotiated version in request context
                ctx := context.WithValue(r.Context(), apiVersionKey, apiVersion)
                r = r.WithContext(ctx)

                // Set version information in response headers
                w.Header().Set("X-API-Version", apiVersion)
                w.Header().Set("X-API-Supported-Versions", "v1")

                next.ServeHTTP(w, r)
        }</span>)
}

// parseAPIVersion extracts API version from Accept header
func (h *HTTPServer) parseAPIVersion(acceptHeader string) string <span class="cov8" title="1">{
        // Default to v1 if no specific version requested
        defaultVersion := "v1"

        if acceptHeader == "" </span><span class="cov8" title="1">{
                return defaultVersion
        }</span>

        // Look for version-specific media types
        // Format: application/vnd.uma.v1+json
        <span class="cov8" title="1">if strings.Contains(acceptHeader, "application/vnd.uma.v1+json") </span><span class="cov8" title="1">{
                return "v1"
        }</span>

        // Look for version parameter in Accept header
        // Format: application/json; version=v1
        <span class="cov0" title="0">if strings.Contains(acceptHeader, "version=v1") </span><span class="cov0" title="0">{
                return "v1"
        }</span>

        // Future versions can be added here
        // if strings.Contains(acceptHeader, "application/vnd.uma.v2+json") {
        //     return "v2"
        // }

        <span class="cov0" title="0">return defaultVersion</span>
}

// getAPIVersionFromContext retrieves the API version from request context
func (h *HTTPServer) getAPIVersionFromContext(r *http.Request) string <span class="cov8" title="1">{
        if version, ok := r.Context().Value(apiVersionKey).(string); ok </span><span class="cov0" title="0">{
                return version
        }</span>
        <span class="cov8" title="1">return "v1"</span> // Default fallback
}

// writeVersionedResponse writes a response with version-specific formatting
func (h *HTTPServer) writeVersionedResponse(w http.ResponseWriter, r *http.Request, status int, data interface{}, pagination *dto.PaginationInfo) <span class="cov8" title="1">{
        version := h.getAPIVersionFromContext(r)

        switch version </span>{
        case "v1":<span class="cov8" title="1">
                // Current v1 format with standardized response structure
                h.writeStandardResponse(w, status, data, pagination)</span>
        default:<span class="cov0" title="0">
                // Future versions can have different response formats
                h.writeStandardResponse(w, status, data, pagination)</span>
        }
}

// loggingMiddleware logs HTTP requests with structured logging
func (h *HTTPServer) loggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                // Create a response writer wrapper to capture status code
                wrapper := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(wrapper, r)

                duration := time.Since(start)
                requestID := h.getRequestIDFromContext(r)

                // Use structured logging for API requests
                logger.LogAPIRequest(requestID, r.Method, r.URL.Path, wrapper.statusCode, duration)

                // Log additional context for errors
                if wrapper.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        context := map[string]interface{}{
                                "user_agent":     r.UserAgent(),
                                "content_type":   r.Header.Get("Content-Type"),
                                "content_length": r.ContentLength,
                                "query_params":   r.URL.RawQuery,
                        }

                        if wrapper.statusCode &gt;= 500 </span><span class="cov0" title="0">{
                                logger.LogErrorWithContext("api", "http_request",
                                        fmt.Errorf("HTTP %d error for %s %s", wrapper.statusCode, r.Method, r.URL.Path),
                                        requestID, context)
                        }</span>
                }

                // Backward compatibility: also log with colored output
                <span class="cov8" title="1">if requestID != "" </span><span class="cov0" title="0">{
                        logger.LightGreen("HTTP %s %s %d %v [%s]", r.Method, r.URL.Path, wrapper.statusCode, duration, requestID)
                }</span> else<span class="cov8" title="1"> {
                        logger.LightGreen("HTTP %s %s %d %v", r.Method, r.URL.Path, wrapper.statusCode, duration)
                }</span>
        })
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// writeJSON writes a JSON response
func (h *HTTPServer) writeJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                logger.Yellow("Error encoding JSON response: %v", err)
        }</span>
}

// writeError writes an error response
func (h *HTTPServer) writeError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        errorResponse := dto.Response{
                Error:   message,
                Message: http.StatusText(status),
        }
        h.writeJSON(w, status, errorResponse)
}</span>

// Notification API handlers

// handleNotifications handles GET /api/v1/notifications and POST /api/v1/notifications
func (h *HTTPServer) handleNotifications(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetNotifications(w, r)</span>
        case http.MethodPost:<span class="cov0" title="0">
                h.handleCreateNotification(w, r)</span>
        default:<span class="cov0" title="0">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// handleNotification handles GET/PUT/DELETE /api/v1/notifications/{id}
func (h *HTTPServer) handleNotification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract notification ID from URL path
        path := strings.TrimPrefix(r.URL.Path, "/api/v1/notifications/")
        if path == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Notification ID required")
                return
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetNotification(w, r, path)</span>
        case http.MethodPut:<span class="cov0" title="0">
                h.handleUpdateNotification(w, r, path)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                h.handleDeleteNotification(w, r, path)</span>
        default:<span class="cov0" title="0">
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")</span>
        }
}

// handleNotificationsClear handles POST /api/v1/notifications/clear
func (h *HTTPServer) handleNotificationsClear(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if err := h.api.notifications.ClearAllNotifications(); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to clear notifications: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "All notifications cleared"})</span>
}

// handleNotificationsStats handles GET /api/v1/notifications/stats
func (h *HTTPServer) handleNotificationsStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.api.notifications.GetNotificationStats()
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get notification stats: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, stats)</span>
}

// handleNotificationsMarkAllRead handles POST /api/v1/notifications/mark-all-read
func (h *HTTPServer) handleNotificationsMarkAllRead(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">if err := h.api.notifications.MarkAllAsRead(); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to mark all notifications as read: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "All notifications marked as read"})</span>
}

// handleGetNotifications handles GET /api/v1/notifications with filtering
func (h *HTTPServer) handleGetNotifications(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse pagination parameters
        params := h.parsePaginationParams(r)
        usePagination := r.URL.Query().Get("page") != "" || r.URL.Query().Get("limit") != ""

        // Parse query parameters for filtering
        filter := &amp;notifications.NotificationFilter{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filter.Level = notifications.NotificationLevel(level)
        }</span>

        <span class="cov0" title="0">if category := r.URL.Query().Get("category"); category != "" </span><span class="cov0" title="0">{
                filter.Category = notifications.NotificationCategory(category)
        }</span>

        <span class="cov0" title="0">if readStr := r.URL.Query().Get("read"); readStr != "" </span><span class="cov0" title="0">{
                if read, err := strconv.ParseBool(readStr); err == nil </span><span class="cov0" title="0">{
                        filter.Read = &amp;read
                }</span>
        }

        <span class="cov0" title="0">if persistentStr := r.URL.Query().Get("persistent"); persistentStr != "" </span><span class="cov0" title="0">{
                if persistent, err := strconv.ParseBool(persistentStr); err == nil </span><span class="cov0" title="0">{
                        filter.Persistent = &amp;persistent
                }</span>
        }

        // For backward compatibility, still support the old limit parameter
        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" &amp;&amp; !usePagination </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filter.Limit = limit
                }</span>
        }

        // Parse time filters
        <span class="cov0" title="0">if sinceStr := r.URL.Query().Get("since"); sinceStr != "" </span><span class="cov0" title="0">{
                if since, err := time.Parse(time.RFC3339, sinceStr); err == nil </span><span class="cov0" title="0">{
                        filter.Since = &amp;since
                }</span>
        }

        <span class="cov0" title="0">if untilStr := r.URL.Query().Get("until"); untilStr != "" </span><span class="cov0" title="0">{
                if until, err := time.Parse(time.RFC3339, untilStr); err == nil </span><span class="cov0" title="0">{
                        filter.Until = &amp;until
                }</span>
        }

        <span class="cov0" title="0">notificationsList, err := h.api.notifications.GetNotifications(filter)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get notifications: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if usePagination </span><span class="cov0" title="0">{
                // Convert notifications to interface{} slice for pagination
                notificationItems := make([]interface{}, len(notificationsList))
                for i, notification := range notificationsList </span><span class="cov0" title="0">{
                        notificationItems[i] = notification
                }</span>

                <span class="cov0" title="0">paginatedNotifications, total := h.paginateSlice(notificationItems, params)
                h.writePaginatedResponse(w, http.StatusOK, paginatedNotifications, total, params)</span>
        } else<span class="cov0" title="0"> {
                // Return original format for backward compatibility
                h.writeJSON(w, http.StatusOK, map[string]interface{}{
                        "notifications": notificationsList,
                        "count":         len(notificationsList),
                })
        }</span>
}

// handleCreateNotification handles POST /api/v1/notifications
func (h *HTTPServer) handleCreateNotification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Title    string                             `json:"title"`
                Message  string                             `json:"message"`
                Level    notifications.NotificationLevel    `json:"level"`
                Category notifications.NotificationCategory `json:"category"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON")
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Title == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Title is required")
                return
        }</span>
        <span class="cov0" title="0">if req.Message == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Message is required")
                return
        }</span>
        <span class="cov0" title="0">if req.Level == "" </span><span class="cov0" title="0">{
                req.Level = notifications.LevelInfo
        }</span>
        <span class="cov0" title="0">if req.Category == "" </span><span class="cov0" title="0">{
                req.Category = notifications.CategoryCustom
        }</span>

        <span class="cov0" title="0">notification, err := h.api.notifications.CreateNotification(req.Title, req.Message, req.Level, req.Category)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to create notification: %v", err))
                return
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, http.StatusCreated, notification)</span>
}

// handleGetNotification handles GET /api/v1/notifications/{id}
func (h *HTTPServer) handleGetNotification(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        notification, err := h.api.notifications.GetNotification(id)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, "Notification not found")
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to get notification: %v", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, notification)</span>
}

// handleUpdateNotification handles PUT /api/v1/notifications/{id}
func (h *HTTPServer) handleUpdateNotification(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        var updates map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;updates); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON")
                return
        }</span>

        <span class="cov0" title="0">notification, err := h.api.notifications.UpdateNotification(id, updates)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, "Notification not found")
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to update notification: %v", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, notification)</span>
}

// handleDeleteNotification handles DELETE /api/v1/notifications/{id}
func (h *HTTPServer) handleDeleteNotification(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        if err := h.api.notifications.DeleteNotification(id); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        h.writeError(w, http.StatusNotFound, "Notification not found")
                }</span> else<span class="cov0" title="0"> {
                        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to delete notification: %v", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.writeJSON(w, http.StatusOK, map[string]string{"message": "Notification deleted"})</span>
}

// Command Execution Handlers

// handleExecuteCommand handles POST /api/v1/execute/command
func (h *HTTPServer) handleExecuteCommand(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req command.CommandRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Command == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Command is required")
                return
        }</span>

        // Execute command
        <span class="cov0" title="0">response, err := h.commandExecutor.ExecuteCommand(req)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to execute command: %v", err))
                return
        }</span>

        // Return appropriate status code based on success
        <span class="cov0" title="0">statusCode := http.StatusOK
        if !response.Success </span><span class="cov0" title="0">{
                statusCode = http.StatusBadRequest
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, statusCode, response)</span>
}

// handleExecuteContainer handles POST /api/v1/execute/container
func (h *HTTPServer) handleExecuteContainer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var req command.ContainerCommandRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.ContainerID == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Container ID is required")
                return
        }</span>
        <span class="cov0" title="0">if req.Command == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Command is required")
                return
        }</span>

        // Execute container command
        <span class="cov0" title="0">response, err := h.commandExecutor.ExecuteContainerCommand(req)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to execute container command: %v", err))
                return
        }</span>

        // Return appropriate status code based on success
        <span class="cov0" title="0">statusCode := http.StatusOK
        if !response.Success </span><span class="cov0" title="0">{
                statusCode = http.StatusBadRequest
        }</span>

        <span class="cov0" title="0">h.writeJSON(w, statusCode, response)</span>
}

// handleAllowedCommands handles GET /api/v1/execute/allowed-commands
func (h *HTTPServer) handleAllowedCommands(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">allowedCommands := h.commandExecutor.GetAllowedCommands()

        response := map[string]interface{}{
                "allowed_commands": allowedCommands,
                "count":            len(allowedCommands),
                "message":          "List of allowed commands for secure execution",
        }

        h.writeJSON(w, http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "net/http"
        "strconv"
        "time"

        "github.com/domalab/uma/daemon/logger"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        // API Request Metrics
        apiRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "uma_api_requests_total",
                        Help: "Total number of API requests",
                },
                []string{"method", "endpoint", "status_code"},
        )

        apiRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "uma_api_request_duration_seconds",
                        Help:    "Duration of API requests in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        // Bulk Operation Metrics
        bulkOperationDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "uma_bulk_operation_duration_seconds",
                        Help:    "Duration of bulk operations in seconds",
                        Buckets: []float64{0.1, 0.5, 1.0, 2.5, 5.0, 10.0},
                },
                []string{"operation"},
        )

        bulkOperationContainers = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "uma_bulk_operation_containers",
                        Help:    "Number of containers processed in bulk operations",
                        Buckets: []float64{1, 5, 10, 25, 50},
                },
                []string{"operation"},
        )

        bulkOperationSuccessRate = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "uma_bulk_operation_success_rate",
                        Help: "Success rate of bulk operations (percentage)",
                },
                []string{"operation"},
        )

        // WebSocket Connection Metrics
        websocketConnections = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "uma_websocket_connections",
                        Help: "Number of active WebSocket connections",
                },
                []string{"endpoint"},
        )

        websocketMessagesTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "uma_websocket_messages_total",
                        Help: "Total number of WebSocket messages sent",
                },
                []string{"endpoint", "message_type"},
        )

        // Health Check Metrics
        healthCheckDuration = promauto.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "uma_health_check_duration_seconds",
                        Help:    "Duration of health checks in seconds",
                        Buckets: []float64{0.1, 0.5, 1.0, 2.0, 5.0, 10.0},
                },
        )

        healthCheckStatus = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "uma_health_check_status",
                        Help: "Health check status (1 = healthy, 0 = unhealthy)",
                },
                []string{"dependency"},
        )

        // System Metrics
        configLoadTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "uma_config_load_total",
                        Help: "Total number of configuration loads",
                },
                []string{"config_type", "status"},
        )

        validationErrorsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "uma_validation_errors_total",
                        Help: "Total number of validation errors",
                },
                []string{"component", "operation"},
        )
)

// Note: responseWriter is defined in http_server.go

// metricsMiddleware adds metrics collection to HTTP requests
func (h *HTTPServer) metricsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                // Wrap response writer to capture status code
                wrapped := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                // Process request
                next.ServeHTTP(wrapped, r)

                // Record metrics
                duration := time.Since(start)
                method := r.Method
                endpoint := r.URL.Path
                statusCode := strconv.Itoa(wrapped.statusCode)

                // Update Prometheus metrics
                apiRequestsTotal.WithLabelValues(method, endpoint, statusCode).Inc()
                apiRequestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())

                // Log structured request
                requestID := h.getRequestIDFromContext(r)
                logger.LogAPIRequest(requestID, method, endpoint, wrapped.statusCode, duration)

                // Log metrics collection
                logger.LogMetricsCollection("api_request", duration.Seconds(), map[string]string{
                        "method":      method,
                        "endpoint":    endpoint,
                        "status_code": statusCode,
                })
        }</span>)
}

// RecordBulkOperation records metrics for bulk operations
func RecordBulkOperation(operation string, total, succeeded, failed int, duration time.Duration, requestID string) <span class="cov8" title="1">{
        // Calculate success rate
        successRate := float64(succeeded) / float64(total) * 100

        // Update Prometheus metrics
        bulkOperationDuration.WithLabelValues(operation).Observe(duration.Seconds())
        bulkOperationContainers.WithLabelValues(operation).Observe(float64(total))
        bulkOperationSuccessRate.WithLabelValues(operation).Set(successRate)

        // Log structured bulk operation
        logger.LogBulkOperation(operation, total, succeeded, failed, duration, requestID)

        // Log metrics collection
        logger.LogMetricsCollection("bulk_operation", duration.Seconds(), map[string]string{
                "operation":    operation,
                "total":        strconv.Itoa(total),
                "succeeded":    strconv.Itoa(succeeded),
                "failed":       strconv.Itoa(failed),
                "success_rate": strconv.FormatFloat(successRate, 'f', 2, 64),
        })
}</span>

// RecordWebSocketConnection records WebSocket connection metrics
func RecordWebSocketConnection(endpoint, event string, connectionCount int) <span class="cov0" title="0">{
        switch event </span>{
        case "connect":<span class="cov0" title="0">
                websocketConnections.WithLabelValues(endpoint).Inc()</span>
        case "disconnect":<span class="cov0" title="0">
                websocketConnections.WithLabelValues(endpoint).Dec()</span>
        }

        // Generate client ID for logging (simplified)
        <span class="cov0" title="0">clientID := "client_" + strconv.Itoa(int(time.Now().Unix()))

        // Log structured WebSocket event
        logger.LogWebSocketConnection(endpoint, event, clientID, connectionCount)

        // Log metrics collection
        logger.LogMetricsCollection("websocket_connection", float64(connectionCount), map[string]string{
                "endpoint": endpoint,
                "event":    event,
        })</span>
}

// RecordWebSocketMessage records WebSocket message metrics
func RecordWebSocketMessage(endpoint, messageType string) <span class="cov0" title="0">{
        websocketMessagesTotal.WithLabelValues(endpoint, messageType).Inc()

        // Log metrics collection
        logger.LogMetricsCollection("websocket_message", 1, map[string]string{
                "endpoint":     endpoint,
                "message_type": messageType,
        })
}</span>

// RecordHealthCheck records health check metrics
func RecordHealthCheck(status string, dependencies map[string]string, duration time.Duration, requestID string) <span class="cov8" title="1">{
        // Record overall duration
        healthCheckDuration.Observe(duration.Seconds())

        // Record dependency statuses
        for dep, depStatus := range dependencies </span><span class="cov8" title="1">{
                if depStatus == "healthy" </span><span class="cov0" title="0">{
                        healthCheckStatus.WithLabelValues(dep).Set(1)
                }</span> else<span class="cov8" title="1"> {
                        healthCheckStatus.WithLabelValues(dep).Set(0)
                }</span>
        }

        // Log structured health check
        <span class="cov8" title="1">logger.LogHealthCheck(status, dependencies, duration, requestID)

        // Log metrics collection
        logger.LogMetricsCollection("health_check", duration.Seconds(), map[string]string{
                "status": status,
        })</span>
}

// RecordConfigLoad records configuration loading metrics
func RecordConfigLoad(configType, path string, success bool, errorMsg string) <span class="cov0" title="0">{
        status := "success"
        if !success </span><span class="cov0" title="0">{
                status = "error"
        }</span>

        <span class="cov0" title="0">configLoadTotal.WithLabelValues(configType, status).Inc()

        // Log structured config load
        logger.LogConfigLoad(configType, path, success, errorMsg)

        // Log metrics collection
        logger.LogMetricsCollection("config_load", 1, map[string]string{
                "config_type": configType,
                "status":      status,
        })</span>
}

// RecordValidationError records validation error metrics
func RecordValidationError(component, operation, requestID, errorMsg string) <span class="cov0" title="0">{
        validationErrorsTotal.WithLabelValues(component, operation).Inc()

        // Log structured validation error
        logger.LogValidationError(component, operation, requestID, errorMsg)

        // Log metrics collection
        logger.LogMetricsCollection("validation_error", 1, map[string]string{
                "component": component,
                "operation": operation,
        })
}</span>

// handleMetrics serves Prometheus metrics
func (h *HTTPServer) handleMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        // Serve Prometheus metrics
        <span class="cov0" title="0">promhttp.Handler().ServeHTTP(w, r)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "net/http"

        "github.com/domalab/uma/daemon/services/auth"
)

// Auth returns a middleware that handles authentication
func Auth(authService *auth.AuthService) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                if authService != nil &amp;&amp; authService.IsEnabled() </span><span class="cov0" title="0">{
                        return authService.AuthMiddleware(next)
                }</span>
                <span class="cov0" title="0">return next</span>
        }
}

// AuthWithConfig returns an authentication middleware with custom configuration
func AuthWithConfig(authService *auth.AuthService, config AuthConfig) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Skip authentication for excluded paths
                        if shouldSkipAuth(r.URL.Path, config.ExcludedPaths) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Skip authentication for certain methods if configured
                        <span class="cov0" title="0">if shouldSkipAuthForMethod(r.Method, config.ExcludedMethods) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Use auth service if available and enabled
                        <span class="cov0" title="0">if authService != nil &amp;&amp; authService.IsEnabled() </span><span class="cov0" title="0">{
                                authService.AuthMiddleware(next).ServeHTTP(w, r)
                                return
                        }</span>

                        // If auth is required but service is not available, deny access
                        <span class="cov0" title="0">if config.RequireAuth </span><span class="cov0" title="0">{
                                http.Error(w, "Authentication required", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// AuthConfig represents authentication middleware configuration
type AuthConfig struct {
        RequireAuth      bool     `json:"require_auth"`
        ExcludedPaths    []string `json:"excluded_paths"`
        ExcludedMethods  []string `json:"excluded_methods"`
        TokenHeader      string   `json:"token_header"`
        TokenPrefix      string   `json:"token_prefix"`
}

// DefaultAuthConfig returns a default authentication configuration
func DefaultAuthConfig() AuthConfig <span class="cov0" title="0">{
        return AuthConfig{
                RequireAuth: false, // Default to optional auth for backward compatibility
                ExcludedPaths: []string{
                        "/api/v1/health",
                        "/api/v1/docs",
                        "/api/v1/openapi.json",
                        "/api/v1/auth/login",
                        "/metrics",
                },
                ExcludedMethods: []string{
                        "OPTIONS",
                },
                TokenHeader: "Authorization",
                TokenPrefix: "Bearer ",
        }
}</span>

// shouldSkipAuth determines if authentication should be skipped for a path
func shouldSkipAuth(path string, excludedPaths []string) bool <span class="cov0" title="0">{
        for _, excludedPath := range excludedPaths </span><span class="cov0" title="0">{
                if path == excludedPath || (len(excludedPath) &gt; 0 &amp;&amp; excludedPath[len(excludedPath)-1] == '/' &amp;&amp; 
                        len(path) &gt; len(excludedPath) &amp;&amp; path[:len(excludedPath)] == excludedPath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// shouldSkipAuthForMethod determines if authentication should be skipped for a method
func shouldSkipAuthForMethod(method string, excludedMethods []string) bool <span class="cov0" title="0">{
        for _, excludedMethod := range excludedMethods </span><span class="cov0" title="0">{
                if method == excludedMethod </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RequireAuth returns a middleware that requires authentication
func RequireAuth(authService *auth.AuthService) func(http.Handler) http.Handler <span class="cov0" title="0">{
        config := DefaultAuthConfig()
        config.RequireAuth = true
        return AuthWithConfig(authService, config)
}</span>

// OptionalAuth returns a middleware that allows optional authentication
func OptionalAuth(authService *auth.AuthService) func(http.Handler) http.Handler <span class="cov0" title="0">{
        config := DefaultAuthConfig()
        config.RequireAuth = false
        return AuthWithConfig(authService, config)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "bufio"
        "compress/gzip"
        "fmt"
        "io"
        "net"
        "net/http"
        "strings"
)

// Compression returns a middleware that adds gzip compression for large responses
func Compression() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return CompressionWithConfig(DefaultCompressionConfig())
}</span>

// CompressionWithConfig returns a compression middleware with custom configuration
func CompressionWithConfig(config CompressionConfig) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Check if client accepts gzip encoding
                        if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Only compress responses for certain endpoints or large responses
                        <span class="cov8" title="1">shouldCompress := shouldCompressResponse(r, config)
                        if !shouldCompress </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Create gzip writer
                        <span class="cov0" title="0">gz := gzip.NewWriter(w)
                        defer gz.Close()

                        // Set compression headers
                        w.Header().Set("Content-Encoding", "gzip")
                        w.Header().Set("Vary", "Accept-Encoding")

                        // Wrap response writer
                        gzw := &amp;gzipResponseWriter{
                                ResponseWriter: w,
                                Writer:         gz,
                        }

                        next.ServeHTTP(gzw, r)</span>
                })
        }
}

// CompressionConfig represents compression middleware configuration
type CompressionConfig struct {
        Level             int      `json:"level"`              // Compression level (1-9)
        MinLength         int      `json:"min_length"`         // Minimum response length to compress
        CompressiblePaths []string `json:"compressible_paths"` // Paths that should be compressed
        CompressibleTypes []string `json:"compressible_types"` // Content types that should be compressed
        ExcludedPaths     []string `json:"excluded_paths"`     // Paths that should not be compressed
        ExcludedTypes     []string `json:"excluded_types"`     // Content types that should not be compressed
}

// DefaultCompressionConfig returns a default compression configuration
func DefaultCompressionConfig() CompressionConfig <span class="cov8" title="1">{
        return CompressionConfig{
                Level:     gzip.DefaultCompression,
                MinLength: 1024, // 1KB minimum
                CompressiblePaths: []string{
                        "/api/v1/storage/disks",
                        "/api/v1/storage/zfs",
                        "/api/v1/docker/containers",
                        "/api/v1/notifications",
                        "/api/v1/openapi.json",
                        "/api/v1/system/resources",
                        "/api/v1/system/logs",
                },
                CompressibleTypes: []string{
                        "application/json",
                        "application/xml",
                        "text/plain",
                        "text/html",
                        "text/css",
                        "text/javascript",
                        "application/javascript",
                },
                ExcludedPaths: []string{
                        "/api/v1/ws/", // WebSocket endpoints
                },
                ExcludedTypes: []string{
                        "image/",
                        "video/",
                        "audio/",
                        "application/octet-stream",
                },
        }
}</span>

// shouldCompressResponse determines if a response should be compressed
func shouldCompressResponse(r *http.Request, config CompressionConfig) bool <span class="cov8" title="1">{
        path := r.URL.Path

        // Check excluded paths first
        for _, excludedPath := range config.ExcludedPaths </span><span class="cov8" title="1">{
                if strings.HasPrefix(path, excludedPath) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check compressible paths
        <span class="cov8" title="1">for _, compressiblePath := range config.CompressiblePaths </span><span class="cov8" title="1">{
                if strings.HasPrefix(path, compressiblePath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check content type if available in request
        <span class="cov8" title="1">contentType := r.Header.Get("Content-Type")
        if contentType != "" </span><span class="cov0" title="0">{
                // Check excluded types
                for _, excludedType := range config.ExcludedTypes </span><span class="cov0" title="0">{
                        if strings.HasPrefix(contentType, excludedType) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                // Check compressible types
                <span class="cov0" title="0">for _, compressibleType := range config.CompressibleTypes </span><span class="cov0" title="0">{
                        if strings.HasPrefix(contentType, compressibleType) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// gzipResponseWriter wraps http.ResponseWriter to compress responses
type gzipResponseWriter struct {
        http.ResponseWriter
        Writer io.Writer
}

func (w *gzipResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return w.Writer.Write(b)
}</span>

func (w *gzipResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        w.ResponseWriter.WriteHeader(code)
}</span>

// Flush implements http.Flusher interface
func (w *gzipResponseWriter) Flush() <span class="cov0" title="0">{
        if flusher, ok := w.ResponseWriter.(http.Flusher); ok </span><span class="cov0" title="0">{
                flusher.Flush()
        }</span>
}

// Hijack implements http.Hijacker interface
func (w *gzipResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        if hijacker, ok := w.ResponseWriter.(http.Hijacker); ok </span><span class="cov0" title="0">{
                return hijacker.Hijack()
        }</span>
        <span class="cov0" title="0">return nil, nil, fmt.Errorf("response writer does not support hijacking")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import "net/http"

// CORS returns a middleware that adds CORS headers to responses
func CORS() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        w.Header().Set("Access-Control-Allow-Origin", "*")
                        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID")

                        if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusOK)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// CORSWithConfig returns a CORS middleware with custom configuration
func CORSWithConfig(config CORSConfig) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        origin := r.Header.Get("Origin")
                        
                        // Set allowed origin
                        if config.AllowAllOrigins </span><span class="cov0" title="0">{
                                w.Header().Set("Access-Control-Allow-Origin", "*")
                        }</span> else<span class="cov0" title="0"> if len(config.AllowedOrigins) &gt; 0 </span><span class="cov0" title="0">{
                                for _, allowedOrigin := range config.AllowedOrigins </span><span class="cov0" title="0">{
                                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                                w.Header().Set("Access-Control-Allow-Origin", origin)
                                                break</span>
                                        }
                                }
                        }

                        // Set allowed methods
                        <span class="cov0" title="0">if len(config.AllowedMethods) &gt; 0 </span><span class="cov0" title="0">{
                                methods := ""
                                for i, method := range config.AllowedMethods </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                methods += ", "
                                        }</span>
                                        <span class="cov0" title="0">methods += method</span>
                                }
                                <span class="cov0" title="0">w.Header().Set("Access-Control-Allow-Methods", methods)</span>
                        }

                        // Set allowed headers
                        <span class="cov0" title="0">if len(config.AllowedHeaders) &gt; 0 </span><span class="cov0" title="0">{
                                headers := ""
                                for i, header := range config.AllowedHeaders </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                headers += ", "
                                        }</span>
                                        <span class="cov0" title="0">headers += header</span>
                                }
                                <span class="cov0" title="0">w.Header().Set("Access-Control-Allow-Headers", headers)</span>
                        }

                        // Set exposed headers
                        <span class="cov0" title="0">if len(config.ExposedHeaders) &gt; 0 </span><span class="cov0" title="0">{
                                headers := ""
                                for i, header := range config.ExposedHeaders </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                headers += ", "
                                        }</span>
                                        <span class="cov0" title="0">headers += header</span>
                                }
                                <span class="cov0" title="0">w.Header().Set("Access-Control-Expose-Headers", headers)</span>
                        }

                        // Set credentials
                        <span class="cov0" title="0">if config.AllowCredentials </span><span class="cov0" title="0">{
                                w.Header().Set("Access-Control-Allow-Credentials", "true")
                        }</span>

                        // Set max age
                        <span class="cov0" title="0">if config.MaxAge &gt; 0 </span><span class="cov0" title="0">{
                                w.Header().Set("Access-Control-Max-Age", string(rune(config.MaxAge)))
                        }</span>

                        <span class="cov0" title="0">if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusOK)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// CORSConfig represents CORS configuration
type CORSConfig struct {
        AllowAllOrigins   bool     `json:"allow_all_origins"`
        AllowedOrigins    []string `json:"allowed_origins"`
        AllowedMethods    []string `json:"allowed_methods"`
        AllowedHeaders    []string `json:"allowed_headers"`
        ExposedHeaders    []string `json:"exposed_headers"`
        AllowCredentials  bool     `json:"allow_credentials"`
        MaxAge            int      `json:"max_age"` // Seconds
}

// DefaultCORSConfig returns a default CORS configuration
func DefaultCORSConfig() CORSConfig <span class="cov0" title="0">{
        return CORSConfig{
                AllowAllOrigins: true,
                AllowedMethods:  []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders:  []string{"Content-Type", "Authorization", "X-Request-ID"},
                ExposedHeaders:  []string{"X-Request-ID", "X-API-Version"},
                MaxAge:          86400, // 24 hours
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "bufio"
        "fmt"
        "net"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/logger"
)

// Logging returns a middleware that logs HTTP requests with structured logging
func Logging() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return LoggingWithConfig(DefaultLoggingConfig())
}</span>

// LoggingWithConfig returns a logging middleware with custom configuration
func LoggingWithConfig(config LoggingConfig) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        // Create a response writer wrapper to capture status code
                        wrapper := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                        next.ServeHTTP(wrapper, r)

                        duration := time.Since(start)
                        requestID := GetRequestIDFromContext(r)

                        // Skip logging for certain paths if configured
                        if shouldSkipLogging(r.URL.Path, config.SkipPaths) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Use structured logging for API requests
                        <span class="cov8" title="1">if config.StructuredLogging </span><span class="cov8" title="1">{
                                logger.LogAPIRequest(requestID, r.Method, r.URL.Path, wrapper.statusCode, duration)
                        }</span>

                        // Log additional context for errors
                        <span class="cov8" title="1">if wrapper.statusCode &gt;= 400 &amp;&amp; config.LogErrors </span><span class="cov0" title="0">{
                                context := map[string]interface{}{
                                        "user_agent":     r.UserAgent(),
                                        "content_type":   r.Header.Get("Content-Type"),
                                        "content_length": r.ContentLength,
                                        "query_params":   r.URL.RawQuery,
                                        "remote_addr":    r.RemoteAddr,
                                }

                                if wrapper.statusCode &gt;= 500 </span><span class="cov0" title="0">{
                                        logger.LogErrorWithContext("api", "http_request",
                                                fmt.Errorf("HTTP %d error for %s %s", wrapper.statusCode, r.Method, r.URL.Path),
                                                requestID, context)
                                }</span>
                        }

                        // Backward compatibility: also log with colored output
                        <span class="cov8" title="1">if config.ColoredOutput </span><span class="cov8" title="1">{
                                if requestID != "" </span><span class="cov0" title="0">{
                                        logger.LightGreen("HTTP %s %s %d %v [%s]", r.Method, r.URL.Path, wrapper.statusCode, duration, requestID)
                                }</span> else<span class="cov8" title="1"> {
                                        logger.LightGreen("HTTP %s %s %d %v", r.Method, r.URL.Path, wrapper.statusCode, duration)
                                }</span>
                        }

                        // Custom logger if provided
                        <span class="cov8" title="1">if config.CustomLogger != nil </span><span class="cov0" title="0">{
                                config.CustomLogger(LogEntry{
                                        RequestID:   requestID,
                                        Method:      r.Method,
                                        Path:        r.URL.Path,
                                        StatusCode:  wrapper.statusCode,
                                        Duration:    duration,
                                        UserAgent:   r.UserAgent(),
                                        RemoteAddr:  r.RemoteAddr,
                                        ContentType: r.Header.Get("Content-Type"),
                                        QueryParams: r.URL.RawQuery,
                                        Timestamp:   start,
                                })
                        }</span>
                })
        }
}

// LoggingConfig represents logging middleware configuration
type LoggingConfig struct {
        StructuredLogging bool           `json:"structured_logging"`
        ColoredOutput     bool           `json:"colored_output"`
        LogErrors         bool           `json:"log_errors"`
        SkipPaths         []string       `json:"skip_paths"`
        CustomLogger      func(LogEntry) `json:"-"`
}

// LogEntry represents a log entry for HTTP requests
type LogEntry struct {
        RequestID   string        `json:"request_id"`
        Method      string        `json:"method"`
        Path        string        `json:"path"`
        StatusCode  int           `json:"status_code"`
        Duration    time.Duration `json:"duration"`
        UserAgent   string        `json:"user_agent"`
        RemoteAddr  string        `json:"remote_addr"`
        ContentType string        `json:"content_type"`
        QueryParams string        `json:"query_params"`
        Timestamp   time.Time     `json:"timestamp"`
}

// DefaultLoggingConfig returns a default logging configuration
func DefaultLoggingConfig() LoggingConfig <span class="cov8" title="1">{
        return LoggingConfig{
                StructuredLogging: true,
                ColoredOutput:     true,
                LogErrors:         true,
                SkipPaths: []string{
                        "/health",
                        "/metrics",
                        "/favicon.ico",
                },
                CustomLogger: nil,
        }
}</span>

// shouldSkipLogging determines if logging should be skipped for a path
func shouldSkipLogging(path string, skipPaths []string) bool <span class="cov8" title="1">{
        for _, skipPath := range skipPaths </span><span class="cov8" title="1">{
                if path == skipPath </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return rw.ResponseWriter.Write(b)
}</span>

// Flush implements http.Flusher interface
func (rw *responseWriter) Flush() <span class="cov0" title="0">{
        if flusher, ok := rw.ResponseWriter.(http.Flusher); ok </span><span class="cov0" title="0">{
                flusher.Flush()
        }</span>
}

// Hijack implements http.Hijacker interface
func (rw *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        if hijacker, ok := rw.ResponseWriter.(http.Hijacker); ok </span><span class="cov0" title="0">{
                return hijacker.Hijack()
        }</span>
        <span class="cov0" title="0">return nil, nil, fmt.Errorf("response writer does not support hijacking")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        // HTTP request metrics
        httpRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "uma_http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status_code"},
        )

        httpRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "uma_http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint", "status_code"},
        )

        httpRequestsInFlight = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "uma_http_requests_in_flight",
                        Help: "Number of HTTP requests currently being processed",
                },
        )

        httpRequestSize = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "uma_http_request_size_bytes",
                        Help:    "HTTP request size in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"method", "endpoint"},
        )

        httpResponseSize = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "uma_http_response_size_bytes",
                        Help:    "HTTP response size in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"method", "endpoint", "status_code"},
        )
)

// Metrics returns a middleware that collects HTTP metrics
func Metrics() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return MetricsWithConfig(DefaultMetricsConfig())
}</span>

// MetricsWithConfig returns a metrics middleware with custom configuration
func MetricsWithConfig(config MetricsConfig) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Skip metrics collection for certain paths if configured
                        if shouldSkipMetrics(r.URL.Path, config.SkipPaths) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov8" title="1">start := time.Now()
                        httpRequestsInFlight.Inc()
                        defer httpRequestsInFlight.Dec()

                        // Normalize endpoint for metrics (remove IDs, etc.)
                        endpoint := normalizeEndpoint(r.URL.Path, config.EndpointNormalization)

                        // Record request size
                        if r.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                                httpRequestSize.WithLabelValues(r.Method, endpoint).Observe(float64(r.ContentLength))
                        }</span>

                        // Create a response writer wrapper to capture status code and response size
                        <span class="cov8" title="1">wrapper := &amp;metricsResponseWriter{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK,
                                responseSize:   0,
                        }

                        next.ServeHTTP(wrapper, r)

                        duration := time.Since(start)
                        statusCode := strconv.Itoa(wrapper.statusCode)

                        // Record metrics
                        httpRequestsTotal.WithLabelValues(r.Method, endpoint, statusCode).Inc()
                        httpRequestDuration.WithLabelValues(r.Method, endpoint, statusCode).Observe(duration.Seconds())

                        if wrapper.responseSize &gt; 0 </span><span class="cov8" title="1">{
                                httpResponseSize.WithLabelValues(r.Method, endpoint, statusCode).Observe(float64(wrapper.responseSize))
                        }</span>
                })
        }
}

// MetricsConfig represents metrics middleware configuration
type MetricsConfig struct {
        SkipPaths             []string          `json:"skip_paths"`
        EndpointNormalization map[string]string `json:"endpoint_normalization"`
        CustomLabels          map[string]string `json:"custom_labels"`
}

// DefaultMetricsConfig returns a default metrics configuration
func DefaultMetricsConfig() MetricsConfig <span class="cov8" title="1">{
        return MetricsConfig{
                SkipPaths: []string{
                        "/metrics",
                        "/favicon.ico",
                },
                EndpointNormalization: map[string]string{
                        // Normalize endpoints with IDs
                        "/api/v1/docker/containers/": "/api/v1/docker/containers/{id}",
                        "/api/v1/vms/":               "/api/v1/vms/{name}",
                        "/api/v1/operations/":        "/api/v1/operations/{id}",
                },
                CustomLabels: map[string]string{
                        "service": "uma",
                },
        }
}</span>

// shouldSkipMetrics determines if metrics collection should be skipped for a path
func shouldSkipMetrics(path string, skipPaths []string) bool <span class="cov8" title="1">{
        for _, skipPath := range skipPaths </span><span class="cov8" title="1">{
                if path == skipPath </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// normalizeEndpoint normalizes endpoint paths for consistent metrics
func normalizeEndpoint(path string, normalization map[string]string) string <span class="cov8" title="1">{
        for pattern, normalized := range normalization </span><span class="cov8" title="1">{
                if len(path) &gt; len(pattern) &amp;&amp; path[:len(pattern)] == pattern </span><span class="cov0" title="0">{
                        return normalized
                }</span>
        }
        <span class="cov8" title="1">return path</span>
}

// metricsResponseWriter wraps http.ResponseWriter to capture metrics
type metricsResponseWriter struct {
        http.ResponseWriter
        statusCode   int
        responseSize int
}

func (mrw *metricsResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        mrw.statusCode = code
        mrw.ResponseWriter.WriteHeader(code)
}</span>

func (mrw *metricsResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        size, err := mrw.ResponseWriter.Write(b)
        mrw.responseSize += size
        return size, err
}</span>

// RecordCustomMetric records a custom metric with labels
func RecordCustomMetric(name string, value float64, labels map[string]string) {<span class="cov0" title="0">
        // This would be implemented based on specific metric requirements
        // For now, it's a placeholder for custom metrics
}</span>

// GetMetricsHandler returns the Prometheus metrics handler
func GetMetricsHandler() http.Handler <span class="cov8" title="1">{
        return promhttp.Handler()
}</span>

// RegisterCustomMetrics allows registration of custom metrics
func RegisterCustomMetrics(collectors ...prometheus.Collector) error <span class="cov0" title="0">{
        for _, collector := range collectors </span><span class="cov0" title="0">{
                if err := prometheus.Register(collector); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "context"
        "net/http"

        "github.com/google/uuid"
)

// Context key types for type safety
type contextKey string

const (
        RequestIDKey contextKey = "request_id"
)

// RequestID returns a middleware that adds request ID tracking for debugging and tracing
func RequestID() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Check if request already has an ID from client
                        requestID := r.Header.Get("X-Request-ID")

                        // Generate a new request ID if not provided
                        if requestID == "" </span><span class="cov8" title="1">{
                                requestID = generateRequestID()
                        }</span>

                        // Set the request ID in response headers
                        <span class="cov8" title="1">w.Header().Set("X-Request-ID", requestID)

                        // Add request ID to request context for use in handlers
                        ctx := context.WithValue(r.Context(), RequestIDKey, requestID)
                        r = r.WithContext(ctx)

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// RequestIDWithConfig returns a request ID middleware with custom configuration
func RequestIDWithConfig(config RequestIDConfig) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        var requestID string

                        // Check if request already has an ID from client
                        if config.AllowClientRequestID </span><span class="cov0" title="0">{
                                requestID = r.Header.Get(config.RequestIDHeader)
                        }</span>

                        // Generate a new request ID if not provided or not allowed
                        <span class="cov0" title="0">if requestID == "" </span><span class="cov0" title="0">{
                                if config.Generator != nil </span><span class="cov0" title="0">{
                                        requestID = config.Generator()
                                }</span> else<span class="cov0" title="0"> {
                                        requestID = generateRequestID()
                                }</span>
                        }

                        // Validate request ID format if validator is provided
                        <span class="cov0" title="0">if config.Validator != nil &amp;&amp; !config.Validator(requestID) </span><span class="cov0" title="0">{
                                requestID = generateRequestID()
                        }</span>

                        // Set the request ID in response headers
                        <span class="cov0" title="0">w.Header().Set(config.ResponseIDHeader, requestID)

                        // Add request ID to request context for use in handlers
                        ctx := context.WithValue(r.Context(), config.ContextKey, requestID)
                        r = r.WithContext(ctx)

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// RequestIDConfig represents request ID middleware configuration
type RequestIDConfig struct {
        AllowClientRequestID bool                    `json:"allow_client_request_id"`
        RequestIDHeader      string                  `json:"request_id_header"`
        ResponseIDHeader     string                  `json:"response_id_header"`
        ContextKey           contextKey              `json:"-"`
        Generator            func() string           `json:"-"`
        Validator            func(string) bool       `json:"-"`
}

// DefaultRequestIDConfig returns a default request ID configuration
func DefaultRequestIDConfig() RequestIDConfig <span class="cov0" title="0">{
        return RequestIDConfig{
                AllowClientRequestID: true,
                RequestIDHeader:      "X-Request-ID",
                ResponseIDHeader:     "X-Request-ID",
                ContextKey:           RequestIDKey,
                Generator:            generateRequestID,
                Validator:            nil, // No validation by default
        }
}</span>

// generateRequestID creates a unique request ID for tracing using UUID
func generateRequestID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>

// GetRequestIDFromContext gets the request ID from request context
func GetRequestIDFromContext(r *http.Request) string <span class="cov8" title="1">{
        if requestID, ok := r.Context().Value(RequestIDKey).(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetRequestIDFromContextWithKey gets the request ID from request context using a custom key
func GetRequestIDFromContextWithKey(r *http.Request, key contextKey) string <span class="cov0" title="0">{
        if requestID, ok := r.Context().Value(key).(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "context"
        "net/http"
        "regexp"
        "strings"
)

// Context key for API version
const (
        APIVersionKey contextKey = "api_version"
)

// Versioning returns a middleware that handles API version negotiation
func Versioning() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return VersioningWithConfig(DefaultVersioningConfig())
}</span>

// VersioningWithConfig returns a versioning middleware with custom configuration
func VersioningWithConfig(config VersioningConfig) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Parse Accept header for version negotiation
                        acceptHeader := r.Header.Get("Accept")
                        apiVersion := parseAPIVersion(acceptHeader, config)

                        // Set the negotiated version in request context
                        ctx := context.WithValue(r.Context(), APIVersionKey, apiVersion)
                        r = r.WithContext(ctx)

                        // Set version information in response headers
                        w.Header().Set("X-API-Version", apiVersion)
                        w.Header().Set("X-API-Supported-Versions", strings.Join(config.SupportedVersions, ", "))

                        // Add deprecation warning if version is deprecated
                        if isVersionDeprecated(apiVersion, config.DeprecatedVersions) </span><span class="cov0" title="0">{
                                w.Header().Set("X-API-Deprecation-Warning", "This API version is deprecated")
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// VersioningConfig represents versioning middleware configuration
type VersioningConfig struct {
        DefaultVersion      string   `json:"default_version"`
        SupportedVersions   []string `json:"supported_versions"`
        DeprecatedVersions  []string `json:"deprecated_versions"`
        HeaderName          string   `json:"header_name"`
        AcceptHeaderPattern string   `json:"accept_header_pattern"`
}

// DefaultVersioningConfig returns a default versioning configuration
func DefaultVersioningConfig() VersioningConfig <span class="cov8" title="1">{
        return VersioningConfig{
                DefaultVersion:      "v1",
                SupportedVersions:   []string{"v1"},
                DeprecatedVersions:  []string{},
                HeaderName:          "X-API-Version",
                AcceptHeaderPattern: `application/vnd\.uma\.([^+]+)\+json`,
        }
}</span>

// parseAPIVersion extracts API version from Accept header
func parseAPIVersion(acceptHeader string, config VersioningConfig) string <span class="cov8" title="1">{
        if acceptHeader == "" </span><span class="cov8" title="1">{
                return config.DefaultVersion
        }</span>

        // Try to match the versioned media type pattern
        <span class="cov8" title="1">re := regexp.MustCompile(config.AcceptHeaderPattern)
        matches := re.FindStringSubmatch(acceptHeader)
        
        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                version := matches[1]
                // Check if the version is supported
                for _, supportedVersion := range config.SupportedVersions </span><span class="cov8" title="1">{
                        if version == supportedVersion </span><span class="cov8" title="1">{
                                return version
                        }</span>
                }
        }

        // Check for simple version patterns like "v1", "v2"
        <span class="cov8" title="1">versionPattern := regexp.MustCompile(`v(\d+)`)
        matches = versionPattern.FindStringSubmatch(acceptHeader)
        if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                version := matches[0]
                for _, supportedVersion := range config.SupportedVersions </span><span class="cov0" title="0">{
                        if version == supportedVersion </span><span class="cov0" title="0">{
                                return version
                        }</span>
                }
        }

        <span class="cov8" title="1">return config.DefaultVersion</span>
}

// isVersionDeprecated checks if a version is deprecated
func isVersionDeprecated(version string, deprecatedVersions []string) bool <span class="cov8" title="1">{
        for _, deprecatedVersion := range deprecatedVersions </span><span class="cov0" title="0">{
                if version == deprecatedVersion </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetAPIVersionFromContext gets the API version from request context
func GetAPIVersionFromContext(r *http.Request) string <span class="cov0" title="0">{
        if version, ok := r.Context().Value(APIVersionKey).(string); ok </span><span class="cov0" title="0">{
                return version
        }</span>
        <span class="cov0" title="0">return "v1"</span> // Default fallback
}

// VersionedHandler represents a handler for a specific API version
type VersionedHandler struct {
        Version string
        Handler http.HandlerFunc
}

// VersionRouter routes requests to different handlers based on API version
type VersionRouter struct {
        handlers map[string]http.HandlerFunc
        fallback http.HandlerFunc
}

// NewVersionRouter creates a new version router
func NewVersionRouter() *VersionRouter <span class="cov0" title="0">{
        return &amp;VersionRouter{
                handlers: make(map[string]http.HandlerFunc),
        }
}</span>

// AddHandler adds a handler for a specific version
func (vr *VersionRouter) AddHandler(version string, handler http.HandlerFunc) <span class="cov0" title="0">{
        vr.handlers[version] = handler
}</span>

// SetFallback sets the fallback handler for unsupported versions
func (vr *VersionRouter) SetFallback(handler http.HandlerFunc) <span class="cov0" title="0">{
        vr.fallback = handler
}</span>

// ServeHTTP implements http.Handler interface
func (vr *VersionRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        version := GetAPIVersionFromContext(r)
        
        if handler, exists := vr.handlers[version]; exists </span><span class="cov0" title="0">{
                handler.ServeHTTP(w, r)
                return
        }</span>
        
        <span class="cov0" title="0">if vr.fallback != nil </span><span class="cov0" title="0">{
                vr.fallback.ServeHTTP(w, r)
                return
        }</span>
        
        // No handler found and no fallback
        <span class="cov0" title="0">http.Error(w, "Unsupported API version", http.StatusNotAcceptable)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/domalab/uma/daemon/services/api/openapi"
)

// Legacy type aliases for backward compatibility
type OpenAPISpec = openapi.OpenAPISpec
type OpenAPIInfo = openapi.OpenAPIInfo
type OpenAPIContact = openapi.OpenAPIContact
type OpenAPIServer = openapi.OpenAPIServer
type OpenAPIComponents = openapi.OpenAPIComponents

// generateOpenAPISpec creates the complete OpenAPI specification using the new modular structure
func (h *HTTPServer) generateOpenAPISpec() *OpenAPISpec <span class="cov8" title="1">{
        // Create configuration for the OpenAPI generator
        config := &amp;openapi.Config{
                Version:     h.getAPIVersion(),
                Port:        h.api.ctx.Config.HTTPServer.Port,
                BaseURL:     "",
                Environment: "prod",
                Features: openapi.FeatureFlags{
                        Authentication: true,
                        BulkOperations: true,
                        WebSockets:     true,
                        Metrics:        true,
                        ZFS:            true,
                        ArrayControl:   true,
                        VMManagement:   true,
                },
        }

        // Create generator and generate specification
        generator := openapi.NewGenerator(config)
        return generator.Generate()
}</span>

// getAPIVersion returns the API version with fallback
func (h *HTTPServer) getAPIVersion() string <span class="cov8" title="1">{
        version := h.api.ctx.Config.Version
        if version == "" || version == "unknown" </span><span class="cov0" title="0">{
                version = "2025.06.16" // Current plugin version
        }</span>
        <span class="cov8" title="1">return version</span>
}

// OpenAPIHandler serves the OpenAPI specification
func (h *HTTPServer) OpenAPIHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        spec := h.generateOpenAPISpec()

        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov8" title="1">if err := writeJSON(w, spec); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate OpenAPI specification", http.StatusInternalServerError)
                return
        }</span>
}

// SwaggerUIHandler serves the Swagger UI documentation
func (h *HTTPServer) SwaggerUIHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        html := `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;UMA REST API Documentation&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@5.10.5/swagger-ui.css" /&gt;
    &lt;style&gt;
        html {
            box-sizing: border-box;
            overflow: -moz-scrollbars-vertical;
            overflow-y: scroll;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }
        body {
            margin:0;
            background: #fafafa;
        }
        .swagger-ui .topbar {
            background-color: #2c3e50;
        }
        .swagger-ui .topbar .download-url-wrapper .select-label {
            color: #ffffff;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@5.10.5/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@5.10.5/swagger-ui-standalone-preset.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() {
            const ui = SwaggerUIBundle({
                url: '/api/v1/openapi.json',
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                tryItOutEnabled: true,
                requestInterceptor: function(request) {
                    // Add any custom headers or authentication here
                    return request;
                },
                responseInterceptor: function(response) {
                    // Handle responses here if needed
                    return response;
                }
            });
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`

        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")

        w.WriteHeader(http.StatusOK)
        w.Write([]byte(html))
}</span>

// HealthHandler provides a health check endpoint
func (h *HTTPServer) HealthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Create a simple health response
        health := map[string]interface{}{
                "status":    "healthy",
                "version":   h.getAPIVersion(),
                "service":   "uma",
                "timestamp": fmt.Sprintf("%d", r.Context().Value("timestamp")),
                "dependencies": map[string]interface{}{
                        "docker":     "available", // This would be checked dynamically
                        "unraid_api": "available",
                        "apcupsd":    "available",
                },
                "uptime": 0, // This would be calculated dynamically
        }

        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Cache-Control", "no-cache")

        if err := writeJSON(w, health); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate health response", http.StatusInternalServerError)
                return
        }</span>
}

// GetOpenAPIStats returns statistics about the OpenAPI specification
func (h *HTTPServer) GetOpenAPIStats() map[string]interface{} <span class="cov0" title="0">{
        config := &amp;openapi.Config{
                Version:     h.getAPIVersion(),
                Port:        h.api.ctx.Config.HTTPServer.Port,
                BaseURL:     "",
                Environment: "prod",
                Features: openapi.FeatureFlags{
                        Authentication: true,
                        BulkOperations: true,
                        WebSockets:     true,
                        Metrics:        true,
                        ZFS:            true,
                        ArrayControl:   true,
                        VMManagement:   true,
                },
        }

        generator := openapi.NewGenerator(config)
        return generator.GetStats()
}</span>

// ValidateOpenAPISpec validates the generated OpenAPI specification
func (h *HTTPServer) ValidateOpenAPISpec() []string <span class="cov0" title="0">{
        config := &amp;openapi.Config{
                Version:     h.getAPIVersion(),
                Port:        h.api.ctx.Config.HTTPServer.Port,
                BaseURL:     "",
                Environment: "prod",
                Features: openapi.FeatureFlags{
                        Authentication: true,
                        BulkOperations: true,
                        WebSockets:     true,
                        Metrics:        true,
                        ZFS:            true,
                        ArrayControl:   true,
                        VMManagement:   true,
                },
        }

        generator := openapi.NewGenerator(config)
        return generator.ValidateSpec()
}</span>

// writeJSON is a helper function to write JSON responses
func writeJSON(w http.ResponseWriter, data interface{}) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(data)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package openapi

import "fmt"

// Config holds configuration for OpenAPI spec generation
type Config struct {
        Version     string
        Port        int
        BaseURL     string
        Environment string // dev, staging, prod
        Features    FeatureFlags
}

// FeatureFlags controls which API features are included in the spec
type FeatureFlags struct {
        Authentication bool
        BulkOperations bool
        WebSockets     bool
        Metrics        bool
        ZFS            bool
        ArrayControl   bool
        VMManagement   bool
}

// DefaultConfig returns a default configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Version:     "2025.06.16",
                Port:        34600,
                BaseURL:     "",
                Environment: "prod",
                Features: FeatureFlags{
                        Authentication: true,
                        BulkOperations: true,
                        WebSockets:     true,
                        Metrics:        true,
                        ZFS:            true,
                        ArrayControl:   true,
                        VMManagement:   true,
                },
        }
}</span>

// GetServers returns the server configurations for the OpenAPI spec
func (c *Config) GetServers() []OpenAPIServer <span class="cov0" title="0">{
        servers := []OpenAPIServer{
                {
                        URL:         fmt.Sprintf("http://localhost:%d", c.Port),
                        Description: "Local UMA API server",
                },
        }

        if c.Environment == "prod" </span><span class="cov0" title="0">{
                servers = append(servers, OpenAPIServer{
                        URL:         "http://your-unraid-server:34600",
                        Description: "Remote UMA API server (replace with your server IP)",
                })
        }</span>

        <span class="cov0" title="0">if c.BaseURL != "" </span><span class="cov0" title="0">{
                servers = append(servers, OpenAPIServer{
                        URL:         c.BaseURL,
                        Description: "Custom UMA API server",
                })
        }</span>

        <span class="cov0" title="0">return servers</span>
}

// GetSecuritySchemes returns the security schemes for the OpenAPI spec
func (c *Config) GetSecuritySchemes() map[string]interface{} <span class="cov0" title="0">{
        schemes := make(map[string]interface{})

        if c.Features.Authentication </span><span class="cov0" title="0">{
                schemes["BearerAuth"] = map[string]interface{}{
                        "type":         "http",
                        "scheme":       "bearer",
                        "bearerFormat": "JWT",
                        "description":  "JWT token obtained from /api/v1/auth/login",
                }
                schemes["ApiKeyAuth"] = map[string]interface{}{
                        "type":        "apiKey",
                        "in":          "header",
                        "name":        "X-API-Key",
                        "description": "API key for authentication",
                }
        }</span>

        <span class="cov0" title="0">return schemes</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package openapi

import (
        "github.com/domalab/uma/daemon/services/api/openapi/paths"
        "github.com/domalab/uma/daemon/services/api/openapi/responses"
        "github.com/domalab/uma/daemon/services/api/openapi/schemas"
)

// Generator coordinates all OpenAPI modules and generates the complete specification
type Generator struct {
        config         *Config
        schemaRegistry *schemas.Registry
}

// NewGenerator creates a new OpenAPI generator with the given configuration
func NewGenerator(config *Config) *Generator <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        <span class="cov0" title="0">registry := schemas.NewRegistry()
        registry.RegisterAll()

        return &amp;Generator{
                config:         config,
                schemaRegistry: registry,
        }</span>
}

// Generate creates the complete OpenAPI specification
func (g *Generator) Generate() *OpenAPISpec <span class="cov0" title="0">{
        spec := &amp;OpenAPISpec{
                OpenAPI:    "3.1.1",
                Info:       GenerateInfo(g.config),
                Servers:    g.config.GetServers(),
                Paths:      g.generatePaths(),
                Components: g.generateComponents(),
        }

        return spec
}</span>

// generatePaths combines all path definitions from different modules
func (g *Generator) generatePaths() map[string]interface{} <span class="cov0" title="0">{
        allPaths := make(map[string]interface{})

        // Add Docker paths
        for path, definition := range paths.GetDockerPaths() </span><span class="cov0" title="0">{
                allPaths[path] = definition
        }</span>

        // Add System paths
        <span class="cov0" title="0">for path, definition := range paths.GetSystemPaths() </span><span class="cov0" title="0">{
                allPaths[path] = definition
        }</span>

        // Add Storage paths (if feature enabled)
        <span class="cov0" title="0">if g.config.Features.ArrayControl </span><span class="cov0" title="0">{
                for path, definition := range paths.GetStoragePaths() </span><span class="cov0" title="0">{
                        allPaths[path] = definition
                }</span>
        }

        // Add VM paths (if feature enabled)
        <span class="cov0" title="0">if g.config.Features.VMManagement </span><span class="cov0" title="0">{
                for path, definition := range paths.GetVMPaths() </span><span class="cov0" title="0">{
                        allPaths[path] = definition
                }</span>
        }

        // Add Authentication paths (if feature enabled)
        <span class="cov0" title="0">if g.config.Features.Authentication </span><span class="cov0" title="0">{
                for path, definition := range paths.GetAuthPaths() </span><span class="cov0" title="0">{
                        allPaths[path] = definition
                }</span>
        }

        // Add WebSocket paths (if feature enabled)
        <span class="cov0" title="0">if g.config.Features.WebSockets </span><span class="cov0" title="0">{
                for path, definition := range paths.GetWebSocketPaths() </span><span class="cov0" title="0">{
                        allPaths[path] = definition
                }</span>
        }

        // Add async operations paths
        <span class="cov0" title="0">for path, definition := range paths.AsyncOperationsPaths() </span><span class="cov0" title="0">{
                allPaths[path] = definition
        }</span>

        // Add rate limiting paths
        <span class="cov0" title="0">for path, definition := range paths.RateLimitingPaths() </span><span class="cov0" title="0">{
                allPaths[path] = definition
        }</span>

        // Add health check and documentation paths
        <span class="cov0" title="0">allPaths["/api/v1/health"] = g.getHealthPath()
        allPaths["/api/v1/docs"] = g.getDocsPath()
        allPaths["/api/v1/openapi.json"] = g.getOpenAPIPath()

        return allPaths</span>
}

// generateComponents combines all component definitions
func (g *Generator) generateComponents() OpenAPIComponents <span class="cov0" title="0">{
        return OpenAPIComponents{
                Schemas:         g.schemaRegistry.GetAllSchemas(),
                Responses:       responses.GetCommonResponses(),
                SecuritySchemes: g.config.GetSecuritySchemes(),
        }
}</span>

// getHealthPath returns the health check endpoint definition
func (g *Generator) getHealthPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Health check",
                        "description": "Check the health status of the UMA API service and its dependencies",
                        "operationId": "healthCheck",
                        "tags":        []string{"Monitoring"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Service is healthy",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/HealthResponse",
                                                        },
                                                },
                                        },
                                },
                                "503": map[string]interface{}{
                                        "description": "Service is unhealthy",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/HealthResponse",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// getDocsPath returns the Swagger UI documentation endpoint
func (g *Generator) getDocsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "API Documentation",
                        "description": "Interactive Swagger UI documentation for the UMA REST API",
                        "operationId": "getDocumentation",
                        "tags":        []string{"Documentation"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Swagger UI HTML page",
                                        "content": map[string]interface{}{
                                                "text/html": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "type": "string",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// getOpenAPIPath returns the OpenAPI specification endpoint
func (g *Generator) getOpenAPIPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "OpenAPI Specification",
                        "description": "Get the complete OpenAPI 3.1.1 specification for the UMA REST API",
                        "operationId": "getOpenAPISpec",
                        "tags":        []string{"Documentation"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "OpenAPI specification in JSON format",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "type": "object",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetSchemaRegistry returns the schema registry for external access
func (g *Generator) GetSchemaRegistry() *schemas.Registry <span class="cov0" title="0">{
        return g.schemaRegistry
}</span>

// GetConfig returns the generator configuration
func (g *Generator) GetConfig() *Config <span class="cov0" title="0">{
        return g.config
}</span>

// UpdateConfig updates the generator configuration
func (g *Generator) UpdateConfig(config *Config) <span class="cov0" title="0">{
        g.config = config
}</span>

// ValidateSpec performs basic validation on the generated specification
func (g *Generator) ValidateSpec() []string <span class="cov0" title="0">{
        var errors []string
        spec := g.Generate()

        // Check required fields
        if spec.OpenAPI == "" </span><span class="cov0" title="0">{
                errors = append(errors, "OpenAPI version is required")
        }</span>

        <span class="cov0" title="0">if spec.Info.Title == "" </span><span class="cov0" title="0">{
                errors = append(errors, "API title is required")
        }</span>

        <span class="cov0" title="0">if spec.Info.Version == "" </span><span class="cov0" title="0">{
                errors = append(errors, "API version is required")
        }</span>

        <span class="cov0" title="0">if len(spec.Paths) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, "At least one path is required")
        }</span>

        // Check for required schemas
        <span class="cov0" title="0">requiredSchemas := []string{"Error", "SuccessResponse", "StandardResponse"}
        for _, schemaName := range requiredSchemas </span><span class="cov0" title="0">{
                if !g.schemaRegistry.HasSchema(schemaName) </span><span class="cov0" title="0">{
                        errors = append(errors, "Required schema missing: "+schemaName)
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// GetStats returns statistics about the generated specification
func (g *Generator) GetStats() map[string]interface{} <span class="cov0" title="0">{
        spec := g.Generate()
        schemasByCategory := g.schemaRegistry.GetSchemasByCategory()

        stats := map[string]interface{}{
                "openapi_version": spec.OpenAPI,
                "api_version":     spec.Info.Version,
                "total_paths":     len(spec.Paths),
                "total_schemas":   len(spec.Components.Schemas),
                "total_responses": len(spec.Components.Responses),
                "schemas_by_category": map[string]interface{}{
                        "common":    len(schemasByCategory["Common"]),
                        "docker":    len(schemasByCategory["Docker"]),
                        "system":    len(schemasByCategory["System"]),
                        "storage":   len(schemasByCategory["Storage"]),
                        "vm":        len(schemasByCategory["VM"]),
                        "websocket": len(schemasByCategory["WebSocket"]),
                        "auth":      len(schemasByCategory["Auth"]),
                },
                "features_enabled": map[string]interface{}{
                        "authentication":  g.config.Features.Authentication,
                        "bulk_operations": g.config.Features.BulkOperations,
                        "websockets":      g.config.Features.WebSockets,
                        "metrics":         g.config.Features.Metrics,
                        "zfs":             g.config.Features.ZFS,
                        "array_control":   g.config.Features.ArrayControl,
                        "vm_management":   g.config.Features.VMManagement,
                },
        }

        return stats
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package openapi

// GenerateInfo creates the OpenAPI info section
func GenerateInfo(config *Config) OpenAPIInfo <span class="cov0" title="0">{
        version := config.Version
        if version == "" || version == "unknown" </span><span class="cov0" title="0">{
                version = "2025.06.17"
        }</span>

        <span class="cov0" title="0">return OpenAPIInfo{
                Title: "UMA REST API",
                Description: `Unraid Management Agent API providing 100% functionality coverage for comprehensive server management.

## Features

### System Monitoring
- **Hardware Monitoring**: CPU usage, RAM utilization, temperatures, fan speeds
- **Real-time Metrics**: Live system statistics with WebSocket updates
- **GPU Monitoring**: Graphics card status and utilization
- **Network Monitoring**: Interface statistics and connectivity status

### Storage Management
- **Array Management**: Unraid array start/stop with proper orchestration
- **Disk Monitoring**: Individual disk health, SMART data, temperatures
- **Cache Management**: Cache disk status and performance metrics
- **ZFS Support**: ZFS pool monitoring and management
- **Parity Operations**: Parity check status and scheduling

### Container &amp; VM Control
- **Docker Management**: Individual and bulk container operations (start/stop/restart/pause)
- **VM Lifecycle**: Virtual machine control and monitoring
- **Resource Monitoring**: Container and VM resource usage

### UPS &amp; Power Management
- **UPS Integration**: Real hardware integration with apcupsd daemon
- **Power Control**: System shutdown and reboot capabilities
- **Battery Monitoring**: UPS battery status, runtime, and load information

### System Control
- **User Scripts**: Execute custom Unraid user scripts
- **Log Management**: System log access and monitoring
- **Command Execution**: Secure command execution with proper validation

### Real-time Updates
- **WebSocket Support**: Live updates for system stats, Docker events, and storage status
- **Event Streaming**: Real-time notifications for system changes

## Architecture

Built with optimized HTTP mux architecture for production deployment on Unraid servers. Designed for reliability, performance, and comprehensive monitoring capabilities.

## Authentication

Supports JWT-based authentication and API key authentication for secure access control.`,
                Version: version,
                Contact: OpenAPIContact{
                        Name:  "UMA Development Team",
                        URL:   "https://github.com/domalab/uma",
                        Email: "ruaan.deysel@gmail.com",
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package parameters

// GetCommonParameters returns all common reusable parameters
func GetCommonParameters() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "PageParameter":        GetPageParameter(),
                "LimitParameter":       GetLimitParameter(),
                "RequestIDParameter":   GetRequestIDParameter(),
                "ContainerIDParameter": GetContainerIDParameter(),
                "VMIDParameter":        GetVMIDParameter(),
                "DiskIDParameter":      GetDiskIDParameter(),
                "AllContainersParameter": GetAllContainersParameter(),
                "ForceParameter":       GetForceParameter(),
                "TimeoutParameter":     GetTimeoutParameter(),
                "VerboseParameter":     GetVerboseParameter(),
        }
}</span>

// Pagination parameters
func GetPaginationParameters() []interface{} <span class="cov0" title="0">{
        return []interface{}{
                GetPageParameter(),
                GetLimitParameter(),
        }
}</span>

func GetPageParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "page",
                "in":          "query",
                "description": "Page number for pagination (1-based)",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "integer",
                        "minimum": 1,
                        "default": 1,
                        "example": 1,
                },
        }
}</span>

func GetLimitParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "limit",
                "in":          "query",
                "description": "Number of items per page",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "integer",
                        "minimum": 1,
                        "maximum": 1000,
                        "default": 50,
                        "example": 50,
                },
        }
}</span>

// Request tracking parameters
func GetRequestIDParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "X-Request-ID",
                "in":          "header",
                "description": "Optional request ID for tracing and debugging",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "pattern": "^[a-zA-Z0-9-_]{1,64}$",
                        "example": "req_1234567890_5678",
                },
        }
}</span>

// Resource ID parameters
func GetContainerIDParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "id",
                "in":          "path",
                "description": "Container ID or name",
                "required":    true,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "pattern": "^[a-zA-Z0-9][a-zA-Z0-9_.-]+$",
                        "example": "plex",
                },
        }
}</span>

func GetVMIDParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "id",
                "in":          "path",
                "description": "Virtual machine ID or name",
                "required":    true,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "pattern": "^[a-zA-Z0-9][a-zA-Z0-9_.-]+$",
                        "example": "Windows-10-Gaming",
                },
        }
}</span>

func GetDiskIDParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "id",
                "in":          "path",
                "description": "Disk identifier (e.g., disk1, parity, cache)",
                "required":    true,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "pattern": "^(disk|parity|cache)\\d*$",
                        "example": "disk1",
                },
        }
}</span>

// Query parameters
func GetAllContainersParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "all",
                "in":          "query",
                "description": "Include stopped containers in the response",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "boolean",
                        "default": false,
                        "example": false,
                },
        }
}</span>

func GetForceParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "force",
                "in":          "query",
                "description": "Force the operation (use with caution)",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "boolean",
                        "default": false,
                        "example": false,
                },
        }
}</span>

func GetTimeoutParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "timeout",
                "in":          "query",
                "description": "Operation timeout in seconds",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "integer",
                        "minimum": 1,
                        "maximum": 300,
                        "default": 30,
                        "example": 30,
                },
        }
}</span>

func GetVerboseParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "verbose",
                "in":          "query",
                "description": "Include detailed information in the response",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "boolean",
                        "default": false,
                        "example": false,
                },
        }
}</span>

// Filter parameters
func GetStatusFilterParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "status",
                "in":          "query",
                "description": "Filter by status",
                "required":    false,
                "schema": map[string]interface{}{
                        "type": "array",
                        "items": map[string]interface{}{
                                "type": "string",
                        },
                        "example": []string{"running", "stopped"},
                },
        }
}</span>

func GetSinceParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "since",
                "in":          "query",
                "description": "Show data since timestamp (ISO 8601 format)",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "format":  "date-time",
                        "example": "2025-06-16T14:30:00Z",
                },
        }
}</span>

func GetUntilParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "until",
                "in":          "query",
                "description": "Show data until timestamp (ISO 8601 format)",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "format":  "date-time",
                        "example": "2025-06-16T15:30:00Z",
                },
        }
}</span>

// Content negotiation parameters
func GetAcceptParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "Accept",
                "in":          "header",
                "description": "Preferred response content type",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "string",
                        "enum":    []string{"application/json", "application/vnd.uma.v1+json"},
                        "default": "application/json",
                        "example": "application/vnd.uma.v1+json",
                },
        }
}</span>

// System-specific parameters
func GetLogLevelParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "level",
                "in":          "query",
                "description": "Filter logs by level",
                "required":    false,
                "schema": map[string]interface{}{
                        "type": "array",
                        "items": map[string]interface{}{
                                "type": "string",
                                "enum": []string{"debug", "info", "warn", "error", "fatal"},
                        },
                        "example": []string{"error", "fatal"},
                },
        }
}</span>

func GetLogLinesParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "lines",
                "in":          "query",
                "description": "Number of log lines to return",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "integer",
                        "minimum": 1,
                        "maximum": 10000,
                        "default": 100,
                        "example": 100,
                },
        }
}</span>

// Storage-specific parameters
func GetSMARTParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "smart",
                "in":          "query",
                "description": "Include SMART data in disk information",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "boolean",
                        "default": false,
                        "example": true,
                },
        }
}</span>

func GetTemperatureParameter() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":        "temperature",
                "in":          "query",
                "description": "Include temperature data",
                "required":    false,
                "schema": map[string]interface{}{
                        "type":    "boolean",
                        "default": false,
                        "example": true,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package paths

import (
        "github.com/domalab/uma/daemon/services/api/openapi/responses"
        "github.com/domalab/uma/daemon/services/api/openapi/schemas"
)

// AsyncOperationsPaths returns OpenAPI path definitions for async operations endpoints
func AsyncOperationsPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/operations": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Async Operations"},
                                "summary":     "List async operations",
                                "description": "Retrieve a list of asynchronous operations with optional filtering",
                                "parameters": []map[string]interface{}{
                                        {
                                                "name":        "status",
                                                "in":          "query",
                                                "description": "Filter operations by status",
                                                "required":    false,
                                                "schema": map[string]interface{}{
                                                        "type": "string",
                                                        "enum": []string{"pending", "running", "completed", "failed", "cancelled"},
                                                },
                                        },
                                        {
                                                "name":        "type",
                                                "in":          "query",
                                                "description": "Filter operations by operation type",
                                                "required":    false,
                                                "schema": map[string]interface{}{
                                                        "type": "string",
                                                        "enum": []string{
                                                                "parity_check", "parity_correct", "array_start", "array_stop",
                                                                "disk_scan", "smart_scan", "system_reboot", "system_shutdown",
                                                                "bulk_container", "bulk_vm",
                                                        },
                                                },
                                        },
                                },
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "List of operations retrieved successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetAsyncOperationListResponse(),
                                                        },
                                                },
                                        },
                                        "429": responses.RateLimitExceeded(),
                                        "500": responses.InternalServerError(),
                                },
                        },
                        "post": map[string]interface{}{
                                "tags":        []string{"Async Operations"},
                                "summary":     "Start async operation",
                                "description": "Start a new asynchronous operation",
                                "requestBody": map[string]interface{}{
                                        "required": true,
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": schemas.GetAsyncOperationRequest(),
                                                        "examples": map[string]interface{}{
                                                                "smart_scan": map[string]interface{}{
                                                                        "summary": "SMART data collection",
                                                                        "value": map[string]interface{}{
                                                                                "type":        "smart_scan",
                                                                                "description": "Comprehensive SMART data collection for all disks",
                                                                                "cancellable": true,
                                                                        },
                                                                },
                                                                "parity_check": map[string]interface{}{
                                                                        "summary": "Parity check operation",
                                                                        "value": map[string]interface{}{
                                                                                "type":        "parity_check",
                                                                                "description": "Full parity check of the array",
                                                                                "cancellable": true,
                                                                                "parameters": map[string]interface{}{
                                                                                        "type":     "check",
                                                                                        "priority": "normal",
                                                                                },
                                                                        },
                                                                },
                                                                "bulk_container": map[string]interface{}{
                                                                        "summary": "Bulk container operation",
                                                                        "value": map[string]interface{}{
                                                                                "type":        "bulk_container",
                                                                                "description": "Start multiple Docker containers",
                                                                                "cancellable": false,
                                                                                "parameters": map[string]interface{}{
                                                                                        "container_ids": []string{"container1", "container2"},
                                                                                        "operation":     "start",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "responses": map[string]interface{}{
                                        "201": map[string]interface{}{
                                                "description": "Operation started successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetAsyncOperationResponse(),
                                                        },
                                                },
                                        },
                                        "400": responses.BadRequest(),
                                        "409": responses.Conflict(),
                                        "429": responses.RateLimitExceeded(),
                                },
                        },
                },
                "/api/v1/operations/{operationId}": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Async Operations"},
                                "summary":     "Get operation details",
                                "description": "Retrieve detailed information about a specific operation",
                                "parameters": []map[string]interface{}{
                                        {
                                                "name":        "operationId",
                                                "in":          "path",
                                                "required":    true,
                                                "description": "Unique identifier of the operation",
                                                "schema": map[string]interface{}{
                                                        "type":    "string",
                                                        "format":  "uuid",
                                                        "example": "4a799a05-bb59-42a1-ab3b-d4ccbfdc623f",
                                                },
                                        },
                                },
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Operation details retrieved successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetAsyncOperationDetailResponse(),
                                                        },
                                                },
                                        },
                                        "404": responses.NotFound(),
                                        "429": responses.RateLimitExceeded(),
                                },
                        },
                        "delete": map[string]interface{}{
                                "tags":        []string{"Async Operations"},
                                "summary":     "Cancel operation",
                                "description": "Cancel a running or pending operation (if cancellable)",
                                "parameters": []map[string]interface{}{
                                        {
                                                "name":        "operationId",
                                                "in":          "path",
                                                "required":    true,
                                                "description": "Unique identifier of the operation to cancel",
                                                "schema": map[string]interface{}{
                                                        "type":    "string",
                                                        "format":  "uuid",
                                                        "example": "4a799a05-bb59-42a1-ab3b-d4ccbfdc623f",
                                                },
                                        },
                                },
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Operation cancelled successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetAsyncOperationCancelResponse(),
                                                        },
                                                },
                                        },
                                        "400": responses.BadRequest(),
                                        "404": responses.NotFound(),
                                        "429": responses.RateLimitExceeded(),
                                },
                        },
                },
                "/api/v1/operations/stats": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Async Operations"},
                                "summary":     "Get operation statistics",
                                "description": "Retrieve statistics about async operations",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Operation statistics retrieved successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetAsyncOperationStatsResponse(),
                                                        },
                                                },
                                        },
                                        "429": responses.RateLimitExceeded(),
                                },
                        },
                },
        }
}</span>

// RateLimitingPaths returns OpenAPI path definitions for rate limiting endpoints
func RateLimitingPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/rate-limits/stats": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Rate Limiting"},
                                "summary":     "Get rate limiting statistics",
                                "description": "Retrieve current rate limiting statistics for all operation types and clients",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Rate limiting statistics retrieved successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetRateLimitStatsResponse(),
                                                                "examples": map[string]interface{}{
                                                                        "example_stats": map[string]interface{}{
                                                                                "summary": "Example rate limiting statistics",
                                                                                "value": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "general_rate_limiter": map[string]interface{}{
                                                                                                        "type": "general",
                                                                                                },
                                                                                                "operation_rate_limiter": map[string]interface{}{
                                                                                                        "type":          "operation_specific",
                                                                                                        "total_clients": 3,
                                                                                                        "operation_limits": map[string]interface{}{
                                                                                                                "smart_data": map[string]interface{}{
                                                                                                                        "requests": 1,
                                                                                                                        "window":   "1m0s",
                                                                                                                },
                                                                                                                "parity_check": map[string]interface{}{
                                                                                                                        "requests": 1,
                                                                                                                        "window":   "1h0m0s",
                                                                                                                },
                                                                                                        },
                                                                                                        "client_stats": map[string]interface{}{
                                                                                                                "192.168.1.100": map[string]interface{}{
                                                                                                                        "smart_data": map[string]interface{}{
                                                                                                                                "tokens_remaining": 0,
                                                                                                                                "max_tokens":       1,
                                                                                                                        },
                                                                                                                },
                                                                                                        },
                                                                                                },
                                                                                        },
                                                                                        "meta": map[string]interface{}{
                                                                                                "timestamp":   1640995200,
                                                                                                "api_version": "v1",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                        "429": responses.RateLimitExceeded(),
                                },
                        },
                },
                "/api/v1/rate-limits/config": map[string]interface{}{
                        "get": map[string]interface{}{
                                "tags":        []string{"Rate Limiting"},
                                "summary":     "Get rate limiting configuration",
                                "description": "Retrieve current rate limiting configuration for all operation types",
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Rate limiting configuration retrieved successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetRateLimitConfigResponse(),
                                                        },
                                                },
                                        },
                                        "429": responses.RateLimitExceeded(),
                                },
                        },
                        "put": map[string]interface{}{
                                "tags":        []string{"Rate Limiting"},
                                "summary":     "Update rate limiting configuration",
                                "description": "Update rate limiting configuration for operation types (requires admin privileges)",
                                "requestBody": map[string]interface{}{
                                        "required": true,
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": schemas.GetRateLimitConfigUpdate(),
                                                        "examples": map[string]interface{}{
                                                                "update_smart_data": map[string]interface{}{
                                                                        "summary": "Update SMART data rate limit",
                                                                        "value": map[string]interface{}{
                                                                                "smart_data": map[string]interface{}{
                                                                                        "requests": 2,
                                                                                        "window":   "2m0s",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "responses": map[string]interface{}{
                                        "200": map[string]interface{}{
                                                "description": "Rate limiting configuration updated successfully",
                                                "content": map[string]interface{}{
                                                        "application/json": map[string]interface{}{
                                                                "schema": schemas.GetRateLimitConfigUpdateResponse(),
                                                        },
                                                },
                                        },
                                        "400": responses.BadRequest(),
                                        "401": responses.Unauthorized(),
                                        "403": responses.Forbidden(),
                                        "501": responses.NotImplemented(),
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package paths

// GetAuthPaths returns all authentication API paths
func GetAuthPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/auth/login":    getLoginPath(),
                "/api/v1/auth/logout":   getLogoutPath(),
                "/api/v1/auth/refresh":  getRefreshPath(),
                "/api/v1/auth/me":       getUserInfoPath(),
                "/api/v1/auth/sessions": getSessionsPath(),
                "/api/v1/auth/apikeys":  getAPIKeysPath(),
        }
}</span>

func getLoginPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "User login",
                        "description": "Authenticate user and obtain JWT tokens",
                        "operationId": "login",
                        "tags":        []string{"Authentication"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/LoginRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Login successful",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/LoginResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "429": map[string]interface{}{"$ref": "#/components/responses/TooManyRequests"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                },
        }
}</span>

func getRefreshPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Refresh token",
                        "description": "Refresh JWT access token using refresh token",
                        "operationId": "refreshToken",
                        "tags":        []string{"Authentication"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/RefreshRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Token refreshed successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/TokenResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                },
        }
}</span>

func getLogoutPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "User logout",
                        "description": "Logout user and invalidate session",
                        "operationId": "logout",
                        "tags":        []string{"Authentication"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Logout successful",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/SuccessResponse",
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                        },
                },
        }
}</span>

func getUserInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get current user information",
                        "description": "Retrieve information about the currently authenticated user",
                        "operationId": "getCurrentUser",
                        "tags":        []string{"Authentication"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "User information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/UserInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSessionsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List user sessions",
                        "description": "Retrieve a list of active user sessions",
                        "operationId": "listSessions",
                        "tags":        []string{"Authentication"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Sessions retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/SessionInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                        },
                },
        }
}</span>

func getAPIKeysPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List API keys",
                        "description": "Retrieve a list of API keys for the current user",
                        "operationId": "listAPIKeys",
                        "tags":        []string{"Authentication"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "API keys retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/APIKeyInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package paths

// GetDockerPaths returns all Docker-related API paths
func GetDockerPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/docker/containers":              getContainersListPath(),
                "/api/v1/docker/containers/{id}":         getContainerByIDPath(),
                "/api/v1/docker/containers/{id}/start":   getContainerStartPath(),
                "/api/v1/docker/containers/{id}/stop":    getContainerStopPath(),
                "/api/v1/docker/containers/{id}/restart": getContainerRestartPath(),
                "/api/v1/docker/containers/{id}/pause":   getContainerPausePath(),
                "/api/v1/docker/containers/{id}/resume":  getContainerResumePath(),
                "/api/v1/docker/containers/bulk/start":   getBulkContainerStartPath(),
                "/api/v1/docker/containers/bulk/stop":    getBulkContainerStopPath(),
                "/api/v1/docker/containers/bulk/restart": getBulkContainerRestartPath(),
                "/api/v1/docker/containers/bulk/pause":   getBulkContainerPausePath(),
                "/api/v1/docker/containers/bulk/resume":  getBulkContainerResumePath(),
                "/api/v1/docker/images":                  getImagesListPath(),
                "/api/v1/docker/networks":                getNetworksListPath(),
                "/api/v1/docker/info":                    getDockerInfoPath(),
        }
}</span>

func getContainersListPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List Docker containers",
                        "description": "Retrieve a list of Docker containers with optional filtering and pagination",
                        "operationId": "listContainers",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/PageParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/LimitParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/AllContainersParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/StatusFilterParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/VerboseParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "List of containers retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/ContainerInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getContainerByIDPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get container information",
                        "description": "Retrieve detailed information about a specific Docker container",
                        "operationId": "getContainer",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ContainerIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/VerboseParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Container information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/ContainerInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getContainerStartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Start container",
                        "description": "Start a Docker container",
                        "operationId": "startContainer",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ContainerIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Container started successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ContainerOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getContainerStopPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Stop container",
                        "description": "Stop a Docker container gracefully or forcefully",
                        "operationId": "stopContainer",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ContainerIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/ForceParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Container stopped successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ContainerOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getContainerRestartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Restart container",
                        "description": "Restart a Docker container",
                        "operationId": "restartContainer",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ContainerIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Container restarted successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ContainerOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getContainerPausePath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Pause container",
                        "description": "Pause a running Docker container",
                        "operationId": "pauseContainer",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ContainerIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Container paused successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ContainerOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getContainerResumePath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Resume container",
                        "description": "Resume a paused Docker container",
                        "operationId": "resumeContainer",
                        "tags":        []string{"Docker"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ContainerIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Container resumed successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ContainerOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkContainerStartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Start multiple containers",
                        "description": "Start multiple Docker containers in a single operation",
                        "operationId": "bulkStartContainers",
                        "tags":        []string{"Docker"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkOperationRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk start operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkContainerStopPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Stop multiple containers",
                        "description": "Stop multiple Docker containers in a single operation",
                        "operationId": "bulkStopContainers",
                        "tags":        []string{"Docker"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkOperationRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk stop operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkContainerRestartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Restart multiple containers",
                        "description": "Restart multiple Docker containers in a single operation",
                        "operationId": "bulkRestartContainers",
                        "tags":        []string{"Docker"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkOperationRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk restart operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkContainerPausePath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Pause multiple containers",
                        "description": "Pause multiple Docker containers in a single operation",
                        "operationId": "bulkPauseContainers",
                        "tags":        []string{"Docker"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkOperationRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk pause operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkContainerResumePath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Resume multiple containers",
                        "description": "Resume multiple paused Docker containers in a single operation",
                        "operationId": "bulkResumeContainers",
                        "tags":        []string{"Docker"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkOperationRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk resume operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getImagesListPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List Docker images",
                        "description": "Retrieve a list of Docker images",
                        "operationId": "listImages",
                        "tags":        []string{"Docker"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "List of images retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/DockerImage",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getNetworksListPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List Docker networks",
                        "description": "Retrieve a list of Docker networks",
                        "operationId": "listNetworks",
                        "tags":        []string{"Docker"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "List of networks retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/DockerNetwork",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getDockerInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get Docker information",
                        "description": "Retrieve Docker daemon information and statistics",
                        "operationId": "getDockerInfo",
                        "tags":        []string{"Docker"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Docker information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/DockerInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package paths

// GetStoragePaths returns all storage management API paths
func GetStoragePaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/storage/array":        getArrayInfoPath(),
                "/api/v1/storage/array/start":  getArrayStartPath(),
                "/api/v1/storage/array/stop":   getArrayStopPath(),
                "/api/v1/storage/disks":        getDisksListPath(),
                "/api/v1/storage/disks/{id}":   getDiskByIDPath(),
                "/api/v1/storage/parity":       getParityInfoPath(),
                "/api/v1/storage/parity/check": getParityCheckPath(),
                "/api/v1/storage/cache":        getCacheInfoPath(),
                "/api/v1/storage/zfs/pools":    getZFSPoolsPath(),
                "/api/v1/storage/zfs/datasets": getZFSDatasetsPath(),
                "/api/v1/storage/overview":     getStorageOverviewPath(),
                "/api/v1/storage/temperatures": getDiskTemperaturesPath(),
        }
}</span>

func getArrayInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get array information",
                        "description": "Retrieve Unraid array status, state, disk count, and usage information",
                        "operationId": "getArrayInfo",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Array information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/ArrayInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getArrayStartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Start Unraid array",
                        "description": "Start the Unraid array with proper orchestration sequence",
                        "operationId": "startArray",
                        "tags":        []string{"Storage"},
                        "requestBody": map[string]interface{}{
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/ArrayOperation",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Array start operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ArrayStatus",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getArrayStopPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Stop Unraid array",
                        "description": "Stop the Unraid array with proper orchestration sequence (Docker stop  VM stop  unmount shares  unmount disks  stop parity  mdadm stop)",
                        "operationId": "stopArray",
                        "tags":        []string{"Storage"},
                        "requestBody": map[string]interface{}{
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/ArrayOperation",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Array stop operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ArrayStatus",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getDisksListPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List storage disks",
                        "description": "Retrieve information about all storage disks including data disks, parity disks, and cache disks",
                        "operationId": "listDisks",
                        "tags":        []string{"Storage"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/SMARTParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TemperatureParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/VerboseParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Disk list retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/DiskInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getDiskByIDPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get disk information",
                        "description": "Retrieve detailed information about a specific disk including SMART data and temperature",
                        "operationId": "getDisk",
                        "tags":        []string{"Storage"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/DiskIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/SMARTParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TemperatureParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Disk information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/DiskInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getStorageOverviewPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get storage overview",
                        "description": "Retrieve comprehensive storage overview including array, parity, cache, disks, and ZFS pools",
                        "operationId": "getStorageOverview",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Storage overview retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/StorageOverview",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getParityInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get parity information",
                        "description": "Retrieve parity disk information and check status",
                        "operationId": "getParityInfo",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Parity information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/ParityInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getParityCheckPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get parity check status",
                        "description": "Retrieve current parity check status and progress",
                        "operationId": "getParityCheck",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Parity check status retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/ParityCheckInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getCacheInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get cache information",
                        "description": "Retrieve cache pool information and disk status",
                        "operationId": "getCacheInfo",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Cache information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/CacheInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getZFSPoolsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List ZFS pools",
                        "description": "Retrieve a list of ZFS pools with status and health information",
                        "operationId": "listZFSPools",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "ZFS pools retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/ZFSPoolInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getZFSDatasetsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List ZFS datasets",
                        "description": "Retrieve a list of ZFS datasets with usage information",
                        "operationId": "listZFSDatasets",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "ZFS datasets retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/ZFSDatasetInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getDiskTemperaturesPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get disk temperatures",
                        "description": "Retrieve temperature information for all storage disks",
                        "operationId": "getDiskTemperatures",
                        "tags":        []string{"Storage"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Disk temperatures retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/DiskTemperature",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package paths

// GetSystemPaths returns all system monitoring and control API paths
func GetSystemPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/system/info":         getSystemInfoPath(),
                "/api/v1/system/cpu":          getCPUInfoPath(),
                "/api/v1/system/memory":       getMemoryInfoPath(),
                "/api/v1/system/temperatures": getTemperaturesPath(),
                "/api/v1/system/fans":         getFansPath(),
                "/api/v1/system/gpu":          getGPUInfoPath(),
                "/api/v1/system/ups":          getUPSInfoPath(),
                "/api/v1/system/network":      getNetworkInfoPath(),
                "/api/v1/system/resources":    getSystemResourcesPath(),
                "/api/v1/system/filesystems":  getFilesystemsPath(),
                "/api/v1/system/scripts":      getSystemScriptsPath(),
                "/api/v1/system/scripts/{id}": getSystemScriptPath(),
                "/api/v1/system/execute":      getExecuteCommandPath(),
                "/api/v1/system/logs":         getSystemLogsPath(),
                "/api/v1/system/shutdown":     getSystemShutdownPath(),
                "/api/v1/system/reboot":       getSystemRebootPath(),
        }
}</span>

func getSystemInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get system information",
                        "description": "Retrieve general system information including hostname, kernel, uptime, and load average",
                        "operationId": "getSystemInfo",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "System information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/SystemInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getCPUInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get CPU information",
                        "description": "Retrieve CPU usage, core count, model, frequency, and temperature information",
                        "operationId": "getCPUInfo",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "CPU information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/CPUInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getMemoryInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get memory information",
                        "description": "Retrieve memory usage, total, available, buffers, cached, and swap information",
                        "operationId": "getMemoryInfo",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Memory information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/MemoryInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getTemperaturesPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get temperature sensors",
                        "description": "Retrieve temperature data from all available sensors including CPU, motherboard, and other components",
                        "operationId": "getTemperatures",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Temperature data retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/TemperatureData",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getFansPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get fan information",
                        "description": "Retrieve fan speed data from all available fan sensors",
                        "operationId": "getFans",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Fan data retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/FanData",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getUPSInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get UPS information",
                        "description": "Retrieve UPS status, battery charge, runtime, load, and voltage information from apcupsd daemon",
                        "operationId": "getUPSInfo",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "UPS information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/UPSInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                                "503": map[string]interface{}{"$ref": "#/components/responses/ServiceUnavailable"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSystemShutdownPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Shutdown system",
                        "description": "Initiate system shutdown with optional delay and message",
                        "operationId": "shutdownSystem",
                        "tags":        []string{"System"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ForceParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "202": map[string]interface{}{"$ref": "#/components/responses/Accepted"},
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getGPUInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get GPU information",
                        "description": "Retrieve GPU information and statistics",
                        "operationId": "getGPUInfo",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "GPU information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/GPUInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getNetworkInfoPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get network information",
                        "description": "Retrieve network interface information and statistics",
                        "operationId": "getNetworkInfo",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Network information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/NetworkInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSystemResourcesPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get system resources",
                        "description": "Retrieve comprehensive system resource information",
                        "operationId": "getSystemResources",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "System resources retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/SystemResources",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getFilesystemsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get filesystem information",
                        "description": "Retrieve filesystem mount points and usage information",
                        "operationId": "getFilesystems",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Filesystem information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/FilesystemInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSystemScriptsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List system scripts",
                        "description": "Retrieve a list of available system scripts",
                        "operationId": "listSystemScripts",
                        "tags":        []string{"System"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "System scripts retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/SystemScript",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSystemScriptPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get system script details",
                        "description": "Retrieve details about a specific system script",
                        "operationId": "getSystemScript",
                        "tags":        []string{"System"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ScriptIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "System script details retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/SystemScript",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
                "post": map[string]interface{}{
                        "summary":     "Execute system script",
                        "description": "Execute a specific system script with optional parameters",
                        "operationId": "executeSystemScript",
                        "tags":        []string{"System"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ScriptIDParameter"},
                        },
                        "requestBody": map[string]interface{}{
                                "required": false,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/ScriptExecutionRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Script executed successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/ScriptExecutionResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getExecuteCommandPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Execute system command",
                        "description": "Execute a system command with optional parameters and timeout",
                        "operationId": "executeCommand",
                        "tags":        []string{"System"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/CommandExecutionRequest",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Command executed successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/CommandExecutionResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSystemLogsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get system logs",
                        "description": "Retrieve system logs with optional filtering and pagination",
                        "operationId": "getSystemLogs",
                        "tags":        []string{"System"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/PageParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/LimitParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/LogLevelParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/LogSourceParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/SinceParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "System logs retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/LogEntry",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getSystemRebootPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Reboot system",
                        "description": "Initiate system reboot with optional delay and message",
                        "operationId": "rebootSystem",
                        "tags":        []string{"System"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/ForceParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "202": map[string]interface{}{"$ref": "#/components/responses/Accepted"},
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package paths

// GetVMPaths returns all virtual machine management API paths
func GetVMPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/vms":              getVMsListPath(),
                "/api/v1/vms/{id}":         getVMByIDPath(),
                "/api/v1/vms/{id}/start":   getVMStartPath(),
                "/api/v1/vms/{id}/stop":    getVMStopPath(),
                "/api/v1/vms/{id}/restart": getVMRestartPath(),
                "/api/v1/vms/{id}/pause":   getVMPausePath(),
                "/api/v1/vms/{id}/resume":  getVMResumePath(),
                "/api/v1/vms/{id}/stats":   getVMStatsPath(),
                "/api/v1/vms/bulk/start":   getBulkVMStartPath(),
                "/api/v1/vms/bulk/stop":    getBulkVMStopPath(),
                "/api/v1/vms/bulk/restart": getBulkVMRestartPath(),
        }
}</span>

func getVMsListPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List virtual machines",
                        "description": "Retrieve a list of virtual machines with their current state and configuration",
                        "operationId": "listVMs",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/PageParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/LimitParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/StatusFilterParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/VerboseParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "List of VMs retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/VMInfo",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMStartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Start virtual machine",
                        "description": "Start a virtual machine",
                        "operationId": "startVM",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM started successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/VMOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkVMStartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Start multiple virtual machines",
                        "description": "Start multiple virtual machines in a single operation",
                        "operationId": "bulkStartVMs",
                        "tags":        []string{"Virtual Machines"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkVMOperation",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk VM start operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkVMResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMByIDPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get virtual machine information",
                        "description": "Retrieve detailed information about a specific virtual machine",
                        "operationId": "getVM",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/VerboseParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM information retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/VMInfo",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMStopPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Stop virtual machine",
                        "description": "Stop a virtual machine gracefully or forcefully",
                        "operationId": "stopVM",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/ForceParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM stopped successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/VMOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMRestartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Restart virtual machine",
                        "description": "Restart a virtual machine",
                        "operationId": "restartVM",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                                map[string]interface{}{"$ref": "#/components/parameters/TimeoutParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM restarted successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/VMOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMPausePath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Pause virtual machine",
                        "description": "Pause a running virtual machine",
                        "operationId": "pauseVM",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM paused successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/VMOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMResumePath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Resume virtual machine",
                        "description": "Resume a paused virtual machine",
                        "operationId": "resumeVM",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM resumed successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/VMOperationResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "409": map[string]interface{}{"$ref": "#/components/responses/Conflict"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getVMStatsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get virtual machine statistics",
                        "description": "Retrieve performance statistics for a specific virtual machine",
                        "operationId": "getVMStats",
                        "tags":        []string{"Virtual Machines"},
                        "parameters": []interface{}{
                                map[string]interface{}{"$ref": "#/components/parameters/VMIDParameter"},
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "VM statistics retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/VMStats",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "404": map[string]interface{}{"$ref": "#/components/responses/NotFound"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkVMStopPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Stop multiple virtual machines",
                        "description": "Stop multiple virtual machines in a single operation",
                        "operationId": "bulkStopVMs",
                        "tags":        []string{"Virtual Machines"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkVMOperation",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk VM stop operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkVMResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getBulkVMRestartPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "post": map[string]interface{}{
                        "summary":     "Restart multiple virtual machines",
                        "description": "Restart multiple virtual machines in a single operation",
                        "operationId": "bulkRestartVMs",
                        "tags":        []string{"Virtual Machines"},
                        "requestBody": map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": "#/components/schemas/BulkVMOperation",
                                                },
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Bulk VM restart operation completed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/BulkVMResponse",
                                                        },
                                                },
                                        },
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "403": map[string]interface{}{"$ref": "#/components/responses/Forbidden"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package paths

// GetWebSocketPaths returns all WebSocket API paths
func GetWebSocketPaths() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "/api/v1/ws":          getWebSocketPath(),
                "/api/v1/ws/stats":    getWebSocketStatsPath(),
                "/api/v1/ws/channels": getWebSocketChannelsPath(),
        }
}</span>

func getWebSocketPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "WebSocket connection",
                        "description": "Establish WebSocket connection for real-time updates",
                        "operationId": "connectWebSocket",
                        "tags":        []string{"WebSocket"},
                        "parameters": []interface{}{
                                map[string]interface{}{
                                        "name":        "Upgrade",
                                        "in":          "header",
                                        "description": "WebSocket upgrade header",
                                        "required":    true,
                                        "schema": map[string]interface{}{
                                                "type": "string",
                                                "enum": []string{"websocket"},
                                        },
                                },
                                map[string]interface{}{
                                        "name":        "Connection",
                                        "in":          "header",
                                        "description": "Connection upgrade header",
                                        "required":    true,
                                        "schema": map[string]interface{}{
                                                "type": "string",
                                                "enum": []string{"Upgrade"},
                                        },
                                },
                                map[string]interface{}{
                                        "name":        "Sec-WebSocket-Key",
                                        "in":          "header",
                                        "description": "WebSocket key for handshake",
                                        "required":    true,
                                        "schema": map[string]interface{}{
                                                "type": "string",
                                        },
                                },
                        },
                        "responses": map[string]interface{}{
                                "101": map[string]interface{}{
                                        "description": "Switching Protocols - WebSocket connection established",
                                },
                                "400": map[string]interface{}{"$ref": "#/components/responses/BadRequest"},
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "426": map[string]interface{}{
                                        "description": "Upgrade Required - Invalid WebSocket upgrade request",
                                },
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getWebSocketStatsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "Get WebSocket statistics",
                        "description": "Retrieve WebSocket server statistics including connections, subscriptions, and message counts",
                        "operationId": "getWebSocketStats",
                        "tags":        []string{"WebSocket"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "WebSocket statistics retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "$ref": "#/components/schemas/WebSocketStats",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>

func getWebSocketChannelsPath() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "get": map[string]interface{}{
                        "summary":     "List WebSocket channels",
                        "description": "Retrieve a list of available WebSocket channels for real-time updates",
                        "operationId": "listWebSocketChannels",
                        "tags":        []string{"WebSocket"},
                        "responses": map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "WebSocket channels retrieved successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "allOf": []interface{}{
                                                                        map[string]interface{}{"$ref": "#/components/schemas/StandardResponse"},
                                                                        map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "data": map[string]interface{}{
                                                                                                "type": "array",
                                                                                                "items": map[string]interface{}{
                                                                                                        "$ref": "#/components/schemas/WebSocketChannel",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{"$ref": "#/components/responses/Unauthorized"},
                                "500": map[string]interface{}{"$ref": "#/components/responses/InternalServerError"},
                        },
                        "security": []map[string][]string{
                                {"BearerAuth": {}},
                                {"ApiKeyAuth": {}},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package responses

// GetCommonResponses returns all common reusable responses
func GetCommonResponses() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "BadRequest":          getBadRequestResponse(),
                "Unauthorized":        getUnauthorizedResponse(),
                "Forbidden":           getForbiddenResponse(),
                "NotFound":            getNotFoundResponse(),
                "Conflict":            getConflictResponse(),
                "UnprocessableEntity": getUnprocessableEntityResponse(),
                "TooManyRequests":     getTooManyRequestsResponse(),
                "InternalServerError": getInternalServerErrorResponse(),
                "ServiceUnavailable":  getServiceUnavailableResponse(),
                "Success":             getSuccessResponse(),
                "Created":             getCreatedResponse(),
                "Accepted":            getAcceptedResponse(),
                "NoContent":           getNoContentResponse(),
        }
}</span>

func getBadRequestResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Bad Request - Invalid request parameters or malformed request",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "validation_error": map[string]interface{}{
                                                "summary": "Validation Error",
                                                "value": map[string]interface{}{
                                                        "error": "Invalid request parameters",
                                                        "code":  "VALIDATION_ERROR",
                                                        "details": map[string]interface{}{
                                                                "field":   "container_ids",
                                                                "message": "must contain at least 1 item",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                        "malformed_json": map[string]interface{}{
                                                "summary": "Malformed JSON",
                                                "value": map[string]interface{}{
                                                        "error": "Invalid JSON in request body",
                                                        "code":  "MALFORMED_JSON",
                                                        "details": map[string]interface{}{
                                                                "line":   5,
                                                                "column": 12,
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                        "missing_parameter": map[string]interface{}{
                                                "summary": "Missing Required Parameter",
                                                "value": map[string]interface{}{
                                                        "error": "Missing required parameter",
                                                        "code":  "MISSING_PARAMETER",
                                                        "details": map[string]interface{}{
                                                                "parameter": "operation",
                                                                "location":  "request body",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getUnauthorizedResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Unauthorized - Authentication required or invalid credentials",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/AuthError",
                                },
                                "examples": map[string]interface{}{
                                        "missing_token": map[string]interface{}{
                                                "summary": "Missing Authentication Token",
                                                "value": map[string]interface{}{
                                                        "error":      "Authentication required",
                                                        "error_code": "TOKEN_MISSING",
                                                        "details": map[string]interface{}{
                                                                "message": "Authorization header is required",
                                                        },
                                                        "timestamp": "2025-06-16T14:30:00Z",
                                                },
                                        },
                                        "invalid_token": map[string]interface{}{
                                                "summary": "Invalid Token",
                                                "value": map[string]interface{}{
                                                        "error":      "Invalid authentication token",
                                                        "error_code": "TOKEN_INVALID",
                                                        "details": map[string]interface{}{
                                                                "message": "Token signature verification failed",
                                                        },
                                                        "timestamp": "2025-06-16T14:30:00Z",
                                                },
                                        },
                                        "expired_token": map[string]interface{}{
                                                "summary": "Expired Token",
                                                "value": map[string]interface{}{
                                                        "error":      "Authentication token has expired",
                                                        "error_code": "TOKEN_EXPIRED",
                                                        "details": map[string]interface{}{
                                                                "expired_at": "2025-06-16T13:30:00Z",
                                                        },
                                                        "timestamp": "2025-06-16T14:30:00Z",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getForbiddenResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Forbidden - Insufficient permissions for the requested operation",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/AuthError",
                                },
                                "examples": map[string]interface{}{
                                        "insufficient_permissions": map[string]interface{}{
                                                "summary": "Insufficient Permissions",
                                                "value": map[string]interface{}{
                                                        "error":      "Insufficient permissions",
                                                        "error_code": "INSUFFICIENT_PERMISSIONS",
                                                        "details": map[string]interface{}{
                                                                "required_permission": "docker.containers.manage",
                                                                "user_permissions":    []string{"docker.containers.read"},
                                                        },
                                                        "timestamp": "2025-06-16T14:30:00Z",
                                                },
                                        },
                                        "readonly_user": map[string]interface{}{
                                                "summary": "Read-only User",
                                                "value": map[string]interface{}{
                                                        "error":      "Read-only user cannot perform write operations",
                                                        "error_code": "READONLY_USER",
                                                        "details": map[string]interface{}{
                                                                "operation": "container_start",
                                                                "user_role": "readonly",
                                                        },
                                                        "timestamp": "2025-06-16T14:30:00Z",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getNotFoundResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Not Found - The requested resource does not exist",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "container_not_found": map[string]interface{}{
                                                "summary": "Container Not Found",
                                                "value": map[string]interface{}{
                                                        "error": "Container 'nonexistent' not found",
                                                        "code":  "CONTAINER_NOT_FOUND",
                                                        "details": map[string]interface{}{
                                                                "container_id": "nonexistent",
                                                                "suggestion":   "Check container name or ID",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                        "vm_not_found": map[string]interface{}{
                                                "summary": "VM Not Found",
                                                "value": map[string]interface{}{
                                                        "error": "Virtual machine 'missing-vm' not found",
                                                        "code":  "VM_NOT_FOUND",
                                                        "details": map[string]interface{}{
                                                                "vm_id":      "missing-vm",
                                                                "suggestion": "Check VM name or ID",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                        "endpoint_not_found": map[string]interface{}{
                                                "summary": "Endpoint Not Found",
                                                "value": map[string]interface{}{
                                                        "error": "The requested endpoint does not exist",
                                                        "code":  "ENDPOINT_NOT_FOUND",
                                                        "details": map[string]interface{}{
                                                                "path":       "/api/v1/nonexistent",
                                                                "suggestion": "Check API documentation for valid endpoints",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getConflictResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Conflict - The request conflicts with the current state of the resource",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "container_already_running": map[string]interface{}{
                                                "summary": "Container Already Running",
                                                "value": map[string]interface{}{
                                                        "error": "Container 'plex' is already running",
                                                        "code":  "CONTAINER_ALREADY_RUNNING",
                                                        "details": map[string]interface{}{
                                                                "container_id":     "plex",
                                                                "current_status":   "running",
                                                                "requested_action": "start",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                        "array_already_started": map[string]interface{}{
                                                "summary": "Array Already Started",
                                                "value": map[string]interface{}{
                                                        "error": "Unraid array is already started",
                                                        "code":  "ARRAY_ALREADY_STARTED",
                                                        "details": map[string]interface{}{
                                                                "current_status":   "started",
                                                                "requested_action": "start",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getUnprocessableEntityResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Unprocessable Entity - The request is well-formed but contains semantic errors",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "invalid_operation": map[string]interface{}{
                                                "summary": "Invalid Operation",
                                                "value": map[string]interface{}{
                                                        "error": "Cannot perform operation on container in current state",
                                                        "code":  "INVALID_OPERATION",
                                                        "details": map[string]interface{}{
                                                                "container_id":     "plex",
                                                                "current_status":   "exited",
                                                                "requested_action": "pause",
                                                                "valid_actions":    []string{"start", "remove"},
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getTooManyRequestsResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Too Many Requests - Rate limit exceeded",
                "headers": map[string]interface{}{
                        "X-RateLimit-Limit": map[string]interface{}{
                                "description": "Request limit per time window",
                                "schema": map[string]interface{}{
                                        "type": "integer",
                                },
                        },
                        "X-RateLimit-Remaining": map[string]interface{}{
                                "description": "Remaining requests in current window",
                                "schema": map[string]interface{}{
                                        "type": "integer",
                                },
                        },
                        "X-RateLimit-Reset": map[string]interface{}{
                                "description": "Time when rate limit resets (Unix timestamp)",
                                "schema": map[string]interface{}{
                                        "type": "integer",
                                },
                        },
                },
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "rate_limited": map[string]interface{}{
                                                "summary": "Rate Limit Exceeded",
                                                "value": map[string]interface{}{
                                                        "error": "Rate limit exceeded",
                                                        "code":  "RATE_LIMITED",
                                                        "details": map[string]interface{}{
                                                                "limit":       100,
                                                                "window":      "1 hour",
                                                                "reset_at":    "2025-06-16T15:30:00Z",
                                                                "retry_after": 3600,
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getInternalServerErrorResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Internal Server Error - An unexpected error occurred",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "service_unavailable": map[string]interface{}{
                                                "summary": "Service Unavailable",
                                                "value": map[string]interface{}{
                                                        "error": "Docker daemon is not available",
                                                        "code":  "SERVICE_UNAVAILABLE",
                                                        "details": map[string]interface{}{
                                                                "service": "docker",
                                                                "status":  "unreachable",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                        "unexpected_error": map[string]interface{}{
                                                "summary": "Unexpected Error",
                                                "value": map[string]interface{}{
                                                        "error": "An unexpected error occurred",
                                                        "code":  "INTERNAL_ERROR",
                                                        "details": map[string]interface{}{
                                                                "error_id": "err_1234567890",
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getServiceUnavailableResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Service Unavailable - The service is temporarily unavailable",
                "headers": map[string]interface{}{
                        "Retry-After": map[string]interface{}{
                                "description": "Seconds to wait before retrying",
                                "schema": map[string]interface{}{
                                        "type": "integer",
                                },
                        },
                },
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/Error",
                                },
                                "examples": map[string]interface{}{
                                        "maintenance_mode": map[string]interface{}{
                                                "summary": "Maintenance Mode",
                                                "value": map[string]interface{}{
                                                        "error": "Service is in maintenance mode",
                                                        "code":  "MAINTENANCE_MODE",
                                                        "details": map[string]interface{}{
                                                                "estimated_duration": "30 minutes",
                                                                "retry_after":        1800,
                                                        },
                                                        "request_id": "req_1234567890_5678",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getSuccessResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Success - Operation completed successfully",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/SuccessResponse",
                                },
                                "examples": map[string]interface{}{
                                        "operation_success": map[string]interface{}{
                                                "summary": "Operation Success",
                                                "value": map[string]interface{}{
                                                        "success": true,
                                                        "message": "Operation completed successfully",
                                                        "data": map[string]interface{}{
                                                                "operation_id": "op_1234567890",
                                                                "timestamp":    "2025-06-16T14:30:00Z",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getCreatedResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Created - Resource created successfully",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/SuccessResponse",
                                },
                                "examples": map[string]interface{}{
                                        "resource_created": map[string]interface{}{
                                                "summary": "Resource Created",
                                                "value": map[string]interface{}{
                                                        "success": true,
                                                        "message": "Resource created successfully",
                                                        "data": map[string]interface{}{
                                                                "id":         "resource_1234567890",
                                                                "created_at": "2025-06-16T14:30:00Z",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getAcceptedResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Accepted - Request accepted for processing",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/SuccessResponse",
                                },
                                "examples": map[string]interface{}{
                                        "async_operation": map[string]interface{}{
                                                "summary": "Asynchronous Operation",
                                                "value": map[string]interface{}{
                                                        "success": true,
                                                        "message": "Request accepted for processing",
                                                        "data": map[string]interface{}{
                                                                "operation_id":         "op_1234567890",
                                                                "status":               "pending",
                                                                "estimated_completion": "2025-06-16T14:35:00Z",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getNoContentResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "No Content - Operation completed successfully with no response body",
        }
}</span>

// Convenience functions for new error types

// BadRequest returns a 400 Bad Request response
func BadRequest() map[string]interface{} <span class="cov0" title="0">{
        return getBadRequestResponse()
}</span>

// Unauthorized returns a 401 Unauthorized response
func Unauthorized() map[string]interface{} <span class="cov0" title="0">{
        return getUnauthorizedResponse()
}</span>

// Forbidden returns a 403 Forbidden response
func Forbidden() map[string]interface{} <span class="cov0" title="0">{
        return getForbiddenResponse()
}</span>

// NotFound returns a 404 Not Found response
func NotFound() map[string]interface{} <span class="cov0" title="0">{
        return getNotFoundResponse()
}</span>

// Conflict returns a 409 Conflict response
func Conflict() map[string]interface{} <span class="cov0" title="0">{
        return getConflictResponse()
}</span>

// RateLimitExceeded returns a 429 Too Many Requests response
func RateLimitExceeded() map[string]interface{} <span class="cov0" title="0">{
        return getTooManyRequestsResponse()
}</span>

// InternalServerError returns a 500 Internal Server Error response
func InternalServerError() map[string]interface{} <span class="cov0" title="0">{
        return getInternalServerErrorResponse()
}</span>

// NotImplemented returns a 501 Not Implemented response
func NotImplemented() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "description": "Not Implemented - The requested functionality is not yet implemented",
                "content": map[string]interface{}{
                        "application/json": map[string]interface{}{
                                "schema": map[string]interface{}{
                                        "$ref": "#/components/schemas/APIError",
                                },
                                "examples": map[string]interface{}{
                                        "not_implemented": map[string]interface{}{
                                                "summary": "Feature Not Implemented",
                                                "value": map[string]interface{}{
                                                        "error": map[string]interface{}{
                                                                "code":    "NOT_IMPLEMENTED",
                                                                "message": "This feature is not yet implemented",
                                                                "details": map[string]interface{}{
                                                                        "feature": "rate_limit_config_update",
                                                                        "note":    "This endpoint would require admin authentication",
                                                                },
                                                        },
                                                        "meta": map[string]interface{}{
                                                                "timestamp":   1640995200,
                                                                "api_version": "v1",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package schemas

// GetStandardResponse returns the standard response schema
func GetStandardResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "meta": GetStandardResponseMeta(),
                },
        }
}</span>

// GetStandardResponseMeta returns the standard response metadata schema
func GetStandardResponseMeta() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "timestamp": map[string]interface{}{
                                "type":        "integer",
                                "format":      "int64",
                                "description": "Unix timestamp of the response",
                        },
                        "request_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Unique request identifier for tracing",
                        },
                        "api_version": map[string]interface{}{
                                "type":        "string",
                                "example":     "v1",
                                "description": "API version",
                        },
                },
                "required": []string{"timestamp", "api_version"},
        }
}</span>

// GetAsyncOperationRequest returns the schema for async operation request
func GetAsyncOperationRequest() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "object",
                "required": []string{"type"},
                "properties": map[string]interface{}{
                        "type": map[string]interface{}{
                                "type": "string",
                                "enum": []string{
                                        "parity_check", "parity_correct", "array_start", "array_stop",
                                        "disk_scan", "smart_scan", "system_reboot", "system_shutdown",
                                        "bulk_container", "bulk_vm",
                                },
                                "description": "Type of asynchronous operation",
                        },
                        "description": map[string]interface{}{
                                "type":        "string",
                                "maxLength":   500,
                                "description": "Human-readable description of the operation",
                                "example":     "Comprehensive SMART data collection for all disks",
                        },
                        "cancellable": map[string]interface{}{
                                "type":        "boolean",
                                "default":     true,
                                "description": "Whether the operation can be cancelled",
                        },
                        "parameters": map[string]interface{}{
                                "type":                 "object",
                                "description":          "Operation-specific parameters",
                                "additionalProperties": true,
                                "examples": []map[string]interface{}{
                                        {
                                                "type":     "check",
                                                "priority": "normal",
                                        },
                                },
                        },
                },
        }
}</span>

// GetAsyncOperationResponse returns the schema for async operation response
func GetAsyncOperationResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "id": map[string]interface{}{
                                                                "type":        "string",
                                                                "format":      "uuid",
                                                                "description": "Unique identifier for the operation",
                                                        },
                                                        "type": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{
                                                                        "parity_check", "parity_correct", "array_start", "array_stop",
                                                                        "disk_scan", "smart_scan", "system_reboot", "system_shutdown",
                                                                        "bulk_container", "bulk_vm",
                                                                },
                                                                "description": "Type of asynchronous operation",
                                                        },
                                                        "status": map[string]interface{}{
                                                                "type":        "string",
                                                                "enum":        []string{"pending", "running", "completed", "failed", "cancelled"},
                                                                "description": "Current status of the operation",
                                                        },
                                                        "description": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "Human-readable description",
                                                        },
                                                        "cancellable": map[string]interface{}{
                                                                "type":        "boolean",
                                                                "description": "Whether the operation can be cancelled",
                                                        },
                                                        "started": map[string]interface{}{
                                                                "type":        "string",
                                                                "format":      "date-time",
                                                                "description": "When the operation was started",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetAsyncOperationDetailResponse returns the schema for detailed async operation response
func GetAsyncOperationDetailResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "id": map[string]interface{}{
                                                                "type":        "string",
                                                                "format":      "uuid",
                                                                "description": "Unique identifier for the operation",
                                                        },
                                                        "type": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{
                                                                        "parity_check", "parity_correct", "array_start", "array_stop",
                                                                        "disk_scan", "smart_scan", "system_reboot", "system_shutdown",
                                                                        "bulk_container", "bulk_vm",
                                                                },
                                                                "description": "Type of asynchronous operation",
                                                        },
                                                        "status": map[string]interface{}{
                                                                "type":        "string",
                                                                "enum":        []string{"pending", "running", "completed", "failed", "cancelled"},
                                                                "description": "Current status of the operation",
                                                        },
                                                        "progress": map[string]interface{}{
                                                                "type":        "integer",
                                                                "minimum":     0,
                                                                "maximum":     100,
                                                                "description": "Progress percentage (0-100)",
                                                        },
                                                        "started": map[string]interface{}{
                                                                "type":        "string",
                                                                "format":      "date-time",
                                                                "description": "When the operation was started",
                                                        },
                                                        "completed": map[string]interface{}{
                                                                "type":        "string",
                                                                "format":      "date-time",
                                                                "nullable":    true,
                                                                "description": "When the operation completed (if finished)",
                                                        },
                                                        "error": map[string]interface{}{
                                                                "type":        "string",
                                                                "nullable":    true,
                                                                "description": "Error message if operation failed",
                                                        },
                                                        "result": map[string]interface{}{
                                                                "type":                 "object",
                                                                "nullable":             true,
                                                                "description":          "Operation result data",
                                                                "additionalProperties": true,
                                                        },
                                                        "cancellable": map[string]interface{}{
                                                                "type":        "boolean",
                                                                "description": "Whether the operation can be cancelled",
                                                        },
                                                        "description": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "Human-readable description",
                                                        },
                                                        "created_by": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "User or system that created the operation",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetAsyncOperationListResponse returns the schema for async operation list response
func GetAsyncOperationListResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "operations": map[string]interface{}{
                                                                "type": "array",
                                                                "items": map[string]interface{}{
                                                                        "type": "object",
                                                                        "properties": map[string]interface{}{
                                                                                "id": map[string]interface{}{
                                                                                        "type":   "string",
                                                                                        "format": "uuid",
                                                                                },
                                                                                "type": map[string]interface{}{
                                                                                        "type": "string",
                                                                                        "enum": []string{
                                                                                                "parity_check", "parity_correct", "array_start", "array_stop",
                                                                                                "disk_scan", "smart_scan", "system_reboot", "system_shutdown",
                                                                                                "bulk_container", "bulk_vm",
                                                                                        },
                                                                                },
                                                                                "status": map[string]interface{}{
                                                                                        "type": "string",
                                                                                        "enum": []string{"pending", "running", "completed", "failed", "cancelled"},
                                                                                },
                                                                                "progress": map[string]interface{}{
                                                                                        "type":    "integer",
                                                                                        "minimum": 0,
                                                                                        "maximum": 100,
                                                                                },
                                                                                "started": map[string]interface{}{
                                                                                        "type":   "string",
                                                                                        "format": "date-time",
                                                                                },
                                                                                "description": map[string]interface{}{
                                                                                        "type": "string",
                                                                                },
                                                                                "cancellable": map[string]interface{}{
                                                                                        "type": "boolean",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        "total": map[string]interface{}{
                                                                "type":        "integer",
                                                                "description": "Total number of operations",
                                                        },
                                                        "active": map[string]interface{}{
                                                                "type":        "integer",
                                                                "description": "Number of active operations",
                                                        },
                                                        "completed": map[string]interface{}{
                                                                "type":        "integer",
                                                                "description": "Number of completed operations",
                                                        },
                                                        "failed": map[string]interface{}{
                                                                "type":        "integer",
                                                                "description": "Number of failed operations",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetAsyncOperationCancelResponse returns the schema for operation cancellation response
func GetAsyncOperationCancelResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "success": map[string]interface{}{
                                                                "type":    "boolean",
                                                                "example": true,
                                                        },
                                                        "message": map[string]interface{}{
                                                                "type":    "string",
                                                                "example": "Operation cancelled successfully",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetAsyncOperationStatsResponse returns the schema for operation statistics response
func GetAsyncOperationStatsResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "total_operations": map[string]interface{}{
                                                                "type":        "integer",
                                                                "description": "Total number of operations",
                                                        },
                                                        "max_operations": map[string]interface{}{
                                                                "type":        "integer",
                                                                "description": "Maximum concurrent operations allowed",
                                                        },
                                                        "by_status": map[string]interface{}{
                                                                "type": "object",
                                                                "additionalProperties": map[string]interface{}{
                                                                        "type": "integer",
                                                                },
                                                                "description": "Count of operations by status",
                                                        },
                                                        "by_type": map[string]interface{}{
                                                                "type": "object",
                                                                "additionalProperties": map[string]interface{}{
                                                                        "type": "integer",
                                                                },
                                                                "description": "Count of operations by type",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package schemas

// GetAuthSchemas returns authentication-related schemas
func GetAuthSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "LoginRequest":   getLoginRequestSchema(),
                "LoginResponse":  getLoginResponseSchema(),
                "TokenResponse":  getTokenResponseSchema(),
                "RefreshRequest": getRefreshRequestSchema(),
                "UserInfo":       getUserInfoSchema(),
                "APIKeyInfo":     getAPIKeyInfoSchema(),
                "AuthError":      getAuthErrorSchema(),
                "AuthStats":      getAuthStatsSchema(),
                "SessionInfo":    getSessionInfoSchema(),
                "PermissionInfo": getPermissionInfoSchema(),
        }
}</span>

func getLoginRequestSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "username": map[string]interface{}{
                                "type":        "string",
                                "description": "Username for authentication",
                                "example":     "admin",
                                "minLength":   1,
                                "maxLength":   50,
                                "pattern":     "^[a-zA-Z0-9_.-]+$",
                        },
                        "password": map[string]interface{}{
                                "type":        "string",
                                "description": "Password for authentication",
                                "example":     "secure_password",
                                "minLength":   1,
                                "maxLength":   100,
                                "format":      "password",
                        },
                        "remember_me": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether to create a long-lived session",
                                "example":     false,
                                "default":     false,
                        },
                        "client_info": map[string]interface{}{
                                "type":        "object",
                                "description": "Optional client information",
                                "properties": map[string]interface{}{
                                        "user_agent": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Client user agent",
                                                "example":     "UMA-Client/1.0",
                                        },
                                        "ip_address": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Client IP address",
                                                "example":     "192.168.1.100",
                                        },
                                },
                        },
                },
                "required": []string{"username", "password"},
        }
}</span>

func getLoginResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether login was successful",
                                "example":     true,
                        },
                        "token": map[string]interface{}{
                                "type":        "string",
                                "description": "JWT access token",
                                "example":     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                        },
                        "refresh_token": map[string]interface{}{
                                "type":        "string",
                                "description": "JWT refresh token",
                                "example":     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                        },
                        "expires_in": map[string]interface{}{
                                "type":        "integer",
                                "description": "Token expiration time in seconds",
                                "example":     3600,
                                "minimum":     1,
                        },
                        "token_type": map[string]interface{}{
                                "type":        "string",
                                "description": "Token type",
                                "example":     "Bearer",
                                "default":     "Bearer",
                        },
                        "user": map[string]interface{}{
                                "$ref": "#/components/schemas/UserInfo",
                        },
                        "permissions": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "User permissions",
                                "example":     []string{"read", "write", "admin"},
                        },
                        "session_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Session identifier",
                                "example":     "sess_1234567890",
                        },
                },
                "required": []string{"success", "token", "expires_in", "token_type", "user"},
        }
}</span>

func getTokenResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "access_token": map[string]interface{}{
                                "type":        "string",
                                "description": "JWT access token",
                                "example":     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                        },
                        "refresh_token": map[string]interface{}{
                                "type":        "string",
                                "description": "JWT refresh token",
                                "example":     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                        },
                        "token_type": map[string]interface{}{
                                "type":        "string",
                                "description": "Token type",
                                "example":     "Bearer",
                                "default":     "Bearer",
                        },
                        "expires_in": map[string]interface{}{
                                "type":        "integer",
                                "description": "Token expiration time in seconds",
                                "example":     3600,
                                "minimum":     1,
                        },
                        "scope": map[string]interface{}{
                                "type":        "string",
                                "description": "Token scope",
                                "example":     "read write admin",
                        },
                        "issued_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Token issuance timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"access_token", "token_type", "expires_in"},
        }
}</span>

func getRefreshRequestSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "refresh_token": map[string]interface{}{
                                "type":        "string",
                                "description": "JWT refresh token",
                                "example":     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                        },
                },
                "required": []string{"refresh_token"},
        }
}</span>

func getUserInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "User ID",
                                "example":     "user_1234567890",
                        },
                        "username": map[string]interface{}{
                                "type":        "string",
                                "description": "Username",
                                "example":     "admin",
                        },
                        "email": map[string]interface{}{
                                "type":        "string",
                                "format":      "email",
                                "description": "User email address",
                                "example":     "admin@example.com",
                        },
                        "full_name": map[string]interface{}{
                                "type":        "string",
                                "description": "User full name",
                                "example":     "System Administrator",
                        },
                        "role": map[string]interface{}{
                                "type":        "string",
                                "description": "User role",
                                "enum":        []string{"admin", "user", "readonly"},
                                "example":     "admin",
                        },
                        "permissions": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "User permissions",
                                "example":     []string{"read", "write", "admin"},
                        },
                        "created_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "User creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "last_login": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last login timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "active": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether user account is active",
                                "example":     true,
                        },
                },
                "required": []string{"id", "username", "role", "permissions", "active"},
        }
}</span>

func getAPIKeyInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "API key ID",
                                "example":     "key_1234567890",
                        },
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "API key name",
                                "example":     "Home Assistant Integration",
                        },
                        "key": map[string]interface{}{
                                "type":        "string",
                                "description": "API key value (only shown on creation)",
                                "example":     "uma_1234567890abcdef",
                        },
                        "permissions": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "API key permissions",
                                "example":     []string{"read", "write"},
                        },
                        "created_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "API key creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "last_used": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last usage timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "expires_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "API key expiration timestamp",
                                "example":     "2026-06-16T14:30:00Z",
                        },
                        "active": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether API key is active",
                                "example":     true,
                        },
                },
                "required": []string{"id", "name", "permissions", "created_at", "active"},
        }
}</span>

func getAuthErrorSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "error": map[string]interface{}{
                                "type":        "string",
                                "description": "Authentication error message",
                                "example":     "Invalid credentials",
                        },
                        "error_code": map[string]interface{}{
                                "type":        "string",
                                "description": "Authentication error code",
                                "enum": []string{
                                        "INVALID_CREDENTIALS", "TOKEN_EXPIRED", "TOKEN_INVALID",
                                        "INSUFFICIENT_PERMISSIONS", "ACCOUNT_DISABLED", "RATE_LIMITED",
                                },
                                "example": "INVALID_CREDENTIALS",
                        },
                        "details": map[string]interface{}{
                                "type":                 "object",
                                "description":          "Additional error details",
                                "additionalProperties": true,
                                "example": map[string]interface{}{
                                        "attempts_remaining": 2,
                                        "lockout_duration":   300,
                                },
                        },
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Error timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"error", "error_code", "timestamp"},
        }
}</span>

func getAuthStatsSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "total_users": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of users",
                                "example":     5,
                                "minimum":     0,
                        },
                        "active_users": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of active users",
                                "example":     3,
                                "minimum":     0,
                        },
                        "active_sessions": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of active sessions",
                                "example":     2,
                                "minimum":     0,
                        },
                        "api_keys": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of active API keys",
                                "example":     4,
                                "minimum":     0,
                        },
                        "failed_logins_24h": map[string]interface{}{
                                "type":        "integer",
                                "description": "Failed login attempts in last 24 hours",
                                "example":     1,
                                "minimum":     0,
                        },
                        "successful_logins_24h": map[string]interface{}{
                                "type":        "integer",
                                "description": "Successful logins in last 24 hours",
                                "example":     15,
                                "minimum":     0,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"total_users", "active_users", "active_sessions", "api_keys", "last_updated"},
        }
}</span>

func getSessionInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Session ID",
                                "example":     "sess_1234567890",
                        },
                        "user_id": map[string]interface{}{
                                "type":        "string",
                                "description": "User ID",
                                "example":     "user_1234567890",
                        },
                        "username": map[string]interface{}{
                                "type":        "string",
                                "description": "Username",
                                "example":     "admin",
                        },
                        "ip_address": map[string]interface{}{
                                "type":        "string",
                                "description": "Client IP address",
                                "example":     "192.168.1.100",
                        },
                        "user_agent": map[string]interface{}{
                                "type":        "string",
                                "description": "Client user agent",
                                "example":     "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
                        },
                        "created_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Session creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "expires_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Session expiration timestamp",
                                "example":     "2025-06-16T18:30:00Z",
                        },
                        "last_activity": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last activity timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "active": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether session is active",
                                "example":     true,
                        },
                },
                "required": []string{"id", "user_id", "username", "created_at", "expires_at", "active"},
        }
}</span>

func getPermissionInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Permission name",
                                "example":     "docker.containers.manage",
                        },
                        "description": map[string]interface{}{
                                "type":        "string",
                                "description": "Permission description",
                                "example":     "Manage Docker containers (start, stop, restart)",
                        },
                        "category": map[string]interface{}{
                                "type":        "string",
                                "description": "Permission category",
                                "enum":        []string{"system", "docker", "storage", "vm", "auth", "monitoring"},
                                "example":     "docker",
                        },
                        "level": map[string]interface{}{
                                "type":        "string",
                                "description": "Permission level",
                                "enum":        []string{"read", "write", "admin"},
                                "example":     "write",
                        },
                        "resource": map[string]interface{}{
                                "type":        "string",
                                "description": "Resource this permission applies to",
                                "example":     "containers",
                        },
                },
                "required": []string{"name", "description", "category", "level"},
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package schemas

// GetCommonSchemas returns common schemas used across all API endpoints
func GetCommonSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "StandardResponse": getStandardResponseSchema(),
                "PaginationInfo":   getPaginationSchema(),
                "ResponseMeta":     getResponseMetaSchema(),
                "HealthResponse":   getHealthResponseSchema(),
                "Error":            getErrorSchema(),
                "SuccessResponse":  getSuccessResponseSchema(),
        }
}</span>

func getStandardResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "data": map[string]interface{}{
                                "description": "The response data",
                        },
                        "pagination": map[string]interface{}{
                                "$ref": "#/components/schemas/PaginationInfo",
                        },
                        "meta": map[string]interface{}{
                                "$ref": "#/components/schemas/ResponseMeta",
                        },
                },
                "required": []string{"data"},
        }
}</span>

func getPaginationSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "page": map[string]interface{}{
                                "type":        "integer",
                                "description": "Current page number",
                                "example":     1,
                                "minimum":     1,
                        },
                        "per_page": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of items per page",
                                "example":     50,
                                "minimum":     1,
                                "maximum":     1000,
                        },
                        "total": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of items",
                                "example":     150,
                                "minimum":     0,
                        },
                        "has_more": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether there are more pages available",
                                "example":     true,
                        },
                        "total_pages": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of pages",
                                "example":     3,
                                "minimum":     0,
                        },
                },
                "required": []string{"page", "per_page", "total", "has_more", "total_pages"},
        }
}</span>

func getResponseMetaSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "request_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Unique request identifier for tracing",
                                "example":     "req_1234567890_5678",
                        },
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Response timestamp in ISO 8601 format",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "version": map[string]interface{}{
                                "type":        "string",
                                "description": "API version",
                                "example":     "v1",
                        },
                        "server": map[string]interface{}{
                                "type":        "string",
                                "description": "Server identifier",
                                "example":     "uma-server-01",
                        },
                },
        }
}</span>

func getHealthResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Overall health status",
                                "enum":        []string{"healthy", "degraded", "unhealthy"},
                                "example":     "healthy",
                        },
                        "version": map[string]interface{}{
                                "type":        "string",
                                "description": "UMA version",
                                "example":     "2025.06.16",
                        },
                        "uptime": map[string]interface{}{
                                "type":        "integer",
                                "description": "Server uptime in seconds",
                                "example":     86400,
                                "minimum":     0,
                        },
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Health check timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "dependencies": map[string]interface{}{
                                "type": "object",
                                "description": "Status of external dependencies",
                                "properties": map[string]interface{}{
                                        "docker": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"available", "unavailable"},
                                                "example":     "available",
                                        },
                                        "unraid_api": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"available", "unavailable"},
                                                "example":     "available",
                                        },
                                        "apcupsd": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"available", "unavailable"},
                                                "example":     "available",
                                        },
                                },
                        },
                },
                "required": []string{"status", "version", "uptime", "timestamp"},
        }
}</span>

func getErrorSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "error": map[string]interface{}{
                                "type":        "string",
                                "description": "Human-readable error message",
                                "example":     "Invalid request parameters",
                        },
                        "code": map[string]interface{}{
                                "type":        "string",
                                "description": "Machine-readable error code for programmatic handling",
                                "example":     "INVALID_REQUEST",
                        },
                        "details": map[string]interface{}{
                                "type":        "object",
                                "description": "Additional error details and context",
                                "additionalProperties": true,
                                "example": map[string]interface{}{
                                        "field":   "container_ids",
                                        "message": "must contain at least 1 item",
                                },
                        },
                        "request_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Request ID for error tracking",
                                "example":     "req_1234567890_5678",
                        },
                },
                "required": []string{"error"},
        }
}</span>

func getSuccessResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Operation success status",
                                "example":     true,
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Success message",
                                "example":     "Operation completed successfully",
                        },
                        "data": map[string]interface{}{
                                "description": "Optional response data",
                        },
                },
                "required": []string{"success"},
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package schemas

// GetDockerSchemas returns Docker-related schemas
func GetDockerSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "ContainerInfo":             getContainerInfoSchema(),
                "ContainerState":            getContainerStateSchema(),
                "ContainerOperationResult":  getContainerOperationResultSchema(),
                "ContainerOperationResponse": getContainerOperationResponseSchema(),
                "BulkOperationRequest":      getBulkOperationRequestSchema(),
                "BulkOperationResponse":     getBulkOperationResponseSchema(),
                "BulkOperationSummary":      getBulkOperationSummarySchema(),
                "DockerImage":               getDockerImageSchema(),
                "DockerNetwork":             getDockerNetworkSchema(),
                "DockerInfo":                getDockerInfoSchema(),
                "ContainerPort":             getContainerPortSchema(),
        }
}</span>

func getContainerInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Container ID",
                                "example":     "1234567890ab",
                                "pattern":     "^[a-f0-9]{12}$",
                        },
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Container name",
                                "example":     "plex",
                                "pattern":     "^[a-zA-Z0-9][a-zA-Z0-9_.-]+$",
                        },
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Container status",
                                "enum":        []string{"created", "running", "paused", "restarting", "removing", "exited", "dead"},
                                "example":     "running",
                        },
                        "state": map[string]interface{}{
                                "$ref": "#/components/schemas/ContainerState",
                        },
                        "created": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Container creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "image": map[string]interface{}{
                                "type":        "string",
                                "description": "Container image",
                                "example":     "linuxserver/plex:latest",
                        },
                        "ports": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/ContainerPort",
                                },
                                "description": "Container port mappings",
                        },
                        "labels": map[string]interface{}{
                                "type":        "object",
                                "description": "Container labels",
                                "additionalProperties": map[string]interface{}{
                                        "type": "string",
                                },
                        },
                        "mounts": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "source": map[string]interface{}{
                                                        "type": "string",
                                                },
                                                "destination": map[string]interface{}{
                                                        "type": "string",
                                                },
                                                "mode": map[string]interface{}{
                                                        "type": "string",
                                                },
                                        },
                                },
                        },
                },
                "required": []string{"id", "name", "status", "created"},
        }
}</span>

func getContainerStateSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Container state status",
                                "example":     "running",
                        },
                        "running": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the container is running",
                                "example":     true,
                        },
                        "paused": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the container is paused",
                                "example":     false,
                        },
                        "restarting": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the container is restarting",
                                "example":     false,
                        },
                        "pid": map[string]interface{}{
                                "type":        "integer",
                                "description": "Container process ID",
                                "example":     1234,
                        },
                        "exit_code": map[string]interface{}{
                                "type":        "integer",
                                "description": "Container exit code",
                                "example":     0,
                        },
                        "started_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Container start timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "finished_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Container finish timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
        }
}</span>

func getContainerPortSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "private_port": map[string]interface{}{
                                "type":        "integer",
                                "description": "Container internal port",
                                "example":     32400,
                                "minimum":     1,
                                "maximum":     65535,
                        },
                        "public_port": map[string]interface{}{
                                "type":        "integer",
                                "description": "Host external port",
                                "example":     32400,
                                "minimum":     1,
                                "maximum":     65535,
                        },
                        "type": map[string]interface{}{
                                "type":        "string",
                                "description": "Port protocol",
                                "enum":        []string{"tcp", "udp"},
                                "example":     "tcp",
                        },
                        "ip": map[string]interface{}{
                                "type":        "string",
                                "description": "Bind IP address",
                                "example":     "0.0.0.0",
                        },
                },
                "required": []string{"private_port", "type"},
        }
}</span>

func getBulkOperationRequestSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "container_ids": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type":    "string",
                                        "pattern": "^[a-zA-Z0-9][a-zA-Z0-9_.-]+$",
                                },
                                "description": "Array of container IDs or names",
                                "example":     []string{"plex", "nginx", "sonarr"},
                                "minItems":    1,
                                "maxItems":    50,
                                "uniqueItems": true,
                        },
                },
                "required": []string{"container_ids"},
        }
}</span>

func getBulkOperationResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "summary": map[string]interface{}{
                                "$ref": "#/components/schemas/BulkOperationSummary",
                        },
                        "results": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/ContainerOperationResult",
                                },
                                "description": "Individual operation results",
                        },
                },
                "required": []string{"summary", "results"},
        }
}</span>

func getBulkOperationSummarySchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "total": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of operations attempted",
                                "example":     3,
                                "minimum":     0,
                        },
                        "successful": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of successful operations",
                                "example":     2,
                                "minimum":     0,
                        },
                        "failed": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of failed operations",
                                "example":     1,
                                "minimum":     0,
                        },
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "description": "Type of operation performed",
                                "enum":        []string{"start", "stop", "restart", "pause", "resume"},
                                "example":     "start",
                        },
                },
                "required": []string{"total", "successful", "failed", "operation"},
        }
}</span>

func getContainerOperationResultSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "container_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Container ID or name",
                                "example":     "plex",
                        },
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the operation was successful",
                                "example":     true,
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Operation result message",
                                "example":     "Container started successfully",
                        },
                        "error": map[string]interface{}{
                                "type":        "string",
                                "description": "Error message if operation failed",
                                "example":     "Container not found",
                        },
                },
                "required": []string{"container_id", "success"},
        }
}</span>

func getContainerOperationResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the operation was successful",
                                "example":     true,
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Operation result message",
                                "example":     "Container started successfully",
                        },
                        "container_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Container ID or name",
                                "example":     "plex",
                        },
                },
                "required": []string{"success", "message", "container_id"},
        }
}</span>

func getDockerImageSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Image ID",
                                "example":     "sha256:1234567890ab",
                        },
                        "repo_tags": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "Repository tags",
                                "example":     []string{"linuxserver/plex:latest"},
                        },
                        "size": map[string]interface{}{
                                "type":        "integer",
                                "description": "Image size in bytes",
                                "example":     1073741824,
                                "minimum":     0,
                        },
                        "created": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Image creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"id", "repo_tags", "size", "created"},
        }
}</span>

func getDockerNetworkSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Network ID",
                                "example":     "1234567890ab",
                        },
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Network name",
                                "example":     "bridge",
                        },
                        "driver": map[string]interface{}{
                                "type":        "string",
                                "description": "Network driver",
                                "example":     "bridge",
                        },
                        "scope": map[string]interface{}{
                                "type":        "string",
                                "description": "Network scope",
                                "example":     "local",
                        },
                },
                "required": []string{"id", "name", "driver"},
        }
}</span>

func getDockerInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "containers": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of containers",
                                "example":     15,
                                "minimum":     0,
                        },
                        "containers_running": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of running containers",
                                "example":     12,
                                "minimum":     0,
                        },
                        "containers_paused": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of paused containers",
                                "example":     0,
                                "minimum":     0,
                        },
                        "containers_stopped": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of stopped containers",
                                "example":     3,
                                "minimum":     0,
                        },
                        "images": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of images",
                                "example":     25,
                                "minimum":     0,
                        },
                        "server_version": map[string]interface{}{
                                "type":        "string",
                                "description": "Docker server version",
                                "example":     "20.10.21",
                        },
                },
                "required": []string{"containers", "containers_running", "containers_paused", "containers_stopped", "images"},
        }
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package schemas

// GetAPIError returns the schema for structured API errors
func GetAPIError() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "error": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "code": map[string]interface{}{
                                                "type": "string",
                                                "enum": []string{
                                                        // General errors
                                                        "INVALID_REQUEST", "UNAUTHORIZED", "FORBIDDEN", "NOT_FOUND",
                                                        "CONFLICT", "INTERNAL_ERROR", "SERVICE_UNAVAILABLE", "RATE_LIMIT_EXCEEDED",
                                                        // Validation errors
                                                        "VALIDATION_FAILED", "MISSING_PARAMETER", "INVALID_PARAMETER", "PARAMETER_OUT_OF_RANGE",
                                                        // Storage/Array errors
                                                        "ARRAY_NOT_STOPPED", "ARRAY_NOT_STARTED", "ARRAY_INVALID_STATE",
                                                        "DISK_NOT_FOUND", "DISK_OFFLINE", "DISK_READ_ONLY",
                                                        "PARITY_CHECK_ACTIVE", "PARITY_CHECK_FAILED", "INSUFFICIENT_SPACE",
                                                        // Docker errors
                                                        "CONTAINER_NOT_FOUND", "CONTAINER_NOT_RUNNING", "CONTAINER_NOT_STOPPED",
                                                        "DOCKER_DAEMON_ERROR", "IMAGE_NOT_FOUND", "NETWORK_NOT_FOUND",
                                                        // VM errors
                                                        "VM_NOT_FOUND", "VM_NOT_RUNNING", "VM_NOT_STOPPED",
                                                        "VM_CONFIG_ERROR", "VIRT_MANAGER_ERROR",
                                                        // System errors
                                                        "SYSTEM_NOT_READY", "COMMAND_FAILED", "PERMISSION_DENIED",
                                                        "RESOURCE_BUSY", "HARDWARE_ERROR",
                                                        // Async operation errors
                                                        "OPERATION_NOT_FOUND", "OPERATION_NOT_CANCELLABLE", "OPERATION_CONFLICT",
                                                        "OPERATION_TIMEOUT", "MAX_OPERATIONS_REACHED",
                                                        // Authentication errors
                                                        "INVALID_CREDENTIALS", "TOKEN_EXPIRED", "TOKEN_INVALID", "SESSION_EXPIRED",
                                                        // Configuration errors
                                                        "CONFIG_NOT_FOUND", "CONFIG_INVALID", "CONFIG_READ_ONLY",
                                                },
                                                "description": "Standardized error code",
                                                "example":     "OPERATION_NOT_FOUND",
                                        },
                                        "message": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Human-readable error message",
                                                "example":     "Operation not found",
                                        },
                                        "details": map[string]interface{}{
                                                "type":                 "object",
                                                "nullable":             true,
                                                "description":          "Additional error context and debugging information",
                                                "additionalProperties": true,
                                                "properties": map[string]interface{}{
                                                        "resource_id": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "ID of the resource that caused the error",
                                                        },
                                                        "resource_type": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "Type of resource (disk, container, vm, operation, etc.)",
                                                        },
                                                        "operation_type": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "Type of operation that failed",
                                                        },
                                                        "client_ip": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "Client IP address for rate limiting errors",
                                                        },
                                                        "validation_errors": map[string]interface{}{
                                                                "type": "array",
                                                                "items": map[string]interface{}{
                                                                        "$ref": "#/components/schemas/ValidationError",
                                                                },
                                                                "description": "Detailed validation errors for each field",
                                                        },
                                                        "conflicting_operation": map[string]interface{}{
                                                                "type":        "string",
                                                                "description": "ID or type of conflicting operation",
                                                        },
                                                        "limit": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "requests": map[string]interface{}{
                                                                                "type": "integer",
                                                                        },
                                                                        "window": map[string]interface{}{
                                                                                "type": "string",
                                                                        },
                                                                },
                                                                "description": "Rate limit that was exceeded",
                                                        },
                                                },
                                        },
                                },
                                "required": []string{"code", "message"},
                        },
                        "meta": GetStandardResponseMeta(),
                },
                "required": []string{"error", "meta"},
        }
}</span>

// GetValidationError returns the schema for validation errors
func GetValidationError() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "field": map[string]interface{}{
                                "type":        "string",
                                "description": "Name of the field that failed validation",
                                "example":     "container_id",
                        },
                        "value": map[string]interface{}{
                                "description": "The invalid value that was provided",
                                "example":     "invalid-container-id",
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Human-readable validation error message",
                                "example":     "Invalid container ID format (expected: 12-64 hex characters)",
                        },
                        "code": map[string]interface{}{
                                "type":        "string",
                                "description": "Validation error code for programmatic handling",
                                "example":     "INVALID_FORMAT",
                        },
                },
                "required": []string{"field", "message"},
        }
}</span>

// GetValidationErrorResponse returns the schema for validation error responses
func GetValidationErrorResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetAPIError(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "error": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "code": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{"VALIDATION_FAILED"},
                                                        },
                                                        "details": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "validation_errors": map[string]interface{}{
                                                                                "type": "array",
                                                                                "items": map[string]interface{}{
                                                                                        "$ref": "#/components/schemas/ValidationError",
                                                                                },
                                                                                "minItems": 1,
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetResourceNotFoundError returns the schema for resource not found errors
func GetResourceNotFoundError() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetAPIError(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "error": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "code": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{
                                                                        "DISK_NOT_FOUND", "CONTAINER_NOT_FOUND",
                                                                        "VM_NOT_FOUND", "OPERATION_NOT_FOUND",
                                                                },
                                                        },
                                                        "details": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "resource_id": map[string]interface{}{
                                                                                "type":        "string",
                                                                                "description": "ID of the resource that was not found",
                                                                        },
                                                                        "resource_type": map[string]interface{}{
                                                                                "type":        "string",
                                                                                "description": "Type of resource (disk, container, vm, operation)",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetConflictError returns the schema for conflict errors
func GetConflictError() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetAPIError(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "error": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "code": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{
                                                                        "ARRAY_NOT_STOPPED", "ARRAY_NOT_STARTED",
                                                                        "OPERATION_CONFLICT", "PARITY_CHECK_ACTIVE",
                                                                },
                                                        },
                                                        "details": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "conflicting_operation": map[string]interface{}{
                                                                                "type":        "string",
                                                                                "description": "ID or description of the conflicting operation",
                                                                        },
                                                                        "required_state": map[string]interface{}{
                                                                                "type":        "string",
                                                                                "description": "Required state for the operation to proceed",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetRateLimitError returns the schema for rate limit errors
func GetRateLimitError() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetAPIError(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "error": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "code": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{"RATE_LIMIT_EXCEEDED"},
                                                        },
                                                        "details": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "operation_type": map[string]interface{}{
                                                                                "type":        "string",
                                                                                "description": "The operation type that was rate limited",
                                                                        },
                                                                        "client_ip": map[string]interface{}{
                                                                                "type":        "string",
                                                                                "description": "The client IP that was rate limited",
                                                                        },
                                                                        "limit": map[string]interface{}{
                                                                                "type": "object",
                                                                                "properties": map[string]interface{}{
                                                                                        "requests": map[string]interface{}{
                                                                                                "type":        "integer",
                                                                                                "description": "Number of requests allowed",
                                                                                        },
                                                                                        "window": map[string]interface{}{
                                                                                                "type":        "string",
                                                                                                "description": "Time window for the rate limit",
                                                                                        },
                                                                                },
                                                                        },
                                                                        "retry_after": map[string]interface{}{
                                                                                "type":        "integer",
                                                                                "description": "Seconds to wait before retrying",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package schemas

// GetRateLimitStatsResponse returns the schema for rate limiting statistics response
func GetRateLimitStatsResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "general_rate_limiter": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "type": map[string]interface{}{
                                                                                "type":    "string",
                                                                                "example": "general",
                                                                        },
                                                                },
                                                                "description": "General rate limiter statistics",
                                                        },
                                                        "operation_rate_limiter": map[string]interface{}{
                                                                "type": "object",
                                                                "properties": map[string]interface{}{
                                                                        "type": map[string]interface{}{
                                                                                "type":    "string",
                                                                                "example": "operation_specific",
                                                                        },
                                                                        "total_clients": map[string]interface{}{
                                                                                "type":        "integer",
                                                                                "description": "Total number of tracked clients",
                                                                        },
                                                                        "operation_limits": map[string]interface{}{
                                                                                "type": "object",
                                                                                "additionalProperties": map[string]interface{}{
                                                                                        "type": "object",
                                                                                        "properties": map[string]interface{}{
                                                                                                "requests": map[string]interface{}{
                                                                                                        "type":        "integer",
                                                                                                        "description": "Number of requests allowed",
                                                                                                },
                                                                                                "window": map[string]interface{}{
                                                                                                        "type":        "string",
                                                                                                        "description": "Time window for the rate limit",
                                                                                                        "example":     "1m0s",
                                                                                                },
                                                                                        },
                                                                                },
                                                                                "description": "Current rate limits by operation type",
                                                                        },
                                                                        "client_stats": map[string]interface{}{
                                                                                "type": "object",
                                                                                "additionalProperties": map[string]interface{}{
                                                                                        "type": "object",
                                                                                        "additionalProperties": map[string]interface{}{
                                                                                                "type": "object",
                                                                                                "properties": map[string]interface{}{
                                                                                                        "tokens_remaining": map[string]interface{}{
                                                                                                                "type":        "integer",
                                                                                                                "minimum":     0,
                                                                                                                "description": "Number of tokens remaining for this client",
                                                                                                        },
                                                                                                        "max_tokens": map[string]interface{}{
                                                                                                                "type":        "integer",
                                                                                                                "minimum":     1,
                                                                                                                "description": "Maximum number of tokens for this operation type",
                                                                                                        },
                                                                                                },
                                                                                        },
                                                                                },
                                                                                "description": "Per-client rate limiting statistics",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetRateLimitConfigResponse returns the schema for rate limiting configuration response
func GetRateLimitConfigResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "additionalProperties": map[string]interface{}{
                                                        "type": "object",
                                                        "properties": map[string]interface{}{
                                                                "requests": map[string]interface{}{
                                                                        "type":        "integer",
                                                                        "minimum":     1,
                                                                        "maximum":     1000,
                                                                        "description": "Number of requests allowed",
                                                                        "example":     60,
                                                                },
                                                                "window": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "pattern":     "^(\\d+(\\.\\d+)?(ns|us|s|ms|s|m|h))+$",
                                                                        "description": "Time window for the rate limit (Go duration format)",
                                                                        "example":     "1m0s",
                                                                },
                                                        },
                                                        "required": []string{"requests", "window"},
                                                },
                                                "description": "Rate limiting configuration by operation type",
                                        },
                                },
                        },
                },
        }
}</span>

// GetRateLimitConfigUpdate returns the schema for rate limiting configuration update request
func GetRateLimitConfigUpdate() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "additionalProperties": map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "requests": map[string]interface{}{
                                        "type":        "integer",
                                        "minimum":     1,
                                        "maximum":     1000,
                                        "description": "Number of requests allowed",
                                        "example":     60,
                                },
                                "window": map[string]interface{}{
                                        "type":        "string",
                                        "pattern":     "^(\\d+(\\.\\d+)?(ns|us|s|ms|s|m|h))+$",
                                        "description": "Time window for the rate limit (Go duration format)",
                                        "example":     "1m0s",
                                },
                        },
                        "required": []string{"requests", "window"},
                },
                "description":   "Rate limiting configuration updates by operation type",
                "minProperties": 1,
                "example": map[string]interface{}{
                        "smart_data": map[string]interface{}{
                                "requests": 2,
                                "window":   "2m0s",
                        },
                        "docker_bulk": map[string]interface{}{
                                "requests": 10,
                                "window":   "1m0s",
                        },
                },
        }
}</span>

// GetRateLimitConfigUpdateResponse returns the schema for rate limiting configuration update response
func GetRateLimitConfigUpdateResponse() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "allOf": []map[string]interface{}{
                        GetStandardResponse(),
                        {
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "data": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "message": map[string]interface{}{
                                                                "type":    "string",
                                                                "example": "Rate limit configuration update not implemented yet",
                                                        },
                                                        "note": map[string]interface{}{
                                                                "type":    "string",
                                                                "example": "This endpoint would require admin authentication",
                                                        },
                                                        "updated_operations": map[string]interface{}{
                                                                "type": "array",
                                                                "items": map[string]interface{}{
                                                                        "type": "string",
                                                                        "enum": []string{
                                                                                "general", "health_check", "smart_data", "parity_check",
                                                                                "array_control", "disk_info", "docker_list", "docker_control",
                                                                                "docker_bulk", "vm_list", "vm_control", "vm_bulk",
                                                                                "system_info", "system_control", "sensor_data",
                                                                                "async_create", "async_list", "async_cancel",
                                                                        },
                                                                },
                                                                "description": "List of operation types that were updated",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package schemas

import (
        "fmt"
)

// Registry manages all OpenAPI schemas
type Registry struct {
        schemas map[string]interface{}
}

// NewRegistry creates a new schema registry
func NewRegistry() *Registry <span class="cov0" title="0">{
        return &amp;Registry{
                schemas: make(map[string]interface{}),
        }
}</span>

// RegisterAll registers all schemas from different modules
func (r *Registry) RegisterAll() <span class="cov0" title="0">{
        // Register common schemas
        for name, schema := range GetCommonSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register Docker schemas
        <span class="cov0" title="0">for name, schema := range GetDockerSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register system schemas
        <span class="cov0" title="0">for name, schema := range GetSystemSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register storage schemas
        <span class="cov0" title="0">for name, schema := range GetStorageSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register VM schemas
        <span class="cov0" title="0">for name, schema := range GetVMSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register WebSocket schemas
        <span class="cov0" title="0">for name, schema := range GetWebSocketSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register authentication schemas
        <span class="cov0" title="0">for name, schema := range GetAuthSchemas() </span><span class="cov0" title="0">{
                r.schemas[name] = schema
        }</span>

        // Register async operations schemas
        <span class="cov0" title="0">r.schemas["AsyncOperationRequest"] = GetAsyncOperationRequest()
        r.schemas["AsyncOperationResponse"] = GetAsyncOperationResponse()
        r.schemas["AsyncOperationDetailResponse"] = GetAsyncOperationDetailResponse()
        r.schemas["AsyncOperationListResponse"] = GetAsyncOperationListResponse()
        r.schemas["AsyncOperationCancelResponse"] = GetAsyncOperationCancelResponse()
        r.schemas["AsyncOperationStatsResponse"] = GetAsyncOperationStatsResponse()

        // Register rate limiting schemas
        r.schemas["RateLimitStatsResponse"] = GetRateLimitStatsResponse()
        r.schemas["RateLimitConfigResponse"] = GetRateLimitConfigResponse()
        r.schemas["RateLimitConfigUpdate"] = GetRateLimitConfigUpdate()
        r.schemas["RateLimitConfigUpdateResponse"] = GetRateLimitConfigUpdateResponse()

        // Register enhanced error schemas
        r.schemas["APIError"] = GetAPIError()
        r.schemas["ValidationError"] = GetValidationError()
        r.schemas["ValidationErrorResponse"] = GetValidationErrorResponse()
        r.schemas["ResourceNotFoundError"] = GetResourceNotFoundError()
        r.schemas["ConflictError"] = GetConflictError()
        r.schemas["RateLimitError"] = GetRateLimitError()</span>
}

// GetAllSchemas returns all registered schemas
func (r *Registry) GetAllSchemas() map[string]interface{} <span class="cov0" title="0">{
        return r.schemas
}</span>

// GetSchema returns a specific schema by name
func (r *Registry) GetSchema(name string) (interface{}, error) <span class="cov0" title="0">{
        schema, exists := r.schemas[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("schema '%s' not found", name)
        }</span>
        <span class="cov0" title="0">return schema, nil</span>
}

// HasSchema checks if a schema exists
func (r *Registry) HasSchema(name string) bool <span class="cov0" title="0">{
        _, exists := r.schemas[name]
        return exists
}</span>

// ListSchemas returns a list of all schema names
func (r *Registry) ListSchemas() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(r.schemas))
        for name := range r.schemas </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// GetSchemasByCategory returns schemas grouped by category
func (r *Registry) GetSchemasByCategory() map[string][]string <span class="cov0" title="0">{
        categories := map[string][]string{
                "Common":          {},
                "Docker":          {},
                "System":          {},
                "Storage":         {},
                "VM":              {},
                "WebSocket":       {},
                "Auth":            {},
                "AsyncOperations": {},
                "RateLimiting":    {},
                "Errors":          {},
                "Responses":       {},
        }

        for name := range r.schemas </span><span class="cov0" title="0">{
                switch </span>{
                case isCommonSchema(name):<span class="cov0" title="0">
                        categories["Common"] = append(categories["Common"], name)</span>
                case isDockerSchema(name):<span class="cov0" title="0">
                        categories["Docker"] = append(categories["Docker"], name)</span>
                case isSystemSchema(name):<span class="cov0" title="0">
                        categories["System"] = append(categories["System"], name)</span>
                case isStorageSchema(name):<span class="cov0" title="0">
                        categories["Storage"] = append(categories["Storage"], name)</span>
                case isVMSchema(name):<span class="cov0" title="0">
                        categories["VM"] = append(categories["VM"], name)</span>
                case isWebSocketSchema(name):<span class="cov0" title="0">
                        categories["WebSocket"] = append(categories["WebSocket"], name)</span>
                case isAuthSchema(name):<span class="cov0" title="0">
                        categories["Auth"] = append(categories["Auth"], name)</span>
                case isAsyncOperationSchema(name):<span class="cov0" title="0">
                        categories["AsyncOperations"] = append(categories["AsyncOperations"], name)</span>
                case isRateLimitingSchema(name):<span class="cov0" title="0">
                        categories["RateLimiting"] = append(categories["RateLimiting"], name)</span>
                case isErrorSchema(name):<span class="cov0" title="0">
                        categories["Errors"] = append(categories["Errors"], name)</span>
                default:<span class="cov0" title="0">
                        categories["Responses"] = append(categories["Responses"], name)</span>
                }
        }

        <span class="cov0" title="0">return categories</span>
}

// Helper functions to categorize schemas
func isCommonSchema(name string) bool <span class="cov0" title="0">{
        commonSchemas := []string{
                "StandardResponse", "PaginationInfo", "ResponseMeta",
                "HealthResponse", "Error", "SuccessResponse",
        }
        for _, schema := range commonSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isDockerSchema(name string) bool <span class="cov0" title="0">{
        dockerSchemas := []string{
                "ContainerInfo", "ContainerState", "ContainerOperationResult",
                "ContainerOperationResponse", "BulkOperationRequest", "BulkOperationResponse",
                "BulkOperationSummary", "DockerImage", "DockerNetwork", "DockerInfo",
                "ContainerPort",
        }
        for _, schema := range dockerSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isSystemSchema(name string) bool <span class="cov0" title="0">{
        systemSchemas := []string{
                "SystemInfo", "CPUInfo", "MemoryInfo", "TemperatureData", "FanData",
                "GPUInfo", "UPSInfo", "NetworkInfo", "SystemResources", "FilesystemInfo",
                "SystemScript", "ExecuteRequest", "ExecuteResponse", "LogEntry",
                "SensorChip", "FanInput", "TemperatureInput",
        }
        for _, schema := range systemSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isStorageSchema(name string) bool <span class="cov0" title="0">{
        storageSchemas := []string{
                "ArrayInfo", "DiskInfo", "SMARTData", "ParityInfo", "ParityCheckInfo",
                "CacheInfo", "ZFSPoolInfo", "ZFSDatasetInfo", "ArrayOperation",
                "ArrayStatus", "DiskTemperature", "StorageOverview",
        }
        for _, schema := range storageSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isVMSchema(name string) bool <span class="cov0" title="0">{
        vmSchemas := []string{
                "VMInfo", "VMState", "VMOperation", "VMOperationResponse", "VMResources",
                "VMDisk", "VMNetwork", "VMConfig", "VMStats", "VMSnapshot",
                "BulkVMOperation", "BulkVMResponse",
        }
        for _, schema := range vmSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isWebSocketSchema(name string) bool <span class="cov0" title="0">{
        wsSchemas := []string{
                "WebSocketMessage", "WebSocketEvent", "WebSocketSubscription",
                "WebSocketError", "WebSocketStats", "WebSocketConnection",
        }
        for _, schema := range wsSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isAuthSchema(name string) bool <span class="cov0" title="0">{
        authSchemas := []string{
                "LoginRequest", "LoginResponse", "TokenResponse", "RefreshRequest",
                "UserInfo", "APIKeyInfo", "AuthError",
        }
        for _, schema := range authSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isAsyncOperationSchema(name string) bool <span class="cov0" title="0">{
        asyncSchemas := []string{
                "AsyncOperationRequest", "AsyncOperationResponse", "AsyncOperationDetailResponse",
                "AsyncOperationListResponse", "AsyncOperationCancelResponse", "AsyncOperationStatsResponse",
        }
        for _, schema := range asyncSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isRateLimitingSchema(name string) bool <span class="cov0" title="0">{
        rateLimitSchemas := []string{
                "RateLimitStatsResponse", "RateLimitConfigResponse", "RateLimitConfigUpdate",
                "RateLimitConfigUpdateResponse",
        }
        for _, schema := range rateLimitSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isErrorSchema(name string) bool <span class="cov0" title="0">{
        errorSchemas := []string{
                "APIError", "ValidationError", "ValidationErrorResponse",
                "ResourceNotFoundError", "ConflictError", "RateLimitError",
        }
        for _, schema := range errorSchemas </span><span class="cov0" title="0">{
                if name == schema </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package schemas

// GetStorageSchemas returns storage management schemas
func GetStorageSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "ArrayInfo":       getArrayInfoSchema(),
                "DiskInfo":        getDiskInfoSchema(),
                "SMARTData":       getSMARTDataSchema(),
                "ParityInfo":      getParityInfoSchema(),
                "ParityCheckInfo": getParityCheckInfoSchema(),
                "CacheInfo":       getCacheInfoSchema(),
                "ZFSPoolInfo":     getZFSPoolInfoSchema(),
                "ZFSDatasetInfo":  getZFSDatasetInfoSchema(),
                "ArrayOperation":  getArrayOperationSchema(),
                "ArrayStatus":     getArrayStatusSchema(),
                "DiskTemperature": getDiskTemperatureSchema(),
                "StorageOverview": getStorageOverviewSchema(),
        }
}</span>

func getArrayInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Array status",
                                "enum":        []string{"started", "stopped", "starting", "stopping"},
                                "example":     "started",
                        },
                        "state": map[string]interface{}{
                                "type":        "string",
                                "description": "Array state",
                                "enum":        []string{"normal", "degraded", "invalid", "emulated"},
                                "example":     "normal",
                        },
                        "num_disks": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of data disks",
                                "example":     6,
                                "minimum":     0,
                        },
                        "num_parity": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of parity disks",
                                "example":     2,
                                "minimum":     0,
                                "maximum":     2,
                        },
                        "size": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total array size in bytes",
                                "example":     48000000000000,
                                "minimum":     0,
                        },
                        "free": map[string]interface{}{
                                "type":        "integer",
                                "description": "Free space in bytes",
                                "example":     24000000000000,
                                "minimum":     0,
                        },
                        "used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used space in bytes",
                                "example":     24000000000000,
                                "minimum":     0,
                        },
                        "usage_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "Usage percentage",
                                "example":     50.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"status", "state", "num_disks", "num_parity", "last_updated"},
        }
}</span>

func getDiskInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk name",
                                "example":     "disk1",
                                "pattern":     "^(disk|parity|cache)\\d*$",
                        },
                        "device": map[string]interface{}{
                                "type":        "string",
                                "description": "Device path",
                                "example":     "/dev/sda",
                        },
                        "serial": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk serial number",
                                "example":     "WD-WCC4N7XXXXXX",
                        },
                        "model": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk model",
                                "example":     "WDC WD80EFAX-68LHPN0",
                        },
                        "size": map[string]interface{}{
                                "type":        "integer",
                                "description": "Disk size in bytes",
                                "example":     8000000000000,
                                "minimum":     0,
                        },
                        "used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used space in bytes",
                                "example":     4000000000000,
                                "minimum":     0,
                        },
                        "free": map[string]interface{}{
                                "type":        "integer",
                                "description": "Free space in bytes",
                                "example":     4000000000000,
                                "minimum":     0,
                        },
                        "usage_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "Usage percentage",
                                "example":     50.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "temperature": map[string]interface{}{
                                "type":        "number",
                                "description": "Disk temperature in Celsius",
                                "example":     35.0,
                        },
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk status",
                                "enum":        []string{"active", "standby", "spun_down", "error", "missing"},
                                "example":     "active",
                        },
                        "filesystem": map[string]interface{}{
                                "type":        "string",
                                "description": "Filesystem type",
                                "example":     "xfs",
                        },
                        "smart": map[string]interface{}{
                                "$ref": "#/components/schemas/SMARTData",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"name", "device", "size", "status", "last_updated"},
        }
}</span>

func getSMARTDataSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "overall_health": map[string]interface{}{
                                "type":        "string",
                                "description": "Overall SMART health status",
                                "enum":        []string{"PASSED", "FAILED", "UNKNOWN"},
                                "example":     "PASSED",
                        },
                        "temperature": map[string]interface{}{
                                "type":        "number",
                                "description": "Current temperature in Celsius",
                                "example":     35.0,
                        },
                        "power_on_hours": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total power-on hours",
                                "example":     8760,
                                "minimum":     0,
                        },
                        "power_cycle_count": map[string]interface{}{
                                "type":        "integer",
                                "description": "Power cycle count",
                                "example":     100,
                                "minimum":     0,
                        },
                        "reallocated_sectors": map[string]interface{}{
                                "type":        "integer",
                                "description": "Reallocated sector count",
                                "example":     0,
                                "minimum":     0,
                        },
                        "pending_sectors": map[string]interface{}{
                                "type":        "integer",
                                "description": "Current pending sector count",
                                "example":     0,
                                "minimum":     0,
                        },
                        "uncorrectable_errors": map[string]interface{}{
                                "type":        "integer",
                                "description": "Offline uncorrectable error count",
                                "example":     0,
                                "minimum":     0,
                        },
                        "last_test_result": map[string]interface{}{
                                "type":        "string",
                                "description": "Last self-test result",
                                "example":     "Completed without error",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last SMART data update",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"overall_health", "last_updated"},
        }
}</span>

func getParityInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "parity1": map[string]interface{}{
                                "$ref": "#/components/schemas/DiskInfo",
                        },
                        "parity2": map[string]interface{}{
                                "$ref": "#/components/schemas/DiskInfo",
                        },
                        "check_status": map[string]interface{}{
                                "$ref": "#/components/schemas/ParityCheckInfo",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"last_updated"},
        }
}</span>

func getParityCheckInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Parity check status",
                                "enum":        []string{"idle", "running", "paused", "cancelled"},
                                "example":     "idle",
                        },
                        "progress": map[string]interface{}{
                                "type":        "number",
                                "description": "Check progress percentage",
                                "example":     0.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "speed": map[string]interface{}{
                                "type":        "integer",
                                "description": "Check speed in bytes per second",
                                "example":     150000000,
                                "minimum":     0,
                        },
                        "eta": map[string]interface{}{
                                "type":        "integer",
                                "description": "Estimated time to completion in seconds",
                                "example":     0,
                                "minimum":     0,
                        },
                        "errors": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of errors found",
                                "example":     0,
                                "minimum":     0,
                        },
                        "last_check": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last parity check timestamp",
                                "example":     "2025-06-01T02:00:00Z",
                        },
                        "duration": map[string]interface{}{
                                "type":        "integer",
                                "description": "Last check duration in seconds",
                                "example":     28800,
                                "minimum":     0,
                        },
                        "scheduled": map[string]interface{}{
                                "type":        "string",
                                "description": "Next scheduled check",
                                "example":     "Monthly on 1st at 02:00",
                        },
                },
                "required": []string{"status", "progress", "errors"},
        }
}</span>

func getCacheInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "disks": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/DiskInfo",
                                },
                                "description": "Cache disks",
                        },
                        "pool_status": map[string]interface{}{
                                "type":        "string",
                                "description": "Cache pool status",
                                "enum":        []string{"online", "degraded", "offline", "faulted"},
                                "example":     "online",
                        },
                        "total_size": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total cache size in bytes",
                                "example":     1000000000000,
                                "minimum":     0,
                        },
                        "used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used cache space in bytes",
                                "example":     500000000000,
                                "minimum":     0,
                        },
                        "free": map[string]interface{}{
                                "type":        "integer",
                                "description": "Free cache space in bytes",
                                "example":     500000000000,
                                "minimum":     0,
                        },
                        "usage_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "Cache usage percentage",
                                "example":     50.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"disks", "pool_status", "last_updated"},
        }
}</span>

func getZFSPoolInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "ZFS pool name",
                                "example":     "tank",
                        },
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Pool status",
                                "enum":        []string{"ONLINE", "DEGRADED", "FAULTED", "OFFLINE", "UNAVAIL", "REMOVED"},
                                "example":     "ONLINE",
                        },
                        "health": map[string]interface{}{
                                "type":        "string",
                                "description": "Pool health",
                                "enum":        []string{"ONLINE", "DEGRADED", "FAULTED", "OFFLINE", "UNAVAIL", "REMOVED"},
                                "example":     "ONLINE",
                        },
                        "size": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total pool size in bytes",
                                "example":     2000000000000,
                                "minimum":     0,
                        },
                        "allocated": map[string]interface{}{
                                "type":        "integer",
                                "description": "Allocated space in bytes",
                                "example":     1000000000000,
                                "minimum":     0,
                        },
                        "free": map[string]interface{}{
                                "type":        "integer",
                                "description": "Free space in bytes",
                                "example":     1000000000000,
                                "minimum":     0,
                        },
                        "fragmentation": map[string]interface{}{
                                "type":        "number",
                                "description": "Pool fragmentation percentage",
                                "example":     15.5,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "capacity": map[string]interface{}{
                                "type":        "number",
                                "description": "Pool capacity percentage",
                                "example":     50.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "dedup_ratio": map[string]interface{}{
                                "type":        "number",
                                "description": "Deduplication ratio",
                                "example":     1.0,
                                "minimum":     1.0,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"name", "status", "health", "size", "last_updated"},
        }
}</span>

func getZFSDatasetInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Dataset name",
                                "example":     "tank/data",
                        },
                        "type": map[string]interface{}{
                                "type":        "string",
                                "description": "Dataset type",
                                "enum":        []string{"filesystem", "volume", "snapshot"},
                                "example":     "filesystem",
                        },
                        "used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used space in bytes",
                                "example":     500000000000,
                                "minimum":     0,
                        },
                        "available": map[string]interface{}{
                                "type":        "integer",
                                "description": "Available space in bytes",
                                "example":     1500000000000,
                                "minimum":     0,
                        },
                        "referenced": map[string]interface{}{
                                "type":        "integer",
                                "description": "Referenced space in bytes",
                                "example":     500000000000,
                                "minimum":     0,
                        },
                        "compression": map[string]interface{}{
                                "type":        "string",
                                "description": "Compression algorithm",
                                "example":     "lz4",
                        },
                        "mountpoint": map[string]interface{}{
                                "type":        "string",
                                "description": "Dataset mountpoint",
                                "example":     "/mnt/tank/data",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"name", "type", "used", "available", "last_updated"},
        }
}</span>

func getArrayOperationSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "description": "Array operation to perform",
                                "enum":        []string{"start", "stop"},
                                "example":     "start",
                        },
                        "force": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Force the operation (use with caution)",
                                "example":     false,
                                "default":     false,
                        },
                },
                "required": []string{"operation"},
        }
}</span>

func getArrayStatusSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the operation was successful",
                                "example":     true,
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Operation result message",
                                "example":     "Array started successfully",
                        },
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Current array status",
                                "enum":        []string{"started", "stopped", "starting", "stopping"},
                                "example":     "started",
                        },
                        "warnings": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "Any warnings from the operation",
                                "example":     []string{"Disk temperature high"},
                        },
                },
                "required": []string{"success", "message", "status"},
        }
}</span>

func getDiskTemperatureSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "disk": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk identifier",
                                "example":     "disk1",
                        },
                        "device": map[string]interface{}{
                                "type":        "string",
                                "description": "Device path",
                                "example":     "/dev/sda",
                        },
                        "temperature": map[string]interface{}{
                                "type":        "number",
                                "description": "Current temperature in Celsius",
                                "example":     35.0,
                        },
                        "max_temperature": map[string]interface{}{
                                "type":        "number",
                                "description": "Maximum safe temperature",
                                "example":     60.0,
                        },
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "Temperature status",
                                "enum":        []string{"normal", "warm", "hot", "critical"},
                                "example":     "normal",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"disk", "device", "temperature", "status", "last_updated"},
        }
}</span>

func getStorageOverviewSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "array": map[string]interface{}{
                                "$ref": "#/components/schemas/ArrayInfo",
                        },
                        "parity": map[string]interface{}{
                                "$ref": "#/components/schemas/ParityInfo",
                        },
                        "cache": map[string]interface{}{
                                "$ref": "#/components/schemas/CacheInfo",
                        },
                        "disks": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/DiskInfo",
                                },
                                "description": "All disks in the system",
                        },
                        "zfs_pools": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/ZFSPoolInfo",
                                },
                                "description": "ZFS pools (if available)",
                        },
                        "total_capacity": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total storage capacity in bytes",
                                "example":     50000000000000,
                                "minimum":     0,
                        },
                        "total_used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total used storage in bytes",
                                "example":     25000000000000,
                                "minimum":     0,
                        },
                        "total_free": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total free storage in bytes",
                                "example":     25000000000000,
                                "minimum":     0,
                        },
                        "overall_usage_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "Overall storage usage percentage",
                                "example":     50.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"array", "disks", "total_capacity", "total_used", "total_free", "last_updated"},
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package schemas

// GetSystemSchemas returns system monitoring and control schemas
func GetSystemSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "SystemInfo":       getSystemInfoSchema(),
                "CPUInfo":          getCPUInfoSchema(),
                "MemoryInfo":       getMemoryInfoSchema(),
                "TemperatureData":  getTemperatureDataSchema(),
                "FanData":          getFanDataSchema(),
                "GPUInfo":          getGPUInfoSchema(),
                "UPSInfo":          getUPSInfoSchema(),
                "NetworkInfo":      getNetworkInfoSchema(),
                "SystemResources":  getSystemResourcesSchema(),
                "FilesystemInfo":   getFilesystemInfoSchema(),
                "SystemScript":     getSystemScriptSchema(),
                "ExecuteRequest":   getExecuteRequestSchema(),
                "ExecuteResponse":  getExecuteResponseSchema(),
                "LogEntry":         getLogEntrySchema(),
                "SensorChip":       getSensorChipSchema(),
                "FanInput":         getFanInputSchema(),
                "TemperatureInput": getTemperatureInputSchema(),
        }
}</span>

func getSystemInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "hostname": map[string]interface{}{
                                "type":        "string",
                                "description": "System hostname",
                                "example":     "unraid-server",
                        },
                        "kernel": map[string]interface{}{
                                "type":        "string",
                                "description": "Kernel version",
                                "example":     "5.19.17-Unraid",
                        },
                        "uptime": map[string]interface{}{
                                "type":        "integer",
                                "description": "System uptime in seconds",
                                "example":     86400,
                                "minimum":     0,
                        },
                        "load_average": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "number",
                                },
                                "description": "Load average (1, 5, 15 minutes)",
                                "example":     []float64{0.5, 0.7, 0.8},
                                "minItems":    3,
                                "maxItems":    3,
                        },
                        "architecture": map[string]interface{}{
                                "type":        "string",
                                "description": "System architecture",
                                "example":     "x86_64",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"hostname", "kernel", "uptime", "load_average"},
        }
}</span>

func getCPUInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "usage_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "CPU usage percentage",
                                "example":     25.5,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "cores": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of CPU cores",
                                "example":     8,
                                "minimum":     1,
                        },
                        "threads": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of CPU threads",
                                "example":     16,
                                "minimum":     1,
                        },
                        "model": map[string]interface{}{
                                "type":        "string",
                                "description": "CPU model name",
                                "example":     "Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz",
                        },
                        "frequency": map[string]interface{}{
                                "type":        "number",
                                "description": "Current CPU frequency in MHz",
                                "example":     3700.0,
                                "minimum":     0,
                        },
                        "temperature": map[string]interface{}{
                                "type":        "number",
                                "description": "CPU temperature in Celsius",
                                "example":     45.5,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"usage_percent", "cores", "last_updated"},
        }
}</span>

func getMemoryInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "total": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total memory in bytes",
                                "example":     34359738368,
                                "minimum":     0,
                        },
                        "available": map[string]interface{}{
                                "type":        "integer",
                                "description": "Available memory in bytes",
                                "example":     17179869184,
                                "minimum":     0,
                        },
                        "used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used memory in bytes",
                                "example":     17179869184,
                                "minimum":     0,
                        },
                        "usage_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "Memory usage percentage",
                                "example":     50.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "buffers": map[string]interface{}{
                                "type":        "integer",
                                "description": "Buffer memory in bytes",
                                "example":     1073741824,
                                "minimum":     0,
                        },
                        "cached": map[string]interface{}{
                                "type":        "integer",
                                "description": "Cached memory in bytes",
                                "example":     2147483648,
                                "minimum":     0,
                        },
                        "swap_total": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total swap in bytes",
                                "example":     4294967296,
                                "minimum":     0,
                        },
                        "swap_used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used swap in bytes",
                                "example":     0,
                                "minimum":     0,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"total", "available", "used", "usage_percent", "last_updated"},
        }
}</span>

func getTemperatureDataSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "sensors": map[string]interface{}{
                                "type":        "object",
                                "description": "Temperature sensors by chip",
                                "additionalProperties": map[string]interface{}{
                                        "$ref": "#/components/schemas/SensorChip",
                                },
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"sensors", "last_updated"},
        }
}</span>

func getSensorChipSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Sensor chip name",
                                "example":     "coretemp-isa-0000",
                        },
                        "temperatures": map[string]interface{}{
                                "type": "object",
                                "additionalProperties": map[string]interface{}{
                                        "$ref": "#/components/schemas/TemperatureInput",
                                },
                                "description": "Temperature inputs",
                        },
                },
        }
}</span>

func getTemperatureInputSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "label": map[string]interface{}{
                                "type":        "string",
                                "description": "Temperature sensor label",
                                "example":     "Core 0",
                        },
                        "current": map[string]interface{}{
                                "type":        "number",
                                "description": "Current temperature in Celsius",
                                "example":     45.0,
                        },
                        "high": map[string]interface{}{
                                "type":        "number",
                                "description": "High temperature threshold",
                                "example":     100.0,
                        },
                        "critical": map[string]interface{}{
                                "type":        "number",
                                "description": "Critical temperature threshold",
                                "example":     105.0,
                        },
                },
                "required": []string{"label", "current"},
        }
}</span>

func getFanDataSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "fans": map[string]interface{}{
                                "type":        "object",
                                "description": "Fan sensors",
                                "additionalProperties": map[string]interface{}{
                                        "$ref": "#/components/schemas/FanInput",
                                },
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"fans", "last_updated"},
        }
}</span>

func getFanInputSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "label": map[string]interface{}{
                                "type":        "string",
                                "description": "Fan label",
                                "example":     "CPU Fan",
                        },
                        "current": map[string]interface{}{
                                "type":        "number",
                                "description": "Current fan speed in RPM",
                                "example":     1200.0,
                                "minimum":     0,
                        },
                        "min": map[string]interface{}{
                                "type":        "number",
                                "description": "Minimum fan speed",
                                "example":     0.0,
                        },
                        "max": map[string]interface{}{
                                "type":        "number",
                                "description": "Maximum fan speed",
                                "example":     3000.0,
                        },
                },
                "required": []string{"label", "current"},
        }
}</span>

func getUPSInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "UPS status",
                                "enum":        []string{"online", "onbatt", "lowbatt", "unknown"},
                                "example":     "online",
                        },
                        "battery_charge": map[string]interface{}{
                                "type":        "number",
                                "description": "Battery charge percentage",
                                "example":     95.0,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "battery_runtime": map[string]interface{}{
                                "type":        "integer",
                                "description": "Estimated battery runtime in minutes",
                                "example":     45,
                                "minimum":     0,
                        },
                        "load_percent": map[string]interface{}{
                                "type":        "number",
                                "description": "UPS load percentage",
                                "example":     25.5,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "input_voltage": map[string]interface{}{
                                "type":        "number",
                                "description": "Input voltage",
                                "example":     230.0,
                        },
                        "output_voltage": map[string]interface{}{
                                "type":        "number",
                                "description": "Output voltage",
                                "example":     230.0,
                        },
                        "model": map[string]interface{}{
                                "type":        "string",
                                "description": "UPS model",
                                "example":     "APC Smart-UPS 1500",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"status", "last_updated"},
        }
}</span>

func getGPUInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "gpus": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "id": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "GPU ID",
                                                        "example":     "0",
                                                },
                                                "name": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "GPU name",
                                                        "example":     "NVIDIA GeForce RTX 3080",
                                                },
                                                "utilization": map[string]interface{}{
                                                        "type":        "number",
                                                        "description": "GPU utilization percentage",
                                                        "example":     15.5,
                                                        "minimum":     0,
                                                        "maximum":     100,
                                                },
                                                "memory_used": map[string]interface{}{
                                                        "type":        "integer",
                                                        "description": "Used GPU memory in bytes",
                                                        "example":     2147483648,
                                                        "minimum":     0,
                                                },
                                                "memory_total": map[string]interface{}{
                                                        "type":        "integer",
                                                        "description": "Total GPU memory in bytes",
                                                        "example":     10737418240,
                                                        "minimum":     0,
                                                },
                                                "temperature": map[string]interface{}{
                                                        "type":        "number",
                                                        "description": "GPU temperature in Celsius",
                                                        "example":     65.0,
                                                },
                                        },
                                },
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"gpus", "last_updated"},
        }
}</span>

func getNetworkInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "interfaces": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "name": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Interface name",
                                                        "example":     "eth0",
                                                },
                                                "ip_address": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "IP address",
                                                        "example":     "192.168.1.100",
                                                },
                                                "mac_address": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "MAC address",
                                                        "example":     "00:11:22:33:44:55",
                                                },
                                                "status": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Interface status",
                                                        "enum":        []string{"up", "down"},
                                                        "example":     "up",
                                                },
                                                "speed": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Interface speed",
                                                        "example":     "1000Mbps",
                                                },
                                        },
                                },
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"interfaces", "last_updated"},
        }
}</span>

func getSystemResourcesSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "cpu": map[string]interface{}{
                                "$ref": "#/components/schemas/CPUInfo",
                        },
                        "memory": map[string]interface{}{
                                "$ref": "#/components/schemas/MemoryInfo",
                        },
                        "load_average": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "number",
                                },
                                "description": "Load average (1, 5, 15 minutes)",
                                "example":     []float64{0.5, 0.7, 0.8},
                        },
                        "processes": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of running processes",
                                "example":     150,
                                "minimum":     0,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"cpu", "memory", "last_updated"},
        }
}</span>

func getFilesystemInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "filesystems": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "device": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Device name",
                                                        "example":     "/dev/sda1",
                                                },
                                                "mountpoint": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Mount point",
                                                        "example":     "/mnt/disk1",
                                                },
                                                "fstype": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Filesystem type",
                                                        "example":     "xfs",
                                                },
                                                "size": map[string]interface{}{
                                                        "type":        "integer",
                                                        "description": "Total size in bytes",
                                                        "example":     1099511627776,
                                                        "minimum":     0,
                                                },
                                                "used": map[string]interface{}{
                                                        "type":        "integer",
                                                        "description": "Used space in bytes",
                                                        "example":     549755813888,
                                                        "minimum":     0,
                                                },
                                                "available": map[string]interface{}{
                                                        "type":        "integer",
                                                        "description": "Available space in bytes",
                                                        "example":     549755813888,
                                                        "minimum":     0,
                                                },
                                                "usage_percent": map[string]interface{}{
                                                        "type":        "number",
                                                        "description": "Usage percentage",
                                                        "example":     50.0,
                                                        "minimum":     0,
                                                        "maximum":     100,
                                                },
                                        },
                                },
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"filesystems", "last_updated"},
        }
}</span>

func getSystemScriptSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Script name",
                                "example":     "backup_script",
                        },
                        "path": map[string]interface{}{
                                "type":        "string",
                                "description": "Script file path",
                                "example":     "/boot/config/plugins/user.scripts/scripts/backup_script/script",
                        },
                        "description": map[string]interface{}{
                                "type":        "string",
                                "description": "Script description",
                                "example":     "Daily backup script",
                        },
                        "executable": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the script is executable",
                                "example":     true,
                        },
                },
                "required": []string{"name", "path"},
        }
}</span>

func getExecuteRequestSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "command": map[string]interface{}{
                                "type":        "string",
                                "description": "Command to execute",
                                "example":     "ls -la /mnt/user",
                                "maxLength":   1000,
                        },
                        "timeout": map[string]interface{}{
                                "type":        "integer",
                                "description": "Command timeout in seconds",
                                "example":     30,
                                "minimum":     1,
                                "maximum":     300,
                                "default":     30,
                        },
                },
                "required": []string{"command"},
        }
}</span>

func getExecuteResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the command executed successfully",
                                "example":     true,
                        },
                        "exit_code": map[string]interface{}{
                                "type":        "integer",
                                "description": "Command exit code",
                                "example":     0,
                        },
                        "stdout": map[string]interface{}{
                                "type":        "string",
                                "description": "Command standard output",
                                "example":     "total 4\ndrwxrwxrwx 1 root root 28 Jun 16 14:30 .",
                        },
                        "stderr": map[string]interface{}{
                                "type":        "string",
                                "description": "Command standard error",
                                "example":     "",
                        },
                        "duration": map[string]interface{}{
                                "type":        "number",
                                "description": "Command execution duration in seconds",
                                "example":     0.125,
                                "minimum":     0,
                        },
                },
                "required": []string{"success", "exit_code", "stdout", "stderr", "duration"},
        }
}</span>

func getLogEntrySchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Log entry timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "level": map[string]interface{}{
                                "type":        "string",
                                "description": "Log level",
                                "enum":        []string{"debug", "info", "warn", "error", "fatal"},
                                "example":     "info",
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Log message",
                                "example":     "System startup completed",
                        },
                        "source": map[string]interface{}{
                                "type":        "string",
                                "description": "Log source/component",
                                "example":     "kernel",
                        },
                        "facility": map[string]interface{}{
                                "type":        "string",
                                "description": "Syslog facility",
                                "example":     "daemon",
                        },
                },
                "required": []string{"timestamp", "level", "message"},
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package schemas

// GetVMSchemas returns virtual machine management schemas
func GetVMSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "VMInfo":              getVMInfoSchema(),
                "VMState":             getVMStateSchema(),
                "VMOperation":         getVMOperationSchema(),
                "VMOperationResponse": getVMOperationResponseSchema(),
                "VMResources":         getVMResourcesSchema(),
                "VMDisk":              getVMDiskSchema(),
                "VMNetwork":           getVMNetworkSchema(),
                "VMConfig":            getVMConfigSchema(),
                "VMStats":             getVMStatsSchema(),
                "VMSnapshot":          getVMSnapshotSchema(),
                "BulkVMOperation":     getBulkVMOperationSchema(),
                "BulkVMResponse":      getBulkVMResponseSchema(),
        }
}</span>

func getVMInfoSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "VM identifier",
                                "example":     "vm-001",
                        },
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "VM name",
                                "example":     "Windows-10-Gaming",
                                "pattern":     "^[a-zA-Z0-9][a-zA-Z0-9_.-]+$",
                        },
                        "description": map[string]interface{}{
                                "type":        "string",
                                "description": "VM description",
                                "example":     "Windows 10 gaming virtual machine",
                        },
                        "state": map[string]interface{}{
                                "$ref": "#/components/schemas/VMState",
                        },
                        "os_type": map[string]interface{}{
                                "type":        "string",
                                "description": "Operating system type",
                                "enum":        []string{"windows", "linux", "macos", "other"},
                                "example":     "windows",
                        },
                        "template": map[string]interface{}{
                                "type":        "string",
                                "description": "VM template used",
                                "example":     "Windows 10",
                        },
                        "resources": map[string]interface{}{
                                "$ref": "#/components/schemas/VMResources",
                        },
                        "disks": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/VMDisk",
                                },
                                "description": "VM disk attachments",
                        },
                        "networks": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/VMNetwork",
                                },
                                "description": "VM network interfaces",
                        },
                        "created": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "VM creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"id", "name", "state", "os_type", "resources", "created", "last_updated"},
        }
}</span>

func getVMStateSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "status": map[string]interface{}{
                                "type":        "string",
                                "description": "VM status",
                                "enum":        []string{"running", "stopped", "paused", "suspended", "starting", "stopping", "error"},
                                "example":     "running",
                        },
                        "uptime": map[string]interface{}{
                                "type":        "integer",
                                "description": "VM uptime in seconds",
                                "example":     3600,
                                "minimum":     0,
                        },
                        "cpu_usage": map[string]interface{}{
                                "type":        "number",
                                "description": "CPU usage percentage",
                                "example":     25.5,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "memory_usage": map[string]interface{}{
                                "type":        "number",
                                "description": "Memory usage percentage",
                                "example":     45.2,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "memory_used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used memory in bytes",
                                "example":     4294967296,
                                "minimum":     0,
                        },
                        "vnc_port": map[string]interface{}{
                                "type":        "integer",
                                "description": "VNC port number",
                                "example":     5900,
                                "minimum":     5900,
                                "maximum":     6000,
                        },
                        "autostart": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether VM starts automatically",
                                "example":     true,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last state update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"status", "last_updated"},
        }
}</span>

func getVMResourcesSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "vcpus": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of virtual CPUs",
                                "example":     4,
                                "minimum":     1,
                                "maximum":     64,
                        },
                        "memory": map[string]interface{}{
                                "type":        "integer",
                                "description": "Allocated memory in bytes",
                                "example":     8589934592,
                                "minimum":     134217728,
                        },
                        "memory_mb": map[string]interface{}{
                                "type":        "integer",
                                "description": "Allocated memory in MB",
                                "example":     8192,
                                "minimum":     128,
                        },
                        "cpu_mode": map[string]interface{}{
                                "type":        "string",
                                "description": "CPU mode",
                                "enum":        []string{"host-passthrough", "host-model", "custom"},
                                "example":     "host-passthrough",
                        },
                        "cpu_topology": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "sockets": map[string]interface{}{
                                                "type":    "integer",
                                                "example": 1,
                                                "minimum": 1,
                                        },
                                        "cores": map[string]interface{}{
                                                "type":    "integer",
                                                "example": 4,
                                                "minimum": 1,
                                        },
                                        "threads": map[string]interface{}{
                                                "type":    "integer",
                                                "example": 1,
                                                "minimum": 1,
                                        },
                                },
                        },
                        "machine_type": map[string]interface{}{
                                "type":        "string",
                                "description": "Machine type",
                                "example":     "pc-q35-6.2",
                        },
                        "bios": map[string]interface{}{
                                "type":        "string",
                                "description": "BIOS type",
                                "enum":        []string{"seabios", "ovmf"},
                                "example":     "ovmf",
                        },
                },
                "required": []string{"vcpus", "memory", "memory_mb"},
        }
}</span>

func getVMDiskSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "device": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk device name",
                                "example":     "vda",
                        },
                        "source": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk source path",
                                "example":     "/mnt/user/domains/Windows-10-Gaming/vdisk1.img",
                        },
                        "type": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk type",
                                "enum":        []string{"file", "block", "network"},
                                "example":     "file",
                        },
                        "bus": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk bus type",
                                "enum":        []string{"virtio", "sata", "ide", "scsi"},
                                "example":     "virtio",
                        },
                        "format": map[string]interface{}{
                                "type":        "string",
                                "description": "Disk format",
                                "enum":        []string{"raw", "qcow2", "vmdk", "vdi"},
                                "example":     "raw",
                        },
                        "size": map[string]interface{}{
                                "type":        "integer",
                                "description": "Disk size in bytes",
                                "example":     107374182400,
                                "minimum":     0,
                        },
                        "readonly": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether disk is read-only",
                                "example":     false,
                        },
                        "bootable": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether disk is bootable",
                                "example":     true,
                        },
                },
                "required": []string{"device", "source", "type", "bus"},
        }
}</span>

func getVMNetworkSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "interface": map[string]interface{}{
                                "type":        "string",
                                "description": "Network interface name",
                                "example":     "vnet0",
                        },
                        "type": map[string]interface{}{
                                "type":        "string",
                                "description": "Network type",
                                "enum":        []string{"bridge", "network", "direct"},
                                "example":     "bridge",
                        },
                        "source": map[string]interface{}{
                                "type":        "string",
                                "description": "Network source",
                                "example":     "br0",
                        },
                        "model": map[string]interface{}{
                                "type":        "string",
                                "description": "Network model",
                                "enum":        []string{"virtio", "e1000", "rtl8139"},
                                "example":     "virtio",
                        },
                        "mac_address": map[string]interface{}{
                                "type":        "string",
                                "description": "MAC address",
                                "example":     "52:54:00:12:34:56",
                                "pattern":     "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$",
                        },
                        "link_state": map[string]interface{}{
                                "type":        "string",
                                "description": "Link state",
                                "enum":        []string{"up", "down"},
                                "example":     "up",
                        },
                },
                "required": []string{"interface", "type", "source", "model"},
        }
}</span>

func getVMOperationSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "description": "VM operation to perform",
                                "enum":        []string{"start", "stop", "restart", "pause", "resume", "suspend", "reset"},
                                "example":     "start",
                        },
                        "force": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Force the operation",
                                "example":     false,
                                "default":     false,
                        },
                },
                "required": []string{"operation"},
        }
}</span>

func getVMOperationResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "success": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether the operation was successful",
                                "example":     true,
                        },
                        "message": map[string]interface{}{
                                "type":        "string",
                                "description": "Operation result message",
                                "example":     "VM started successfully",
                        },
                        "vm_id": map[string]interface{}{
                                "type":        "string",
                                "description": "VM identifier",
                                "example":     "vm-001",
                        },
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "description": "Operation that was performed",
                                "example":     "start",
                        },
                        "state": map[string]interface{}{
                                "type":        "string",
                                "description": "Current VM state after operation",
                                "example":     "running",
                        },
                },
                "required": []string{"success", "message", "vm_id", "operation"},
        }
}</span>

func getVMConfigSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "VM name",
                                "example":     "Windows-10-Gaming",
                        },
                        "description": map[string]interface{}{
                                "type":        "string",
                                "description": "VM description",
                                "example":     "Windows 10 gaming virtual machine",
                        },
                        "os_type": map[string]interface{}{
                                "type":        "string",
                                "description": "Operating system type",
                                "enum":        []string{"windows", "linux", "macos", "other"},
                                "example":     "windows",
                        },
                        "autostart": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether VM starts automatically",
                                "example":     true,
                        },
                        "resources": map[string]interface{}{
                                "$ref": "#/components/schemas/VMResources",
                        },
                        "disks": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/VMDisk",
                                },
                        },
                        "networks": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "$ref": "#/components/schemas/VMNetwork",
                                },
                        },
                },
                "required": []string{"name", "os_type", "resources"},
        }
}</span>

func getVMStatsSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "vm_id": map[string]interface{}{
                                "type":        "string",
                                "description": "VM identifier",
                                "example":     "vm-001",
                        },
                        "cpu_usage": map[string]interface{}{
                                "type":        "number",
                                "description": "CPU usage percentage",
                                "example":     25.5,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "memory_usage": map[string]interface{}{
                                "type":        "number",
                                "description": "Memory usage percentage",
                                "example":     45.2,
                                "minimum":     0,
                                "maximum":     100,
                        },
                        "memory_used": map[string]interface{}{
                                "type":        "integer",
                                "description": "Used memory in bytes",
                                "example":     4294967296,
                                "minimum":     0,
                        },
                        "memory_total": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total allocated memory in bytes",
                                "example":     8589934592,
                                "minimum":     0,
                        },
                        "disk_read": map[string]interface{}{
                                "type":        "integer",
                                "description": "Disk read bytes",
                                "example":     1073741824,
                                "minimum":     0,
                        },
                        "disk_write": map[string]interface{}{
                                "type":        "integer",
                                "description": "Disk write bytes",
                                "example":     536870912,
                                "minimum":     0,
                        },
                        "network_rx": map[string]interface{}{
                                "type":        "integer",
                                "description": "Network received bytes",
                                "example":     268435456,
                                "minimum":     0,
                        },
                        "network_tx": map[string]interface{}{
                                "type":        "integer",
                                "description": "Network transmitted bytes",
                                "example":     134217728,
                                "minimum":     0,
                        },
                        "uptime": map[string]interface{}{
                                "type":        "integer",
                                "description": "VM uptime in seconds",
                                "example":     3600,
                                "minimum":     0,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"vm_id", "cpu_usage", "memory_usage", "last_updated"},
        }
}</span>

func getVMSnapshotSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "name": map[string]interface{}{
                                "type":        "string",
                                "description": "Snapshot name",
                                "example":     "pre-update-snapshot",
                        },
                        "description": map[string]interface{}{
                                "type":        "string",
                                "description": "Snapshot description",
                                "example":     "Snapshot before system update",
                        },
                        "state": map[string]interface{}{
                                "type":        "string",
                                "description": "VM state when snapshot was taken",
                                "enum":        []string{"running", "shutoff", "paused"},
                                "example":     "shutoff",
                        },
                        "creation_time": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Snapshot creation timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "parent": map[string]interface{}{
                                "type":        "string",
                                "description": "Parent snapshot name",
                                "example":     "base-snapshot",
                        },
                        "current": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether this is the current snapshot",
                                "example":     true,
                        },
                },
                "required": []string{"name", "state", "creation_time"},
        }
}</span>

func getBulkVMOperationSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "vm_ids": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "Array of VM IDs or names",
                                "example":     []string{"vm-001", "vm-002", "Windows-10-Gaming"},
                                "minItems":    1,
                                "maxItems":    20,
                                "uniqueItems": true,
                        },
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "description": "Operation to perform on all VMs",
                                "enum":        []string{"start", "stop", "restart", "pause", "resume"},
                                "example":     "start",
                        },
                        "force": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Force the operation",
                                "example":     false,
                                "default":     false,
                        },
                },
                "required": []string{"vm_ids", "operation"},
        }
}</span>

func getBulkVMResponseSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "summary": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "total": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Total number of VMs processed",
                                                "example":     3,
                                                "minimum":     0,
                                        },
                                        "successful": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Number of successful operations",
                                                "example":     2,
                                                "minimum":     0,
                                        },
                                        "failed": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Number of failed operations",
                                                "example":     1,
                                                "minimum":     0,
                                        },
                                        "operation": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Operation performed",
                                                "example":     "start",
                                        },
                                },
                                "required": []string{"total", "successful", "failed", "operation"},
                        },
                        "results": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "vm_id": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "VM identifier",
                                                        "example":     "vm-001",
                                                },
                                                "success": map[string]interface{}{
                                                        "type":        "boolean",
                                                        "description": "Whether the operation was successful",
                                                        "example":     true,
                                                },
                                                "message": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Operation result message",
                                                        "example":     "VM started successfully",
                                                },
                                                "error": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Error message if operation failed",
                                                        "example":     "VM not found",
                                                },
                                                "state": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Current VM state after operation",
                                                        "example":     "running",
                                                },
                                        },
                                        "required": []string{"vm_id", "success", "message"},
                                },
                                "description": "Individual operation results",
                        },
                },
                "required": []string{"summary", "results"},
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package schemas

// GetWebSocketSchemas returns WebSocket-related schemas
func GetWebSocketSchemas() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "WebSocketMessage":      getWebSocketMessageSchema(),
                "WebSocketEvent":        getWebSocketEventSchema(),
                "WebSocketSubscription": getWebSocketSubscriptionSchema(),
                "WebSocketError":        getWebSocketErrorSchema(),
                "WebSocketStats":        getWebSocketStatsSchema(),
                "WebSocketConnection":   getWebSocketConnectionSchema(),
        }
}</span>

func getWebSocketMessageSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "type": map[string]interface{}{
                                "type":        "string",
                                "description": "Message type",
                                "enum":        []string{"event", "data", "error", "ping", "pong", "subscribe", "unsubscribe"},
                                "example":     "event",
                        },
                        "event": map[string]interface{}{
                                "type":        "string",
                                "description": "Event name",
                                "example":     "system.stats",
                        },
                        "data": map[string]interface{}{
                                "description": "Message data payload",
                                "example": map[string]interface{}{
                                        "cpu_usage":    25.5,
                                        "memory_usage": 45.2,
                                        "timestamp":    "2025-06-16T14:30:00Z",
                                },
                        },
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Message timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Message ID for tracking",
                                "example":     "msg_1234567890",
                        },
                        "channel": map[string]interface{}{
                                "type":        "string",
                                "description": "WebSocket channel",
                                "example":     "system.stats",
                        },
                },
                "required": []string{"type", "timestamp"},
        }
}</span>

func getWebSocketEventSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "event": map[string]interface{}{
                                "type":        "string",
                                "description": "Event name",
                                "enum": []string{
                                        "system.stats", "docker.container.start", "docker.container.stop",
                                        "storage.array.status", "vm.state.change", "ups.status.change",
                                        "temperature.alert", "disk.smart.warning",
                                },
                                "example": "docker.container.start",
                        },
                        "source": map[string]interface{}{
                                "type":        "string",
                                "description": "Event source",
                                "enum":        []string{"system", "docker", "storage", "vm", "ups", "monitoring"},
                                "example":     "docker",
                        },
                        "severity": map[string]interface{}{
                                "type":        "string",
                                "description": "Event severity",
                                "enum":        []string{"info", "warning", "error", "critical"},
                                "example":     "info",
                        },
                        "data": map[string]interface{}{
                                "description": "Event-specific data",
                                "example": map[string]interface{}{
                                        "container_id":   "plex",
                                        "container_name": "plex",
                                        "status":         "running",
                                },
                        },
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Event timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "correlation_id": map[string]interface{}{
                                "type":        "string",
                                "description": "Correlation ID for tracking related events",
                                "example":     "corr_1234567890",
                        },
                },
                "required": []string{"event", "source", "severity", "timestamp"},
        }
}</span>

func getWebSocketSubscriptionSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "action": map[string]interface{}{
                                "type":        "string",
                                "description": "Subscription action",
                                "enum":        []string{"subscribe", "unsubscribe"},
                                "example":     "subscribe",
                        },
                        "channels": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                        "enum": []string{
                                                "system.stats", "docker.events", "storage.status",
                                                "vm.events", "ups.status", "temperature.alerts",
                                                "disk.smart", "network.stats",
                                        },
                                },
                                "description": "Channels to subscribe/unsubscribe",
                                "example":     []string{"system.stats", "docker.events"},
                                "minItems":    1,
                                "maxItems":    10,
                                "uniqueItems": true,
                        },
                        "filters": map[string]interface{}{
                                "type": "object",
                                "description": "Optional filters for events",
                                "properties": map[string]interface{}{
                                        "severity": map[string]interface{}{
                                                "type": "array",
                                                "items": map[string]interface{}{
                                                        "type": "string",
                                                        "enum": []string{"info", "warning", "error", "critical"},
                                                },
                                                "description": "Filter by event severity",
                                        },
                                        "source": map[string]interface{}{
                                                "type": "array",
                                                "items": map[string]interface{}{
                                                        "type": "string",
                                                        "enum": []string{"system", "docker", "storage", "vm", "ups"},
                                                },
                                                "description": "Filter by event source",
                                        },
                                        "container_ids": map[string]interface{}{
                                                "type": "array",
                                                "items": map[string]interface{}{
                                                        "type": "string",
                                                },
                                                "description": "Filter Docker events by container IDs",
                                        },
                                },
                        },
                        "rate_limit": map[string]interface{}{
                                "type":        "integer",
                                "description": "Maximum events per second (0 = no limit)",
                                "example":     10,
                                "minimum":     0,
                                "maximum":     100,
                                "default":     0,
                        },
                },
                "required": []string{"action", "channels"},
        }
}</span>

func getWebSocketErrorSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "error": map[string]interface{}{
                                "type":        "string",
                                "description": "Error message",
                                "example":     "Invalid subscription channel",
                        },
                        "code": map[string]interface{}{
                                "type":        "string",
                                "description": "Error code",
                                "enum": []string{
                                        "INVALID_MESSAGE", "INVALID_CHANNEL", "SUBSCRIPTION_FAILED",
                                        "RATE_LIMITED", "AUTHENTICATION_REQUIRED", "PERMISSION_DENIED",
                                },
                                "example": "INVALID_CHANNEL",
                        },
                        "details": map[string]interface{}{
                                "type":        "object",
                                "description": "Additional error details",
                                "additionalProperties": true,
                                "example": map[string]interface{}{
                                        "channel": "invalid.channel",
                                        "reason":  "Channel does not exist",
                                },
                        },
                        "timestamp": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Error timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"error", "code", "timestamp"},
        }
}</span>

func getWebSocketStatsSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "connections": map[string]interface{}{
                                "type":        "integer",
                                "description": "Number of active WebSocket connections",
                                "example":     5,
                                "minimum":     0,
                        },
                        "subscriptions": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total number of active subscriptions",
                                "example":     15,
                                "minimum":     0,
                        },
                        "messages_sent": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total messages sent since startup",
                                "example":     1000,
                                "minimum":     0,
                        },
                        "messages_received": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total messages received since startup",
                                "example":     250,
                                "minimum":     0,
                        },
                        "events_published": map[string]interface{}{
                                "type":        "integer",
                                "description": "Total events published since startup",
                                "example":     750,
                                "minimum":     0,
                        },
                        "channels": map[string]interface{}{
                                "type": "object",
                                "description": "Per-channel statistics",
                                "additionalProperties": map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "subscribers": map[string]interface{}{
                                                        "type":    "integer",
                                                        "minimum": 0,
                                                },
                                                "messages": map[string]interface{}{
                                                        "type":    "integer",
                                                        "minimum": 0,
                                                },
                                        },
                                },
                                "example": map[string]interface{}{
                                        "system.stats": map[string]interface{}{
                                                "subscribers": 3,
                                                "messages":    500,
                                        },
                                        "docker.events": map[string]interface{}{
                                                "subscribers": 2,
                                                "messages":    250,
                                        },
                                },
                        },
                        "uptime": map[string]interface{}{
                                "type":        "integer",
                                "description": "WebSocket server uptime in seconds",
                                "example":     3600,
                                "minimum":     0,
                        },
                        "last_updated": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last update timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"connections", "subscriptions", "messages_sent", "messages_received", "uptime", "last_updated"},
        }
}</span>

func getWebSocketConnectionSchema() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Connection ID",
                                "example":     "conn_1234567890",
                        },
                        "remote_addr": map[string]interface{}{
                                "type":        "string",
                                "description": "Client IP address",
                                "example":     "192.168.1.100",
                        },
                        "user_agent": map[string]interface{}{
                                "type":        "string",
                                "description": "Client user agent",
                                "example":     "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                        },
                        "connected_at": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Connection timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                        "subscriptions": map[string]interface{}{
                                "type": "array",
                                "items": map[string]interface{}{
                                        "type": "string",
                                },
                                "description": "Active subscriptions",
                                "example":     []string{"system.stats", "docker.events"},
                        },
                        "messages_sent": map[string]interface{}{
                                "type":        "integer",
                                "description": "Messages sent to this connection",
                                "example":     100,
                                "minimum":     0,
                        },
                        "messages_received": map[string]interface{}{
                                "type":        "integer",
                                "description": "Messages received from this connection",
                                "example":     10,
                                "minimum":     0,
                        },
                        "last_activity": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Last activity timestamp",
                                "example":     "2025-06-16T14:30:00Z",
                        },
                },
                "required": []string{"id", "remote_addr", "connected_at", "subscriptions", "last_activity"},
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package api

import (
        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/lib"
        "github.com/domalab/uma/daemon/logger"
)

func (a *Api) getOrigin() *dto.Origin <span class="cov0" title="0">{
        if a.origin == nil </span><span class="cov0" title="0">{
                origin, err := lib.GetOrigin()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Yellow(" unable to get origin: %s", err)
                }</span>
                <span class="cov0" title="0">a.origin = origin</span>
        }

        <span class="cov0" title="0">return a.origin</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package api

import (
        "net/http"
        "strings"

        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/logger"
        "github.com/domalab/uma/daemon/services/auth"
)

// OperationRateLimitMiddleware creates middleware for operation-specific rate limiting
func (h *HTTPServer) OperationRateLimitMiddleware(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Get client IP
                clientIP := getClientIPFromRequest(r)

                // Determine operation type from request path and method
                operationType := getOperationTypeFromRequest(r)

                // Check operation-specific rate limit
                if !h.api.operationRateLimiter.Allow(clientIP, operationType) </span><span class="cov0" title="0">{
                        // Create structured error response
                        apiError := dto.NewAPIError(
                                dto.ErrCodeRateLimitExceeded,
                                "Operation-specific rate limit exceeded",
                                http.StatusTooManyRequests,
                        ).WithDetails(map[string]interface{}{
                                "operation_type": string(operationType),
                                "client_ip":      clientIP,
                                "limit":          h.api.operationRateLimiter.GetLimit(operationType),
                        })

                        h.writeAPIError(w, apiError)
                        return
                }</span>

                // Log rate limit check for expensive operations
                <span class="cov0" title="0">if isExpensiveOperation(operationType) </span><span class="cov0" title="0">{
                        logger.Blue("Rate limit check passed for %s operation from %s", operationType, clientIP)
                }</span>

                // Continue to next handler
                <span class="cov0" title="0">next(w, r)</span>
        }
}

// getOperationTypeFromRequest determines the operation type from the request
func getOperationTypeFromRequest(r *http.Request) auth.OperationType <span class="cov0" title="0">{
        path := r.URL.Path
        method := r.Method

        // Handle method-specific operations
        switch </span>{
        // Async operations - method-specific
        case path == "/api/v1/operations" &amp;&amp; method == "POST":<span class="cov0" title="0">
                return auth.OpTypeAsyncCreate</span>
        case path == "/api/v1/operations" &amp;&amp; method == "GET":<span class="cov0" title="0">
                return auth.OpTypeAsyncList</span>
        case strings.HasPrefix(path, "/api/v1/operations/") &amp;&amp; method == "DELETE":<span class="cov0" title="0">
                return auth.OpTypeAsyncCancel</span>

        // Docker operations - method-specific
        case strings.HasPrefix(path, "/api/v1/docker/containers/") &amp;&amp; (method == "POST" || method == "PUT"):<span class="cov0" title="0">
                return auth.OpTypeDockerControl</span>
        case path == "/api/v1/docker/bulk":<span class="cov0" title="0">
                return auth.OpTypeDockerBulk</span>

        // VM operations - method-specific
        case strings.HasPrefix(path, "/api/v1/vms/") &amp;&amp; (method == "POST" || method == "PUT"):<span class="cov0" title="0">
                return auth.OpTypeVMControl</span>
        case path == "/api/v1/vms/bulk":<span class="cov0" title="0">
                return auth.OpTypeVMBulk</span>

        // Array control operations
        case (path == "/api/v1/storage/array/start" || path == "/api/v1/storage/array/stop") &amp;&amp; method == "POST":<span class="cov0" title="0">
                return auth.OpTypeArrayControl</span>

        // Parity operations
        case strings.Contains(path, "/parity") &amp;&amp; method == "POST":<span class="cov0" title="0">
                return auth.OpTypeParityCheck</span>

        // System control operations
        case (path == "/api/v1/system/reboot" || path == "/api/v1/system/shutdown") &amp;&amp; method == "POST":<span class="cov0" title="0">
                return auth.OpTypeSystemControl</span>

        default:<span class="cov0" title="0">
                // Fall back to path-based detection
                return auth.GetOperationTypeFromPath(path)</span>
        }
}

// isExpensiveOperation checks if an operation is considered expensive
func isExpensiveOperation(operationType auth.OperationType) bool <span class="cov0" title="0">{
        expensiveOps := []auth.OperationType{
                auth.OpTypeSMARTData,
                auth.OpTypeParityCheck,
                auth.OpTypeArrayControl,
                auth.OpTypeDockerBulk,
                auth.OpTypeVMBulk,
                auth.OpTypeSystemControl,
        }

        for _, expensiveOp := range expensiveOps </span><span class="cov0" title="0">{
                if operationType == expensiveOp </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// getClientIPFromRequest extracts client IP from request
func getClientIPFromRequest(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header first
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                // Take the first IP if multiple are present
                if idx := strings.Index(xff, ","); idx != -1 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(xff[:idx])
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(xff)</span>
        }

        // Check X-Real-IP header
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(xri)
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">if idx := strings.LastIndex(r.RemoteAddr, ":"); idx != -1 </span><span class="cov0" title="0">{
                return r.RemoteAddr[:idx]
        }</span>
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

// writeAPIError writes a structured API error response
func (h *HTTPServer) writeAPIError(w http.ResponseWriter, apiError *dto.APIError) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(apiError.HTTPStatus)

        // Create standard error response
        errorResponse := map[string]interface{}{
                "error": map[string]interface{}{
                        "code":    apiError.Code,
                        "message": apiError.Message,
                        "details": apiError.Details,
                },
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "api_version": "v1",
                },
        }

        h.writeJSON(w, apiError.HTTPStatus, errorResponse)
}</span>

// RateLimitStatsHandler handles GET /api/v1/rate-limits/stats
func (h *HTTPServer) RateLimitStatsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        h.handleCORS(w, r)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return</span>
        }

        // Get stats from both rate limiters
        <span class="cov0" title="0">generalStats := map[string]interface{}{
                "type": "general",
                // Add general rate limiter stats here if available
        }

        operationStats := h.api.operationRateLimiter.GetStats()
        operationStats["type"] = "operation_specific"

        response := map[string]interface{}{
                "general_rate_limiter":   generalStats,
                "operation_rate_limiter": operationStats,
        }

        // Create standard response
        standardResponse := map[string]interface{}{
                "data": response,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "api_version": "v1",
                },
        }

        h.writeJSON(w, http.StatusOK, standardResponse)</span>
}

// RateLimitConfigHandler handles GET/PUT /api/v1/rate-limits/config
func (h *HTTPServer) RateLimitConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case "GET":<span class="cov0" title="0">
                h.getRateLimitConfig(w, r)</span>
        case "PUT":<span class="cov0" title="0">
                h.updateRateLimitConfig(w, r)</span>
        case "OPTIONS":<span class="cov0" title="0">
                h.handleCORS(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// getRateLimitConfig returns current rate limit configuration
func (h *HTTPServer) getRateLimitConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get current limits for all operation types
        operationTypes := []auth.OperationType{
                auth.OpTypeGeneral,
                auth.OpTypeHealthCheck,
                auth.OpTypeSMARTData,
                auth.OpTypeParityCheck,
                auth.OpTypeArrayControl,
                auth.OpTypeDiskInfo,
                auth.OpTypeDockerList,
                auth.OpTypeDockerControl,
                auth.OpTypeDockerBulk,
                auth.OpTypeVMList,
                auth.OpTypeVMControl,
                auth.OpTypeVMBulk,
                auth.OpTypeSystemInfo,
                auth.OpTypeSystemControl,
                auth.OpTypeSensorData,
                auth.OpTypeAsyncCreate,
                auth.OpTypeAsyncList,
                auth.OpTypeAsyncCancel,
        }

        config := make(map[string]interface{})
        for _, opType := range operationTypes </span><span class="cov0" title="0">{
                limit := h.api.operationRateLimiter.GetLimit(opType)
                config[string(opType)] = map[string]interface{}{
                        "requests": limit.Requests,
                        "window":   limit.Window.String(),
                }
        }</span>

        // Create standard response
        <span class="cov0" title="0">standardResponse := map[string]interface{}{
                "data": config,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "api_version": "v1",
                },
        }

        h.writeJSON(w, http.StatusOK, standardResponse)</span>
}

// updateRateLimitConfig updates rate limit configuration
func (h *HTTPServer) updateRateLimitConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // This would require admin authentication in a real implementation
        // For now, just return a placeholder response

        response := map[string]interface{}{
                "message": "Rate limit configuration update not implemented yet",
                "note":    "This endpoint would require admin authentication",
        }

        standardResponse := map[string]interface{}{
                "data": response,
                "meta": map[string]interface{}{
                        "timestamp":   getCurrentTimestamp(),
                        "api_version": "v1",
                },
        }

        h.writeJSON(w, http.StatusNotImplemented, standardResponse)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package utils

import (
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// MetricsCollector provides utilities for collecting and exposing metrics
type MetricsCollector struct {
        registry *prometheus.Registry
}

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector() *MetricsCollector <span class="cov0" title="0">{
        return &amp;MetricsCollector{
                registry: prometheus.NewRegistry(),
        }
}</span>

// GetHandler returns the Prometheus metrics HTTP handler
func (mc *MetricsCollector) GetHandler() http.Handler <span class="cov0" title="0">{
        return promhttp.HandlerFor(mc.registry, promhttp.HandlerOpts{})
}</span>

// RegisterMetrics registers custom metrics with the collector
func (mc *MetricsCollector) RegisterMetrics(collectors ...prometheus.Collector) error <span class="cov0" title="0">{
        for _, collector := range collectors </span><span class="cov0" title="0">{
                if err := mc.registry.Register(collector); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CreateCounterVec creates a new counter vector metric
func (mc *MetricsCollector) CreateCounterVec(name, help string, labels []string) *prometheus.CounterVec <span class="cov0" title="0">{
        counter := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: name,
                        Help: help,
                },
                labels,
        )
        mc.registry.MustRegister(counter)
        return counter
}</span>

// CreateGaugeVec creates a new gauge vector metric
func (mc *MetricsCollector) CreateGaugeVec(name, help string, labels []string) *prometheus.GaugeVec <span class="cov0" title="0">{
        gauge := prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: name,
                        Help: help,
                },
                labels,
        )
        mc.registry.MustRegister(gauge)
        return gauge
}</span>

// CreateHistogramVec creates a new histogram vector metric
func (mc *MetricsCollector) CreateHistogramVec(name, help string, labels []string, buckets []float64) *prometheus.HistogramVec <span class="cov0" title="0">{
        if buckets == nil </span><span class="cov0" title="0">{
                buckets = prometheus.DefBuckets
        }</span>
        
        <span class="cov0" title="0">histogram := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    name,
                        Help:    help,
                        Buckets: buckets,
                },
                labels,
        )
        mc.registry.MustRegister(histogram)
        return histogram</span>
}

// SystemMetrics holds system-related metrics
type SystemMetrics struct {
        CPUUsage        prometheus.Gauge
        MemoryUsage     prometheus.Gauge
        DiskUsage       *prometheus.GaugeVec
        NetworkTraffic  *prometheus.CounterVec
        Temperature     *prometheus.GaugeVec
        FanSpeed        *prometheus.GaugeVec
        UPSStatus       *prometheus.GaugeVec
}

// NewSystemMetrics creates system metrics
func NewSystemMetrics(collector *MetricsCollector) *SystemMetrics <span class="cov0" title="0">{
        return &amp;SystemMetrics{
                CPUUsage: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "uma_system_cpu_usage_percent",
                        Help: "Current CPU usage percentage",
                }),
                MemoryUsage: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "uma_system_memory_usage_percent",
                        Help: "Current memory usage percentage",
                }),
                DiskUsage: collector.CreateGaugeVec(
                        "uma_system_disk_usage_percent",
                        "Disk usage percentage by device",
                        []string{"device", "mount_point"},
                ),
                NetworkTraffic: collector.CreateCounterVec(
                        "uma_system_network_bytes_total",
                        "Total network traffic in bytes",
                        []string{"interface", "direction"},
                ),
                Temperature: collector.CreateGaugeVec(
                        "uma_system_temperature_celsius",
                        "System temperature in Celsius",
                        []string{"sensor"},
                ),
                FanSpeed: collector.CreateGaugeVec(
                        "uma_system_fan_speed_rpm",
                        "Fan speed in RPM",
                        []string{"fan"},
                ),
                UPSStatus: collector.CreateGaugeVec(
                        "uma_system_ups_status",
                        "UPS status metrics",
                        []string{"metric"},
                ),
        }
}</span>

// StorageMetrics holds storage-related metrics
type StorageMetrics struct {
        ArrayStatus     prometheus.Gauge
        DiskHealth      *prometheus.GaugeVec
        ParityCheck     *prometheus.GaugeVec
        CacheUsage      *prometheus.GaugeVec
        ShareUsage      *prometheus.GaugeVec
}

// NewStorageMetrics creates storage metrics
func NewStorageMetrics(collector *MetricsCollector) *StorageMetrics <span class="cov0" title="0">{
        return &amp;StorageMetrics{
                ArrayStatus: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "uma_storage_array_status",
                        Help: "Unraid array status (1=started, 0=stopped)",
                }),
                DiskHealth: collector.CreateGaugeVec(
                        "uma_storage_disk_health",
                        "Disk health status",
                        []string{"device", "type"},
                ),
                ParityCheck: collector.CreateGaugeVec(
                        "uma_storage_parity_check",
                        "Parity check metrics",
                        []string{"metric"},
                ),
                CacheUsage: collector.CreateGaugeVec(
                        "uma_storage_cache_usage_percent",
                        "Cache usage percentage",
                        []string{"cache_pool"},
                ),
                ShareUsage: collector.CreateGaugeVec(
                        "uma_storage_share_usage_percent",
                        "Share usage percentage",
                        []string{"share"},
                ),
        }
}</span>

// DockerMetrics holds Docker-related metrics
type DockerMetrics struct {
        ContainerStatus *prometheus.GaugeVec
        ContainerCPU    *prometheus.GaugeVec
        ContainerMemory *prometheus.GaugeVec
        ImageCount      prometheus.Gauge
        NetworkCount    prometheus.Gauge
        VolumeCount     prometheus.Gauge
}

// NewDockerMetrics creates Docker metrics
func NewDockerMetrics(collector *MetricsCollector) *DockerMetrics <span class="cov0" title="0">{
        return &amp;DockerMetrics{
                ContainerStatus: collector.CreateGaugeVec(
                        "uma_docker_container_status",
                        "Docker container status (1=running, 0=stopped)",
                        []string{"container_name", "container_id"},
                ),
                ContainerCPU: collector.CreateGaugeVec(
                        "uma_docker_container_cpu_percent",
                        "Docker container CPU usage percentage",
                        []string{"container_name", "container_id"},
                ),
                ContainerMemory: collector.CreateGaugeVec(
                        "uma_docker_container_memory_bytes",
                        "Docker container memory usage in bytes",
                        []string{"container_name", "container_id"},
                ),
                ImageCount: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "uma_docker_images_total",
                        Help: "Total number of Docker images",
                }),
                NetworkCount: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "uma_docker_networks_total",
                        Help: "Total number of Docker networks",
                }),
                VolumeCount: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "uma_docker_volumes_total",
                        Help: "Total number of Docker volumes",
                }),
        }
}</span>

// VMMetrics holds VM-related metrics
type VMMetrics struct {
        VMStatus   *prometheus.GaugeVec
        VMCPU      *prometheus.GaugeVec
        VMMemory   *prometheus.GaugeVec
        VMDisk     *prometheus.GaugeVec
        VMNetwork  *prometheus.CounterVec
}

// NewVMMetrics creates VM metrics
func NewVMMetrics(collector *MetricsCollector) *VMMetrics <span class="cov0" title="0">{
        return &amp;VMMetrics{
                VMStatus: collector.CreateGaugeVec(
                        "uma_vm_status",
                        "VM status (1=running, 0=stopped)",
                        []string{"vm_name"},
                ),
                VMCPU: collector.CreateGaugeVec(
                        "uma_vm_cpu_percent",
                        "VM CPU usage percentage",
                        []string{"vm_name"},
                ),
                VMMemory: collector.CreateGaugeVec(
                        "uma_vm_memory_bytes",
                        "VM memory usage in bytes",
                        []string{"vm_name"},
                ),
                VMDisk: collector.CreateGaugeVec(
                        "uma_vm_disk_bytes",
                        "VM disk I/O in bytes",
                        []string{"vm_name", "direction"},
                ),
                VMNetwork: collector.CreateCounterVec(
                        "uma_vm_network_bytes_total",
                        "VM network traffic in bytes",
                        []string{"vm_name", "direction"},
                ),
        }
}</span>

// MetricsUpdater provides methods to update metrics
type MetricsUpdater struct {
        System  *SystemMetrics
        Storage *StorageMetrics
        Docker  *DockerMetrics
        VM      *VMMetrics
}

// NewMetricsUpdater creates a new metrics updater
func NewMetricsUpdater(collector *MetricsCollector) *MetricsUpdater <span class="cov0" title="0">{
        system := NewSystemMetrics(collector)
        storage := NewStorageMetrics(collector)
        docker := NewDockerMetrics(collector)
        vm := NewVMMetrics(collector)

        // Register all metrics
        collector.registry.MustRegister(
                system.CPUUsage,
                system.MemoryUsage,
                storage.ArrayStatus,
                docker.ImageCount,
                docker.NetworkCount,
                docker.VolumeCount,
        )

        return &amp;MetricsUpdater{
                System:  system,
                Storage: storage,
                Docker:  docker,
                VM:      vm,
        }
}</span>

// UpdateSystemMetrics updates system-related metrics
func (mu *MetricsUpdater) UpdateSystemMetrics(api APIInterface) <span class="cov0" title="0">{
        // Update CPU usage
        if cpuInfo, err := api.GetSystem().GetCPUInfo(); err == nil </span><span class="cov0" title="0">{
                if cpuMap, ok := cpuInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if usage, ok := cpuMap["usage"].(float64); ok </span><span class="cov0" title="0">{
                                mu.System.CPUUsage.Set(usage)
                        }</span>
                }
        }

        // Update memory usage
        <span class="cov0" title="0">if memInfo, err := api.GetSystem().GetMemoryInfo(); err == nil </span><span class="cov0" title="0">{
                if memMap, ok := memInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if usage, ok := memMap["usage"].(float64); ok </span><span class="cov0" title="0">{
                                mu.System.MemoryUsage.Set(usage)
                        }</span>
                }
        }
}

// UpdateStorageMetrics updates storage-related metrics
func (mu *MetricsUpdater) UpdateStorageMetrics(api APIInterface) <span class="cov0" title="0">{
        // Update array status
        if arrayInfo, err := api.GetStorage().GetArrayInfo(); err == nil </span><span class="cov0" title="0">{
                if arrayMap, ok := arrayInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if state, ok := arrayMap["state"].(string); ok </span><span class="cov0" title="0">{
                                if state == "started" </span><span class="cov0" title="0">{
                                        mu.Storage.ArrayStatus.Set(1)
                                }</span> else<span class="cov0" title="0"> {
                                        mu.Storage.ArrayStatus.Set(0)
                                }</span>
                        }
                }
        }
}

// StartMetricsCollection starts periodic metrics collection
func (mu *MetricsUpdater) StartMetricsCollection(api APIInterface, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        go func() </span><span class="cov0" title="0">{
                for range ticker.C </span><span class="cov0" title="0">{
                        mu.UpdateSystemMetrics(api)
                        mu.UpdateStorageMetrics(api)
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package utils

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/logger"
        "github.com/domalab/uma/daemon/services/api/types/responses"
)

// WriteJSON writes a JSON response
func WriteJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                logger.Yellow("Error encoding JSON response: %v", err)
        }</span>
}

// WriteError writes an error response
func WriteError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        errorResponse := dto.Response{
                Error:   message,
                Message: http.StatusText(status),
        }
        WriteJSON(w, status, errorResponse)
}</span>

// WriteStandardResponse writes a standardized API response
func WriteStandardResponse(w http.ResponseWriter, status int, data interface{}, pagination *responses.PaginationInfo, requestID string, version string) <span class="cov0" title="0">{
        response := responses.StandardResponse{
                Data:       data,
                Pagination: pagination,
                Meta: &amp;responses.ResponseMeta{
                        RequestID: requestID,
                        Version:   version,
                        Timestamp: time.Now().UTC(),
                },
        }

        WriteJSON(w, status, response)
}</span>

// WritePaginatedResponse writes a paginated API response
func WritePaginatedResponse(w http.ResponseWriter, status int, data interface{}, total int, params *dto.PaginationParams, requestID string, version string) <span class="cov0" title="0">{
        pagination := dto.CalculatePagination(total, params)

        // Convert dto.PaginationInfo to responses.PaginationInfo
        responsePagination := &amp;responses.PaginationInfo{
                Page:       pagination.Page,
                PageSize:   pagination.PerPage,
                TotalPages: pagination.TotalPages,
                TotalItems: pagination.Total,
                HasNext:    pagination.HasMore,
                HasPrev:    pagination.Page &gt; 1,
        }

        WriteStandardResponse(w, status, data, responsePagination, requestID, version)
}</span>

// WriteVersionedResponse writes a response with version-specific formatting
func WriteVersionedResponse(w http.ResponseWriter, r *http.Request, status int, data interface{}, pagination *responses.PaginationInfo, requestID string, version string) <span class="cov0" title="0">{
        switch version </span>{
        case "v1":<span class="cov0" title="0">
                // Current v1 format with standardized response structure
                WriteStandardResponse(w, status, data, pagination, requestID, version)</span>
        default:<span class="cov0" title="0">
                // Future versions can have different response formats
                WriteStandardResponse(w, status, data, pagination, requestID, version)</span>
        }
}

// WriteOperationResponse writes a generic operation response
func WriteOperationResponse(w http.ResponseWriter, status int, success bool, message string, operationID string) <span class="cov0" title="0">{
        response := responses.OperationResponse{
                Success:     success,
                Message:     message,
                OperationID: operationID,
        }
        WriteJSON(w, status, response)
}</span>

// WriteBulkOperationResponse writes a bulk operation response
func WriteBulkOperationResponse(w http.ResponseWriter, status int, results []responses.BulkOperationResult) <span class="cov0" title="0">{
        total := len(results)
        succeeded := 0
        failed := 0

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Success </span><span class="cov0" title="0">{
                        succeeded++
                }</span> else<span class="cov0" title="0"> {
                        failed++
                }</span>
        }

        <span class="cov0" title="0">response := responses.BulkOperationResponse{
                Success: failed == 0,
                Message: "Bulk operation completed",
                Results: results,
                Summary: responses.BulkOperationSummary{
                        Total:     total,
                        Succeeded: succeeded,
                        Failed:    failed,
                },
        }

        WriteJSON(w, status, response)</span>
}

// WriteHealthResponse writes a health check response
func WriteHealthResponse(w http.ResponseWriter, status string, version string, uptime string, checks map[string]responses.HealthCheck) <span class="cov0" title="0">{
        response := responses.HealthResponse{
                Status:    status,
                Version:   version,
                Uptime:    uptime,
                Timestamp: time.Now().UTC(),
                Checks:    checks,
        }

        var httpStatus int
        switch status </span>{
        case "healthy":<span class="cov0" title="0">
                httpStatus = http.StatusOK</span>
        case "degraded":<span class="cov0" title="0">
                httpStatus = http.StatusOK</span> // Still return 200 for degraded
        case "unhealthy":<span class="cov0" title="0">
                httpStatus = http.StatusServiceUnavailable</span>
        default:<span class="cov0" title="0">
                httpStatus = http.StatusInternalServerError</span>
        }

        <span class="cov0" title="0">WriteJSON(w, httpStatus, response)</span>
}

// GetRequestID gets the request ID from response header or generates one
func GetRequestID(w http.ResponseWriter) string <span class="cov0" title="0">{
        // Check if request ID was set in response headers by middleware
        if requestID := w.Header().Get("X-Request-ID"); requestID != "" </span><span class="cov0" title="0">{
                return requestID
        }</span>

        // Generate a simple request ID as fallback
        <span class="cov0" title="0">return GenerateRequestID()</span>
}

// GenerateRequestID generates a simple request ID
func GenerateRequestID() string <span class="cov0" title="0">{
        return "req_" + string(rune(time.Now().UnixNano()))
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package utils

import (
        "fmt"
        "net"
        "regexp"
        "strings"

        "github.com/domalab/uma/daemon/services/api/types/requests"
        "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func init() <span class="cov8" title="1">{
        validate = validator.New()
        
        // Register custom validators
        validate.RegisterValidation("share_name", validateShareName)
        validate.RegisterValidation("mac_address", validateMACAddress)
        validate.RegisterValidation("ip_address", validateIPAddress)
        validate.RegisterValidation("container_name", validateContainerName)
        validate.RegisterValidation("vm_name", validateVMName)
}</span>

// ValidateStruct validates a struct using the validator package
func ValidateStruct(s interface{}) error <span class="cov8" title="1">{
        return validate.Struct(s)
}</span>

// ValidateShareCreateRequest validates a share creation request
func ValidateShareCreateRequest(req *requests.ShareCreateRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("share name is required")
        }</span>

        <span class="cov0" title="0">if !IsValidShareName(req.Name) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid share name: must be 1-40 characters, alphanumeric with hyphens and underscores")
        }</span>

        // Validate allocator method
        <span class="cov0" title="0">if req.AllocatorMethod != "" </span><span class="cov0" title="0">{
                validMethods := []string{"high-water", "most-free", "fill-up"}
                if !contains(validMethods, req.AllocatorMethod) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid allocator method: must be one of %v", validMethods)
                }</span>
        }

        // Validate cache usage
        <span class="cov0" title="0">if req.UseCache != "" </span><span class="cov0" title="0">{
                validCacheOptions := []string{"yes", "no", "only", "prefer"}
                if !contains(validCacheOptions, req.UseCache) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cache usage: must be one of %v", validCacheOptions)
                }</span>
        }

        // Validate SMB security
        <span class="cov0" title="0">if req.SMBSecurity != "" </span><span class="cov0" title="0">{
                validSecurityOptions := []string{"public", "secure", "private"}
                if !contains(validSecurityOptions, req.SMBSecurity) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid SMB security: must be one of %v", validSecurityOptions)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateCommandExecuteRequest validates a command execution request
func ValidateCommandExecuteRequest(req *requests.CommandExecuteRequest) error <span class="cov0" title="0">{
        if strings.TrimSpace(req.Command) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("command is required")
        }</span>

        // Check for dangerous commands
        <span class="cov0" title="0">if IsCommandBlacklisted(req.Command) </span><span class="cov0" title="0">{
                return fmt.Errorf("command not allowed for security reasons")
        }</span>

        // Validate timeout
        <span class="cov0" title="0">if req.Timeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout cannot be negative")
        }</span>

        <span class="cov0" title="0">if req.Timeout &gt; 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout cannot exceed 300 seconds")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateDockerContainerCreateRequest validates a Docker container creation request
func ValidateDockerContainerCreateRequest(req *requests.DockerContainerCreateRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("container name is required")
        }</span>

        <span class="cov0" title="0">if req.Image == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("container image is required")
        }</span>

        <span class="cov0" title="0">if !IsValidContainerName(req.Name) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid container name")
        }</span>

        // Validate restart policy
        <span class="cov0" title="0">if req.RestartPolicy != "" </span><span class="cov0" title="0">{
                validPolicies := []string{"no", "always", "unless-stopped", "on-failure"}
                if !contains(validPolicies, req.RestartPolicy) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid restart policy: must be one of %v", validPolicies)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateVMCreateRequest validates a VM creation request
func ValidateVMCreateRequest(req *requests.VMCreateRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("VM name is required")
        }</span>

        <span class="cov0" title="0">if !IsValidVMName(req.Name) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid VM name")
        }</span>

        <span class="cov0" title="0">if req.CPUs &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("CPU count must be greater than 0")
        }</span>

        <span class="cov0" title="0">if req.Memory &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("memory must be greater than 0")
        }</span>

        // Validate storage configurations
        <span class="cov0" title="0">for i, storage := range req.Storage </span><span class="cov0" title="0">{
                if err := validateVMStorageConfig(&amp;storage); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("storage config %d: %v", i, err)
                }</span>
        }

        // Validate network configurations
        <span class="cov0" title="0">for i, network := range req.Networks </span><span class="cov0" title="0">{
                if err := validateVMNetworkConfig(&amp;network); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("network config %d: %v", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// IsValidShareName checks if a share name is valid
func IsValidShareName(name string) bool <span class="cov0" title="0">{
        if len(name) &lt; 1 || len(name) &gt; 40 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Allow alphanumeric characters, hyphens, and underscores
        <span class="cov0" title="0">matched, _ := regexp.MatchString(`^[a-zA-Z0-9_-]+$`, name)
        return matched</span>
}

// IsValidContainerName checks if a container name is valid
func IsValidContainerName(name string) bool <span class="cov0" title="0">{
        if len(name) &lt; 1 || len(name) &gt; 63 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Docker container name rules
        <span class="cov0" title="0">matched, _ := regexp.MatchString(`^[a-zA-Z0-9][a-zA-Z0-9_.-]*$`, name)
        return matched</span>
}

// IsValidVMName checks if a VM name is valid
func IsValidVMName(name string) bool <span class="cov0" title="0">{
        if len(name) &lt; 1 || len(name) &gt; 63 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // VM name rules (similar to hostname rules)
        <span class="cov0" title="0">matched, _ := regexp.MatchString(`^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$|^[a-zA-Z0-9]$`, name)
        return matched</span>
}

// IsCommandBlacklisted checks if a command is blacklisted for security
func IsCommandBlacklisted(command string) bool <span class="cov8" title="1">{
        lowerCommand := strings.ToLower(command)
        
        // Dangerous commands that should be blocked
        blacklistedCommands := []string{
                "rm -rf /",
                "dd if=",
                "mkfs",
                "fdisk",
                "parted",
                "shutdown",
                "reboot",
                "halt",
                "poweroff",
                "init 0",
                "init 6",
                "systemctl poweroff",
                "systemctl reboot",
                "systemctl halt",
        }

        for _, blocked := range blacklistedCommands </span><span class="cov8" title="1">{
                if strings.Contains(lowerCommand, blocked) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Additional security checks
        <span class="cov8" title="1">if strings.Contains(lowerCommand, "&gt;/dev/") ||
                strings.Contains(lowerCommand, "rm -rf") ||
                strings.Contains(lowerCommand, "chmod 777") ||
                strings.Contains(lowerCommand, "chown root") ||
                strings.Contains(lowerCommand, "sudo su") ||
                strings.Contains(lowerCommand, "su -") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// Helper functions

func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func validateShareName(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        return IsValidShareName(fl.Field().String())
}</span>

func validateMACAddress(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        _, err := net.ParseMAC(fl.Field().String())
        return err == nil
}</span>

func validateIPAddress(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        ip := net.ParseIP(fl.Field().String())
        return ip != nil
}</span>

func validateContainerName(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        return IsValidContainerName(fl.Field().String())
}</span>

func validateVMName(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        return IsValidVMName(fl.Field().String())
}</span>

func validateVMStorageConfig(config *requests.VMStorageConfig) error <span class="cov0" title="0">{
        if config.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage type is required")
        }</span>

        <span class="cov0" title="0">validTypes := []string{"disk", "cdrom", "floppy"}
        if !contains(validTypes, config.Type) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid storage type: must be one of %v", validTypes)
        }</span>

        <span class="cov0" title="0">if config.Source == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage source is required")
        }</span>

        <span class="cov0" title="0">if config.Target == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage target is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validateVMNetworkConfig(config *requests.VMNetworkConfig) error <span class="cov0" title="0">{
        if config.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("network type is required")
        }</span>

        <span class="cov0" title="0">validTypes := []string{"bridge", "nat", "host"}
        if !contains(validTypes, config.Type) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid network type: must be one of %v", validTypes)
        }</span>

        <span class="cov0" title="0">if config.MAC != "" </span><span class="cov0" title="0">{
                if _, err := net.ParseMAC(config.MAC); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid MAC address: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/domalab/uma/daemon/logger"
        "github.com/gorilla/websocket"
)

// WebSocketManager manages WebSocket connections and broadcasting
type WebSocketManager struct {
        connections map[string]*WebSocketConnection
        channels    map[string]map[*WebSocketConnection]bool
        mutex       sync.RWMutex
        broadcast   chan BroadcastMessage
        register    chan *WebSocketConnection
        unregister  chan *WebSocketConnection
}

// WebSocketConnection represents a WebSocket connection
type WebSocketConnection struct {
        ID       string
        Conn     *websocket.Conn
        SendChan chan []byte
        Manager  *WebSocketManager
        Channels map[string]bool
        LastPing time.Time
        mutex    sync.RWMutex
}

// BroadcastMessage represents a message to broadcast
type BroadcastMessage struct {
        Channel string
        Data    interface{}
}

// WebSocketMessage represents a WebSocket message
type WebSocketMessage struct {
        Type      string      `json:"type"`
        Channel   string      `json:"channel,omitempty"`
        Data      interface{} `json:"data,omitempty"`
        Timestamp string      `json:"timestamp"`
}

// NewWebSocketManager creates a new WebSocket manager
func NewWebSocketManager() *WebSocketManager <span class="cov0" title="0">{
        return &amp;WebSocketManager{
                connections: make(map[string]*WebSocketConnection),
                channels:    make(map[string]map[*WebSocketConnection]bool),
                broadcast:   make(chan BroadcastMessage, 256),
                register:    make(chan *WebSocketConnection),
                unregister:  make(chan *WebSocketConnection),
        }
}</span>

// Run starts the WebSocket manager
func (wsm *WebSocketManager) Run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case conn := &lt;-wsm.register:<span class="cov0" title="0">
                        wsm.registerConnection(conn)</span>

                case conn := &lt;-wsm.unregister:<span class="cov0" title="0">
                        wsm.unregisterConnection(conn)</span>

                case message := &lt;-wsm.broadcast:<span class="cov0" title="0">
                        wsm.broadcastToChannel(message.Channel, message.Data)</span>
                }
        }
}

// RegisterConnection registers a new WebSocket connection
func (wsm *WebSocketManager) RegisterConnection(conn *websocket.Conn, id string) *WebSocketConnection <span class="cov0" title="0">{
        wsConn := &amp;WebSocketConnection{
                ID:       id,
                Conn:     conn,
                SendChan: make(chan []byte, 256),
                Manager:  wsm,
                Channels: make(map[string]bool),
                LastPing: time.Now(),
        }

        wsm.register &lt;- wsConn
        return wsConn
}</span>

// Broadcast sends a message to all connections in a channel
func (wsm *WebSocketManager) Broadcast(channel string, data interface{}) <span class="cov0" title="0">{
        select </span>{
        case wsm.broadcast &lt;- BroadcastMessage{Channel: channel, Data: data}:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                logger.Yellow("WebSocket broadcast channel full, dropping message")</span>
        }
}

// GetConnectionCount returns the number of active connections
func (wsm *WebSocketManager) GetConnectionCount() int <span class="cov0" title="0">{
        wsm.mutex.RLock()
        defer wsm.mutex.RUnlock()
        return len(wsm.connections)
}</span>

// GetChannelCount returns the number of active channels
func (wsm *WebSocketManager) GetChannelCount() int <span class="cov0" title="0">{
        wsm.mutex.RLock()
        defer wsm.mutex.RUnlock()
        return len(wsm.channels)
}</span>

// registerConnection registers a connection internally
func (wsm *WebSocketManager) registerConnection(conn *WebSocketConnection) <span class="cov0" title="0">{
        wsm.mutex.Lock()
        defer wsm.mutex.Unlock()

        wsm.connections[conn.ID] = conn
        logger.Green("WebSocket connection registered: %s", conn.ID)

        // Start goroutines for this connection
        go conn.writePump()
        go conn.readPump()
}</span>

// unregisterConnection unregisters a connection internally
func (wsm *WebSocketManager) unregisterConnection(conn *WebSocketConnection) <span class="cov0" title="0">{
        wsm.mutex.Lock()
        defer wsm.mutex.Unlock()

        if _, ok := wsm.connections[conn.ID]; ok </span><span class="cov0" title="0">{
                delete(wsm.connections, conn.ID)
                close(conn.SendChan)

                // Remove from all channels
                for channel := range conn.Channels </span><span class="cov0" title="0">{
                        if connections, ok := wsm.channels[channel]; ok </span><span class="cov0" title="0">{
                                delete(connections, conn)
                                if len(connections) == 0 </span><span class="cov0" title="0">{
                                        delete(wsm.channels, channel)
                                }</span>
                        }
                }

                <span class="cov0" title="0">logger.Yellow("WebSocket connection unregistered: %s", conn.ID)</span>
        }
}

// broadcastToChannel broadcasts a message to all connections in a channel
func (wsm *WebSocketManager) broadcastToChannel(channel string, data interface{}) <span class="cov0" title="0">{
        wsm.mutex.RLock()
        connections, ok := wsm.channels[channel]
        wsm.mutex.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">message := WebSocketMessage{
                Type:      "broadcast",
                Channel:   channel,
                Data:      data,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        messageBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to marshal WebSocket message: %v", err)
                return
        }</span>

        <span class="cov0" title="0">for conn := range connections </span><span class="cov0" title="0">{
                select </span>{
                case conn.SendChan &lt;- messageBytes:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        // Connection is blocked, close it
                        wsm.unregister &lt;- conn</span>
                }
        }
}

// WebSocketConnection methods

// Subscribe subscribes the connection to a channel
func (wsc *WebSocketConnection) Subscribe(channel string) <span class="cov0" title="0">{
        wsc.mutex.Lock()
        defer wsc.mutex.Unlock()

        wsc.Channels[channel] = true

        wsc.Manager.mutex.Lock()
        defer wsc.Manager.mutex.Unlock()

        if _, ok := wsc.Manager.channels[channel]; !ok </span><span class="cov0" title="0">{
                wsc.Manager.channels[channel] = make(map[*WebSocketConnection]bool)
        }</span>
        <span class="cov0" title="0">wsc.Manager.channels[channel][wsc] = true

        logger.Green("WebSocket %s subscribed to channel: %s", wsc.ID, channel)</span>
}

// Unsubscribe unsubscribes the connection from a channel
func (wsc *WebSocketConnection) Unsubscribe(channel string) <span class="cov0" title="0">{
        wsc.mutex.Lock()
        defer wsc.mutex.Unlock()

        delete(wsc.Channels, channel)

        wsc.Manager.mutex.Lock()
        defer wsc.Manager.mutex.Unlock()

        if connections, ok := wsc.Manager.channels[channel]; ok </span><span class="cov0" title="0">{
                delete(connections, wsc)
                if len(connections) == 0 </span><span class="cov0" title="0">{
                        delete(wsc.Manager.channels, channel)
                }</span>
        }

        <span class="cov0" title="0">logger.Yellow("WebSocket %s unsubscribed from channel: %s", wsc.ID, channel)</span>
}

// Send sends a message to the connection
func (wsc *WebSocketConnection) Send(messageType string, data interface{}) error <span class="cov0" title="0">{
        message := WebSocketMessage{
                Type:      messageType,
                Data:      data,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        messageBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">select </span>{
        case wsc.SendChan &lt;- messageBytes:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return ErrWebSocketSendBlocked</span>
        }
}

// Close closes the WebSocket connection
func (wsc *WebSocketConnection) Close() <span class="cov0" title="0">{
        wsc.Manager.unregister &lt;- wsc
        wsc.Conn.Close()
}</span>

// readPump handles reading from the WebSocket connection
func (wsc *WebSocketConnection) readPump() <span class="cov0" title="0">{
        defer wsc.Close()

        wsc.Conn.SetReadLimit(512)
        wsc.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        wsc.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                wsc.LastPing = time.Now()
                wsc.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := wsc.Conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                logger.Red("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Handle incoming message
                <span class="cov0" title="0">wsc.handleMessage(message)</span>
        }
}

// writePump handles writing to the WebSocket connection
func (wsc *WebSocketConnection) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                wsc.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-wsc.SendChan:<span class="cov0" title="0">
                        wsc.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                wsc.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">if err := wsc.Conn.WriteMessage(websocket.TextMessage, message); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        wsc.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := wsc.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// handleMessage handles incoming WebSocket messages
func (wsc *WebSocketConnection) handleMessage(data []byte) <span class="cov0" title="0">{
        var message WebSocketMessage
        if err := json.Unmarshal(data, &amp;message); err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to unmarshal WebSocket message: %v", err)
                return
        }</span>

        <span class="cov0" title="0">switch message.Type </span>{
        case "subscribe":<span class="cov0" title="0">
                if message.Channel != "" </span><span class="cov0" title="0">{
                        wsc.Subscribe(message.Channel)
                }</span>
        case "unsubscribe":<span class="cov0" title="0">
                if message.Channel != "" </span><span class="cov0" title="0">{
                        wsc.Unsubscribe(message.Channel)
                }</span>
        case "ping":<span class="cov0" title="0">
                wsc.Send("pong", nil)</span>
        }
}

// Custom errors
var (
        ErrWebSocketSendBlocked = fmt.Errorf("websocket send channel blocked")
)
</pre>
		
		<pre class="file" id="file55" style="display: none">package api

import (
        "fmt"
        "strings"

        "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func init() <span class="cov8" title="1">{
        validate = validator.New()
}</span>

// BulkOperationRequestValidated represents a validated bulk operation request
type BulkOperationRequestValidated struct {
        ContainerIDs []string `json:"container_ids" validate:"required,min=1,max=50,dive,required,min=1"`
}

// validateBulkRequest validates bulk operation requests with comprehensive checks
func (h *HTTPServer) validateBulkRequest(req *BulkOperationRequest) error <span class="cov8" title="1">{
        // Convert to validated struct for validation
        validatedReq := BulkOperationRequestValidated{
                ContainerIDs: req.ContainerIDs,
        }

        // Perform struct validation
        if err := validate.Struct(validatedReq); err != nil </span><span class="cov8" title="1">{
                // Convert validation errors to user-friendly messages
                var errorMessages []string
                for _, err := range err.(validator.ValidationErrors) </span><span class="cov8" title="1">{
                        switch err.Tag() </span>{
                        case "required":<span class="cov8" title="1">
                                if err.Field() == "ContainerIDs" </span><span class="cov8" title="1">{
                                        errorMessages = append(errorMessages, "container_ids field is required")
                                }</span> else<span class="cov8" title="1"> {
                                        errorMessages = append(errorMessages, "container ID cannot be empty")
                                }</span>
                        case "min":<span class="cov8" title="1">
                                if err.Field() == "ContainerIDs" </span><span class="cov8" title="1">{
                                        errorMessages = append(errorMessages, "at least 1 container ID is required")
                                }</span> else<span class="cov0" title="0"> {
                                        errorMessages = append(errorMessages, "container ID cannot be empty")
                                }</span>
                        case "max":<span class="cov8" title="1">
                                errorMessages = append(errorMessages, "maximum 50 containers allowed per bulk operation")</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Errorf("validation failed: %s", strings.Join(errorMessages, ", "))</span>
        }

        // Custom validation for duplicate IDs
        <span class="cov8" title="1">seen := make(map[string]bool)
        for _, id := range req.ContainerIDs </span><span class="cov8" title="1">{
                if seen[id] </span><span class="cov8" title="1">{
                        return fmt.Errorf("duplicate container ID: %s", id)
                }</span>
                <span class="cov8" title="1">seen[id] = true</span>
        }

        // Custom validation for container ID format (basic check)
        <span class="cov8" title="1">for _, id := range req.ContainerIDs </span><span class="cov8" title="1">{
                if strings.TrimSpace(id) != id </span><span class="cov8" title="1">{
                        return fmt.Errorf("container ID contains leading/trailing whitespace: '%s'", id)
                }</span>
                <span class="cov8" title="1">if strings.Contains(id, " ") </span><span class="cov8" title="1">{
                        return fmt.Errorf("container ID contains spaces: '%s'", id)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateHealthCheckRequest validates health check requests (future use)
func (h *HTTPServer) validateHealthCheckRequest() error <span class="cov0" title="0">{
        // Placeholder for future health check validation
        return nil
}</span>

// validatePaginationParams validates pagination parameters
func (h *HTTPServer) validatePaginationParams(page, limit int) error <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("page must be &gt;= 1, got %d", page)
        }</span>
        <span class="cov8" title="1">if limit &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("limit must be &gt;= 1, got %d", limit)
        }</span>
        <span class="cov8" title="1">if limit &gt; 1000 </span><span class="cov8" title="1">{
                return fmt.Errorf("limit must be &lt;= 1000, got %d", limit)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateRequestID validates request ID format
func (h *HTTPServer) validateRequestID(requestID string) error <span class="cov8" title="1">{
        if len(requestID) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("request ID too long (max 255 characters)")
        }</span>

        // Check for invalid characters (basic validation)
        <span class="cov8" title="1">for _, char := range requestID </span><span class="cov8" title="1">{
                if char &lt; 32 || char &gt; 126 </span><span class="cov8" title="1">{
                        return fmt.Errorf("request ID contains invalid characters")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Enhanced validation for API versioning
func (h *HTTPServer) validateAPIVersion(version string) error <span class="cov8" title="1">{
        supportedVersions := []string{"v1"}

        for _, supported := range supportedVersions </span><span class="cov8" title="1">{
                if version == supported </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("unsupported API version: %s (supported: %s)", version, strings.Join(supportedVersions, ", "))</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package api

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/domalab/uma/daemon/dto"
        "github.com/domalab/uma/daemon/services/async"
        "github.com/go-playground/validator/v10"
)

// Enhanced validation patterns
var (
        // Docker container ID pattern (12-64 hex characters)
        containerIDPattern = regexp.MustCompile(`^[a-f0-9]{12,64}$`)
        
        // VM ID pattern (UUID or name)
        vmIDPattern = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)
        
        // Disk ID pattern (e.g., disk1, parity, cache)
        diskIDPattern = regexp.MustCompile(`^(disk\d+|parity\d*|cache\d*)$`)
        
        // Operation ID pattern (UUID)
        operationIDPattern = regexp.MustCompile(`^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$`)
)

// Custom validator functions
func validateDiskID(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        return diskIDPattern.MatchString(fl.Field().String())
}</span>

func validateContainerID(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        id := fl.Field().String()
        // Allow both short (12 chars) and full (64 chars) container IDs
        return len(id) &gt;= 12 &amp;&amp; containerIDPattern.MatchString(id)
}</span>

func validateVMID(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        return vmIDPattern.MatchString(fl.Field().String())
}</span>

func validateOperationType(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        validTypes := []async.OperationType{
                async.TypeParityCheck,
                async.TypeParityCorrect,
                async.TypeArrayStart,
                async.TypeArrayStop,
                async.TypeDiskScan,
                async.TypeSMARTScan,
                async.TypeSystemReboot,
                async.TypeSystemShutdown,
                async.TypeBulkContainer,
                async.TypeBulkVM,
        }
        
        opType := async.OperationType(fl.Field().String())
        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if opType == validType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func validateArrayState(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        validStates := []string{"started", "stopped", "invalid", "unknown"}
        state := fl.Field().String()
        for _, validState := range validStates </span><span class="cov0" title="0">{
                if state == validState </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Enhanced validation functions using custom error types

// ValidateAsyncOperationRequest validates async operation requests
func (h *HTTPServer) ValidateAsyncOperationRequest(req *async.OperationRequest) *dto.APIError <span class="cov0" title="0">{
        validationErrors := dto.NewValidationError()
        
        // Validate operation type
        if req.Type == "" </span><span class="cov0" title="0">{
                validationErrors.AddError("type", "Operation type is required")
        }</span> else<span class="cov0" title="0"> if !validateOperationType(validator.FieldLevel(nil)) </span><span class="cov0" title="0">{
                // Manual validation since we can't use the validator directly here
                validTypes := []string{
                        string(async.TypeParityCheck),
                        string(async.TypeParityCorrect),
                        string(async.TypeArrayStart),
                        string(async.TypeArrayStop),
                        string(async.TypeDiskScan),
                        string(async.TypeSMARTScan),
                        string(async.TypeSystemReboot),
                        string(async.TypeSystemShutdown),
                        string(async.TypeBulkContainer),
                        string(async.TypeBulkVM),
                }
                
                valid := false
                for _, validType := range validTypes </span><span class="cov0" title="0">{
                        if string(req.Type) == validType </span><span class="cov0" title="0">{
                                valid = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        validationErrors.AddErrorWithValue("type", 
                                fmt.Sprintf("Invalid operation type. Valid types: %s", strings.Join(validTypes, ", ")), 
                                req.Type)
                }</span>
        }
        
        // Validate description length
        <span class="cov0" title="0">if len(req.Description) &gt; 500 </span><span class="cov0" title="0">{
                validationErrors.AddErrorWithValue("description", 
                        "Description must be 500 characters or less", 
                        len(req.Description))
        }</span>
        
        // Validate parameters based on operation type
        <span class="cov0" title="0">if err := h.validateOperationParameters(req.Type, req.Parameters); err != nil </span><span class="cov0" title="0">{
                validationErrors.AddError("parameters", err.Error())
        }</span>
        
        <span class="cov0" title="0">if validationErrors.HasErrors() </span><span class="cov0" title="0">{
                return validationErrors.ToAPIError()
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// validateOperationParameters validates operation-specific parameters
func (h *HTTPServer) validateOperationParameters(opType async.OperationType, params map[string]interface{}) error <span class="cov0" title="0">{
        switch opType </span>{
        case async.TypeParityCheck, async.TypeParityCorrect:<span class="cov0" title="0">
                return h.validateParityCheckParams(params)</span>
        case async.TypeBulkContainer:<span class="cov0" title="0">
                return h.validateBulkContainerParams(params)</span>
        case async.TypeBulkVM:<span class="cov0" title="0">
                return h.validateBulkVMParams(params)</span>
        case async.TypeArrayStart, async.TypeArrayStop:<span class="cov0" title="0">
                return h.validateArrayOperationParams(params)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateParityCheckParams validates parity check parameters
func (h *HTTPServer) validateParityCheckParams(params map[string]interface{}) error <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Validate check type
        <span class="cov0" title="0">if checkType, ok := params["type"].(string); ok </span><span class="cov0" title="0">{
                validTypes := []string{"check", "correct"}
                valid := false
                for _, validType := range validTypes </span><span class="cov0" title="0">{
                        if checkType == validType </span><span class="cov0" title="0">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid parity check type '%s', must be 'check' or 'correct'", checkType)
                }</span>
        }
        
        // Validate priority
        <span class="cov0" title="0">if priority, ok := params["priority"].(string); ok </span><span class="cov0" title="0">{
                validPriorities := []string{"low", "normal", "high"}
                valid := false
                for _, validPriority := range validPriorities </span><span class="cov0" title="0">{
                        if priority == validPriority </span><span class="cov0" title="0">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid priority '%s', must be 'low', 'normal', or 'high'", priority)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// validateBulkContainerParams validates bulk container operation parameters
func (h *HTTPServer) validateBulkContainerParams(params map[string]interface{}) error <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("container_ids parameter is required for bulk container operations")
        }</span>
        
        // Validate container IDs
        <span class="cov0" title="0">containerIDs, ok := params["container_ids"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("container_ids must be an array of strings")
        }</span>
        
        <span class="cov0" title="0">if len(containerIDs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one container ID is required")
        }</span>
        
        <span class="cov0" title="0">if len(containerIDs) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum 50 containers allowed per bulk operation")
        }</span>
        
        // Validate each container ID
        <span class="cov0" title="0">seen := make(map[string]bool)
        for i, id := range containerIDs </span><span class="cov0" title="0">{
                if id == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("container ID at index %d cannot be empty", i)
                }</span>
                
                <span class="cov0" title="0">if seen[id] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate container ID: %s", id)
                }</span>
                <span class="cov0" title="0">seen[id] = true
                
                // Validate container ID format
                if len(id) &lt; 12 || !containerIDPattern.MatchString(id) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid container ID format: %s", id)
                }</span>
        }
        
        // Validate operation
        <span class="cov0" title="0">if operation, ok := params["operation"].(string); ok </span><span class="cov0" title="0">{
                validOperations := []string{"start", "stop", "restart", "pause", "resume"}
                valid := false
                for _, validOp := range validOperations </span><span class="cov0" title="0">{
                        if operation == validOp </span><span class="cov0" title="0">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid operation '%s', must be one of: %s", 
                                operation, strings.Join(validOperations, ", "))
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("operation parameter is required")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// validateBulkVMParams validates bulk VM operation parameters
func (h *HTTPServer) validateBulkVMParams(params map[string]interface{}) error <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("vm_ids parameter is required for bulk VM operations")
        }</span>
        
        // Validate VM IDs
        <span class="cov0" title="0">vmIDs, ok := params["vm_ids"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("vm_ids must be an array of strings")
        }</span>
        
        <span class="cov0" title="0">if len(vmIDs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one VM ID is required")
        }</span>
        
        <span class="cov0" title="0">if len(vmIDs) &gt; 20 </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum 20 VMs allowed per bulk operation")
        }</span>
        
        // Validate each VM ID
        <span class="cov0" title="0">seen := make(map[string]bool)
        for i, id := range vmIDs </span><span class="cov0" title="0">{
                if id == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("VM ID at index %d cannot be empty", i)
                }</span>
                
                <span class="cov0" title="0">if seen[id] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate VM ID: %s", id)
                }</span>
                <span class="cov0" title="0">seen[id] = true
                
                // Validate VM ID format
                if !vmIDPattern.MatchString(id) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid VM ID format: %s", id)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// validateArrayOperationParams validates array operation parameters
func (h *HTTPServer) validateArrayOperationParams(params map[string]interface{}) error <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Validate maintenance mode flag
        <span class="cov0" title="0">if _, ok := params["maintenance_mode"]; ok </span><span class="cov0" title="0">{
                if _, isBool := params["maintenance_mode"].(bool); !isBool </span><span class="cov0" title="0">{
                        return fmt.Errorf("maintenance_mode must be a boolean value")
                }</span>
        }
        
        // Validate check filesystem flag
        <span class="cov0" title="0">if _, ok := params["check_filesystem"]; ok </span><span class="cov0" title="0">{
                if _, isBool := params["check_filesystem"].(bool); !isBool </span><span class="cov0" title="0">{
                        return fmt.Errorf("check_filesystem must be a boolean value")
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateDiskID validates disk ID format and returns appropriate error
func (h *HTTPServer) ValidateDiskID(diskID string) *dto.APIError <span class="cov0" title="0">{
        if diskID == "" </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("disk_id", diskID, "disk ID cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if !diskIDPattern.MatchString(diskID) </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("disk_id", diskID, 
                        "invalid disk ID format (expected: disk1, parity, cache, etc.)")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateContainerID validates container ID format and returns appropriate error
func (h *HTTPServer) ValidateContainerID(containerID string) *dto.APIError <span class="cov0" title="0">{
        if containerID == "" </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("container_id", containerID, "container ID cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if len(containerID) &lt; 12 || !containerIDPattern.MatchString(containerID) </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("container_id", containerID, 
                        "invalid container ID format (expected: 12-64 hex characters)")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateVMID validates VM ID format and returns appropriate error
func (h *HTTPServer) ValidateVMID(vmID string) *dto.APIError <span class="cov0" title="0">{
        if vmID == "" </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("vm_id", vmID, "VM ID cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if !vmIDPattern.MatchString(vmID) </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("vm_id", vmID, 
                        "invalid VM ID format (expected: alphanumeric, underscore, or dash)")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateOperationID validates operation ID format and returns appropriate error
func (h *HTTPServer) ValidateOperationID(operationID string) *dto.APIError <span class="cov0" title="0">{
        if operationID == "" </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("operation_id", operationID, "operation ID cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if !operationIDPattern.MatchString(operationID) </span><span class="cov0" title="0">{
                return dto.NewParameterValidationError("operation_id", operationID, 
                        "invalid operation ID format (expected: UUID)")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package api

import (
        "net/http"

        "github.com/go-chi/chi/v5"
)

// handleVMGet handles GET /api/v1/vms/{name}
func (h *HTTPServer) handleVMGet(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">vm, err := h.api.vm.GetVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusNotFound, "VM not found: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusOK, vm, nil)</span>
}

// handleVMStats handles GET /api/v1/vms/{name}/stats
func (h *HTTPServer) handleVMStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.api.vm.GetVMStats(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get VM stats: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeStandardResponse(w, http.StatusOK, stats, nil)</span>
}

// handleVMConsole handles GET /api/v1/vms/{name}/console
func (h *HTTPServer) handleVMConsole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">console, err := h.api.vm.GetVMConsole(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get VM console: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "console": console,
                "vm_name": vmName,
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMStart handles POST /api/v1/vms/{name}/start
func (h *HTTPServer) handleVMStart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.vm.StartVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to start VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message": "VM started successfully",
                "vm_name": vmName,
                "action":  "start",
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMStop handles POST /api/v1/vms/{name}/stop
func (h *HTTPServer) handleVMStop(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">force := r.URL.Query().Get("force") == "true"
        err := h.api.vm.StopVM(vmName, force)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to stop VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "VM stopped successfully",
                "vm_name": vmName,
                "action":  "stop",
                "force":   force,
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMRestart handles POST /api/v1/vms/{name}/restart
func (h *HTTPServer) handleVMRestart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.vm.RestartVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to restart VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message": "VM restarted successfully",
                "vm_name": vmName,
                "action":  "restart",
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMPause handles POST /api/v1/vms/{name}/pause
func (h *HTTPServer) handleVMPause(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.vm.PauseVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to pause VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message": "VM paused successfully",
                "vm_name": vmName,
                "action":  "pause",
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMResume handles POST /api/v1/vms/{name}/resume
func (h *HTTPServer) handleVMResume(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.vm.ResumeVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to resume VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message": "VM resumed successfully",
                "vm_name": vmName,
                "action":  "resume",
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMHibernate handles POST /api/v1/vms/{name}/hibernate
func (h *HTTPServer) handleVMHibernate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.vm.HibernateVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to hibernate VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message": "VM hibernated successfully",
                "vm_name": vmName,
                "action":  "hibernate",
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMRestore handles POST /api/v1/vms/{name}/restore
func (h *HTTPServer) handleVMRestore(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">err := h.api.vm.RestoreVM(vmName)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to restore VM: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message": "VM restored successfully",
                "vm_name": vmName,
                "action":  "restore",
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}

// handleVMAutostart handles POST /api/v1/vms/{name}/autostart
func (h *HTTPServer) handleVMAutostart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vmName := chi.URLParam(r, "name")
        if vmName == "" </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "VM name is required")
                return
        }</span>

        <span class="cov0" title="0">enable := r.URL.Query().Get("enable") == "true"
        err := h.api.vm.SetVMAutostart(vmName, enable)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to set VM autostart: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "message":   "VM autostart updated successfully",
                "vm_name":   vmName,
                "action":    "autostart",
                "autostart": enable,
        }

        h.writeStandardResponse(w, http.StatusOK, response, nil)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/domalab/uma/daemon/logger"
        "github.com/gorilla/websocket"
)

// WebSocketManager manages WebSocket connections and broadcasting
type WebSocketManager struct {
        upgrader    websocket.Upgrader
        connections map[string]map[*websocket.Conn]*WebSocketClient
        mutex       sync.RWMutex
        httpServer  *HTTPServer
}

// WebSocketClient represents a connected WebSocket client
type WebSocketClient struct {
        conn      *websocket.Conn
        endpoint  string
        requestID string
        version   string
        send      chan []byte
        done      chan struct{}
}

// WebSocketMessage represents a WebSocket message
type WebSocketMessage struct {
        Type      string      `json:"type"`
        Data      interface{} `json:"data"`
        Timestamp string      `json:"timestamp"`
        RequestID string      `json:"request_id,omitempty"`
        Version   string      `json:"version,omitempty"`
}

// NewWebSocketManager creates a new WebSocket manager
func NewWebSocketManager(httpServer *HTTPServer) *WebSocketManager <span class="cov8" title="1">{
        return &amp;WebSocketManager{
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                // Allow all origins for now - in production, implement proper origin checking
                                return true
                        }</span>,
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                },
                connections: make(map[string]map[*websocket.Conn]*WebSocketClient),
                httpServer:  httpServer,
        }
}

// handleWebSocketUpgrade upgrades HTTP connection to WebSocket
func (wsm *WebSocketManager) handleWebSocketUpgrade(w http.ResponseWriter, r *http.Request, endpoint string) <span class="cov0" title="0">{
        // Extract request metadata
        requestID := wsm.httpServer.getRequestIDFromContext(r)
        if requestID == "" </span><span class="cov0" title="0">{
                requestID = wsm.httpServer.generateRequestID()
        }</span>
        <span class="cov0" title="0">version := wsm.httpServer.getAPIVersionFromContext(r)

        // Upgrade connection
        conn, err := wsm.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("WebSocket upgrade failed for %s: %v", endpoint, err)
                return
        }</span>

        // Create client
        <span class="cov0" title="0">client := &amp;WebSocketClient{
                conn:      conn,
                endpoint:  endpoint,
                requestID: requestID,
                version:   version,
                send:      make(chan []byte, 256),
                done:      make(chan struct{}),
        }

        // Register client
        wsm.registerClient(endpoint, conn, client)

        // Record connection metrics
        connectionCount := len(wsm.connections[endpoint])
        RecordWebSocketConnection(endpoint, "connect", connectionCount)

        // Start client handlers
        go client.writePump()
        go client.readPump(wsm)

        logger.Green("WebSocket client connected to %s [%s]", endpoint, requestID)</span>
}

// registerClient registers a new WebSocket client
func (wsm *WebSocketManager) registerClient(endpoint string, conn *websocket.Conn, client *WebSocketClient) <span class="cov0" title="0">{
        wsm.mutex.Lock()
        defer wsm.mutex.Unlock()

        if wsm.connections[endpoint] == nil </span><span class="cov0" title="0">{
                wsm.connections[endpoint] = make(map[*websocket.Conn]*WebSocketClient)
        }</span>
        <span class="cov0" title="0">wsm.connections[endpoint][conn] = client</span>
}

// unregisterClient removes a WebSocket client
func (wsm *WebSocketManager) unregisterClient(endpoint string, conn *websocket.Conn) <span class="cov0" title="0">{
        wsm.mutex.Lock()
        defer wsm.mutex.Unlock()

        if clients, exists := wsm.connections[endpoint]; exists </span><span class="cov0" title="0">{
                if client, exists := clients[conn]; exists </span><span class="cov0" title="0">{
                        close(client.done)
                        close(client.send)
                        delete(clients, conn)
                        conn.Close()

                        // Record disconnection metrics
                        connectionCount := len(clients) - 1 // -1 because we just removed it
                        RecordWebSocketConnection(endpoint, "disconnect", connectionCount)
                }</span>
        }
}

// broadcast sends a message to all clients connected to a specific endpoint
func (wsm *WebSocketManager) broadcast(endpoint string, messageType string, data interface{}) <span class="cov0" title="0">{
        wsm.mutex.RLock()
        clients := wsm.connections[endpoint]
        wsm.mutex.RUnlock()

        if len(clients) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">message := WebSocketMessage{
                Type:      messageType,
                Data:      data,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        messageBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to marshal WebSocket message: %v", err)
                return
        }</span>

        <span class="cov0" title="0">messagesSent := 0
        for conn, client := range clients </span><span class="cov0" title="0">{
                select </span>{
                case client.send &lt;- messageBytes:<span class="cov0" title="0">
                        messagesSent++</span>
                default:<span class="cov0" title="0">
                        // Client send buffer is full, disconnect
                        wsm.unregisterClient(endpoint, conn)</span>
                }
        }

        // Record message metrics
        <span class="cov0" title="0">if messagesSent &gt; 0 </span><span class="cov0" title="0">{
                RecordWebSocketMessage(endpoint, messageType)
        }</span>
}

// writePump handles writing messages to the WebSocket connection
func (client *WebSocketClient) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second) // Ping every 54 seconds
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                client.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-client.send:<span class="cov0" title="0">
                        client.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                client.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">if err := client.conn.WriteMessage(websocket.TextMessage, message); err != nil </span><span class="cov0" title="0">{
                                logger.Red("WebSocket write error: %v", err)
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        client.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := client.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-client.done:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// readPump handles reading messages from the WebSocket connection
func (client *WebSocketClient) readPump(wsm *WebSocketManager) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                wsm.unregisterClient(client.endpoint, client.conn)
        }</span>()

        <span class="cov0" title="0">client.conn.SetReadLimit(512)
        client.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        client.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                client.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := client.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                logger.Red("WebSocket read error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// WebSocket endpoint handlers

// handleSystemStatsWebSocket handles /api/v1/ws/system/stats
func (h *HTTPServer) handleSystemStatsWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">h.wsManager.handleWebSocketUpgrade(w, r, "system/stats")</span>
}

// handleDockerEventsWebSocket handles /api/v1/ws/docker/events
func (h *HTTPServer) handleDockerEventsWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">h.wsManager.handleWebSocketUpgrade(w, r, "docker/events")</span>
}

// handleStorageStatusWebSocket handles /api/v1/ws/storage/status
func (h *HTTPServer) handleStorageStatusWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">h.wsManager.handleWebSocketUpgrade(w, r, "storage/status")</span>
}

// startWebSocketBroadcasters starts background goroutines for broadcasting real-time data
func (h *HTTPServer) startWebSocketBroadcasters() <span class="cov8" title="1">{
        // Start system stats broadcaster
        go h.systemStatsBroadcaster()

        // Start Docker events broadcaster
        go h.dockerEventsBroadcaster()

        // Start storage status broadcaster
        go h.storageStatusBroadcaster()
}</span>

// systemStatsBroadcaster broadcasts system statistics every 5 seconds
func (h *HTTPServer) systemStatsBroadcaster() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                stats := h.collectSystemStats()
                h.wsManager.broadcast("system/stats", "system_stats", stats)
        }</span>
}

// collectSystemStats collects current system statistics
func (h *HTTPServer) collectSystemStats() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get CPU info
        if cpuInfo, err := h.api.system.GetCPUInfo(); err == nil </span><span class="cov0" title="0">{
                stats["cpu"] = map[string]interface{}{
                        "usage_percent": cpuInfo.Usage,
                        "temperature":   cpuInfo.Temperature,
                        "cores":         cpuInfo.Cores,
                }
        }</span>

        // Get memory info
        <span class="cov0" title="0">if memInfo, err := h.api.system.GetMemoryInfo(); err == nil </span><span class="cov0" title="0">{
                stats["memory"] = map[string]interface{}{
                        "total":           memInfo.Total,
                        "used":            memInfo.Used,
                        "free":            memInfo.Free,
                        "used_percent":    memInfo.UsedPercent,
                        "total_formatted": memInfo.TotalFormatted,
                        "used_formatted":  memInfo.UsedFormatted,
                }
        }</span>

        // Get uptime
        <span class="cov0" title="0">if uptimeInfo, err := h.api.system.GetUptimeInfo(); err == nil </span><span class="cov0" title="0">{
                stats["uptime"] = map[string]interface{}{
                        "seconds":   uptimeInfo.Uptime,
                        "formatted": fmt.Sprintf("%.0f seconds", uptimeInfo.Uptime),
                }
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// dockerEventsBroadcaster broadcasts Docker events
func (h *HTTPServer) dockerEventsBroadcaster() <span class="cov8" title="1">{
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        var lastContainerStates map[string]string

        for range ticker.C </span><span class="cov0" title="0">{
                events := h.collectDockerEvents(&amp;lastContainerStates)
                if len(events) &gt; 0 </span><span class="cov0" title="0">{
                        h.wsManager.broadcast("docker/events", "docker_events", events)
                }</span>
        }
}

// collectDockerEvents collects Docker container state changes
func (h *HTTPServer) collectDockerEvents(lastStates *map[string]string) []map[string]interface{} <span class="cov0" title="0">{
        var events []map[string]interface{}

        if *lastStates == nil </span><span class="cov0" title="0">{
                *lastStates = make(map[string]string)
        }</span>

        // Get current container states
        <span class="cov0" title="0">containers, err := h.api.docker.ListContainers(true) // Include all containers
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to get Docker containers for events: %v", err)
                return events
        }</span>

        <span class="cov0" title="0">currentStates := make(map[string]string)

        for _, container := range containers </span><span class="cov0" title="0">{
                containerID := container.ID
                currentState := container.State
                currentStates[containerID] = currentState

                // Check for state changes
                if lastState, exists := (*lastStates)[containerID]; exists </span><span class="cov0" title="0">{
                        if lastState != currentState </span><span class="cov0" title="0">{
                                // State changed
                                events = append(events, map[string]interface{}{
                                        "container_id":   containerID,
                                        "container_name": container.Name,
                                        "previous_state": lastState,
                                        "current_state":  currentState,
                                        "event_type":     "state_change",
                                        "timestamp":      time.Now().UTC().Format(time.RFC3339),
                                })
                        }</span>
                } else<span class="cov0" title="0"> {
                        // New container detected
                        events = append(events, map[string]interface{}{
                                "container_id":   containerID,
                                "container_name": container.Name,
                                "current_state":  currentState,
                                "event_type":     "container_discovered",
                                "timestamp":      time.Now().UTC().Format(time.RFC3339),
                        })
                }</span>
        }

        // Check for removed containers
        <span class="cov0" title="0">for containerID, lastState := range *lastStates </span><span class="cov0" title="0">{
                if _, exists := currentStates[containerID]; !exists </span><span class="cov0" title="0">{
                        events = append(events, map[string]interface{}{
                                "container_id": containerID,
                                "last_state":   lastState,
                                "event_type":   "container_removed",
                                "timestamp":    time.Now().UTC().Format(time.RFC3339),
                        })
                }</span>
        }

        <span class="cov0" title="0">*lastStates = currentStates
        return events</span>
}

// storageStatusBroadcaster broadcasts storage status updates
func (h *HTTPServer) storageStatusBroadcaster() <span class="cov8" title="1">{
        ticker := time.NewTicker(30 * time.Second) // Check storage every 30 seconds
        defer ticker.Stop()

        var lastDiskStates map[string]string

        for range ticker.C </span><span class="cov0" title="0">{
                updates := h.collectStorageUpdates(&amp;lastDiskStates)
                if len(updates) &gt; 0 </span><span class="cov0" title="0">{
                        h.wsManager.broadcast("storage/status", "storage_updates", updates)
                }</span>
        }
}

// collectStorageUpdates collects storage status changes
func (h *HTTPServer) collectStorageUpdates(lastStates *map[string]string) []map[string]interface{} <span class="cov0" title="0">{
        var updates []map[string]interface{}

        if *lastStates == nil </span><span class="cov0" title="0">{
                *lastStates = make(map[string]string)
        }</span>

        // Get current disk information
        <span class="cov0" title="0">disksInfo, err := h.api.storage.GetConsolidatedDisksInfo()
        if err != nil </span><span class="cov0" title="0">{
                logger.Red("Failed to get disk info for storage updates: %v", err)
                return updates
        }</span>

        <span class="cov0" title="0">currentStates := make(map[string]string)

        // Check all disk types
        allDisks := make([]interface{}, 0)
        for _, disk := range disksInfo.ArrayDisks </span><span class="cov0" title="0">{
                allDisks = append(allDisks, disk)
        }</span>
        <span class="cov0" title="0">for _, disk := range disksInfo.ParityDisks </span><span class="cov0" title="0">{
                allDisks = append(allDisks, disk)
        }</span>
        <span class="cov0" title="0">for _, disk := range disksInfo.CacheDisks </span><span class="cov0" title="0">{
                allDisks = append(allDisks, disk)
        }</span>
        <span class="cov0" title="0">if disksInfo.BootDisk != nil </span><span class="cov0" title="0">{
                allDisks = append(allDisks, *disksInfo.BootDisk)
        }</span>

        <span class="cov0" title="0">for _, diskInterface := range allDisks </span><span class="cov0" title="0">{
                // Type assertion to get disk information
                diskMap, ok := diskInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">device, _ := diskMap["device"].(string)
                health, _ := diskMap["health"].(string)
                status, _ := diskMap["status"].(string)

                if device == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">currentState := fmt.Sprintf("%s:%s", status, health)
                currentStates[device] = currentState

                // Check for state changes
                if lastState, exists := (*lastStates)[device]; exists </span><span class="cov0" title="0">{
                        if lastState != currentState </span><span class="cov0" title="0">{
                                updates = append(updates, map[string]interface{}{
                                        "device":         device,
                                        "previous_state": lastState,
                                        "current_state":  currentState,
                                        "health":         health,
                                        "status":         status,
                                        "event_type":     "disk_state_change",
                                        "timestamp":      time.Now().UTC().Format(time.RFC3339),
                                })
                        }</span>
                } else<span class="cov0" title="0"> {
                        // New disk detected
                        updates = append(updates, map[string]interface{}{
                                "device":        device,
                                "current_state": currentState,
                                "health":        health,
                                "status":        status,
                                "event_type":    "disk_discovered",
                                "timestamp":     time.Now().UTC().Format(time.RFC3339),
                        })
                }</span>
        }

        <span class="cov0" title="0">*lastStates = currentStates
        return updates</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
